---
title: "Analysis"
subtitle: "Full analyses and plots"
author: "Mathilde Josserand"
date: "`r date()`"
format:
  html: 
    toc: true
    html-math-method: katex
    toc-depth: 3
    theme: cerulean
    fontsize: 0.95em
    #number-sections: true
crossref:
  fig-title: '**Figure**'
  labels: arabic
  title-delim: "**.**"
---

```{r}
#| message: false
#| warning: false
#| echo: false

# load libraries
library(dplyr)
library(ggplot2)
library(stringr)
library(tidyr)
library(stringdist) # for levenshtein distance
library(DescTools) # for entropy
library(gridExtra)
library(cba) # for distance between words
#library(kableExtra)
library(knitr)
library(rstatix) # for anova tests
library(lmerTest) # for mixed effect models
library(boot) # for bootstrapping
library(MuMIn) # for computing R2 in mixed effect model
library(reshape) # for function melt to create heatmap
library(GGally)
library(ggpubr)
library(lmeresampler) # for bootstrapping
library(lme4) # for bootstrapping too

## Knitting options:
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE,   
                      fig.pos = "!H", # default code chunk options
                      fig.width=10, fig.height=7, fig.align="center", comment=NA, 
                      fig.path="./figures/",                                      
                      dpi=300, dev="jpeg", cache=FALSE, autodep=TRUE);              

## Various folders:
if( !dir.exists("./figures") ) dir.create("./figures", showWarnings=FALSE)

## affect colour
scale_colour_continuous <- scale_colour_viridis_c(end=0.8)
scale_colour_discrete <- scale_colour_viridis_d(end=0.8)
scale_colour_binned <- scale_colour_viridis_b(end=0.8)
scale_fill_continuous <- scale_fill_viridis_c(end=0.8)
scale_fill_discrete <- scale_fill_viridis_d(end=0.8)
scale_fill_binned <- scale_fill_viridis_b(end=0.8)

## affect general theme
theme_set(theme_bw(base_size = 20))
```

```{r}
#| message: false
#| warning: false
#| echo: false

# Standard error function
se <- function(x) sd(x)/sqrt(length(x))

# normalized levenstein distance between x and y
# weights correspond to deletion, insertion, match and replacement
normdist <- function(x,y) {
  sdists(x,y, weight=c(1,1,0,1))[,]/max(nchar(x),nchar(y))
}

normdist.vec <- function(x,y){
# This is a convenience wrapper for vectorizing normdist()
  sapply(x, normdist, y, simplify = TRUE, USE.NAMES = FALSE)
}

meandist_motion <- function(m1, m2) {
# distance between two meanings with continous motion

  # penalty for mismatched shape
  (m1$Shape != m2$Shape) + 
    # standardized, directionless difference in angle note that this may not
    # translate perfectly to other programming languages depending on how they
    # handle the modulus of negative numbers
    pmin( (m1$Angle - m2$Angle) %% 360,
          (m2$Angle - m1$Angle) %% 360 ) / 180
}


#levenstein distances between all pairs of words in a given list
# weights correspond to deletion, insertion, match and replacement
normdist <- function(x,y) {
  sdists(x,y, weight=c(1,1,0,1))[,]/max(nchar(x),nchar(y))
}
allpairslev <- function(words) {
  l <- length(words)
  unlist(sapply(1:(l-1),function(x) sapply((x+1):l,function(y) normdist(words[x],words[y]))))
}
# modify function to return mean Levenshtein distance
allpairslev_mean <- function(words) {
  l <- length(words)
  pairwise_distances <- unlist(sapply(1:(l-1),function(x) sapply((x+1):l,function(y) normdist(words[x],words[y]))))
  return(mean(pairwise_distances))
}


#levenstein distances between all pairs of words from rounds n and n-1 
allpairslev_rounds <- function(itemwords,l1) {
if (l1==0) return(NA) else
  l <- length(itemwords)
  unlist(sapply(1:l1,function(x) sapply((l1+1):l,function(y) normdist(itemwords[x],itemwords[y]))))
}

#semantic distances between all pairs of meanings (without same item)
allpairshamm <- function(ID,meanings) {
  l <-length(meanings)/2  # number of semantic dimensions
  unlist(sapply(1:(l-1),function(x) sapply((x+1):l,function(y)  if (ID[x]!=ID[y]) meandist_motion(meanings[,x],meanings[,y]))))
}

#levenstein distances between all pairs of words (without same item)
allpairslev_diff <- function(ID, words) {
  l <- length(words)
  unlist(sapply(1:(l-1),function(x) sapply((x+1):l,function(y) if (ID[x]!=ID[y]) normdist(words[x],words[y]))))
}

# levenstein distances between a word and all rest in one list (input variability)
allpairslev_var2 <- function(words) {
   l <- length(words)
   if (l>0) {
     words <- na.omit(words)
      sapply(1:l, function(x) sapply(1:l, function(y) if (x!=y) {normdist(words[x],words[y])} else {NA}))
   } else {NA}
}

# minimum Levenshtein distance between a word and a list of words
lev_word_listword <- function(ListWords, MyWord) {
   l <- length(ListWords)
   if (l>0) {
     ListWords <- na.omit(ListWords)
      sapply(1:l, function(x) if (x!=MyWord) {normdist(MyWord,ListWords[x])} else {NA})
   } else {NA}
}

#the structure calculation: calculate the correlation between meaning distances and word distances in a participant's languages
correlation_test <- function(ID,meanings,words) {
  hamms <- allpairshamm(ID, meanings)
  hamms <- hamms[hamms!=0]
  levs <- allpairslev_diff(ID,words)
  veridical <- cor(hamms,levs,use="complete.obs")
  
  return(list(veridical=veridical))
}

# add grey rectangles in plots (from Round 1 to Round 9)
add_grey_rect_1_9 <- function(myplot){
  myplot <- myplot +
    geom_rect(color="grey90", fill="grey90",alpha=0.1, aes(xmin=0.6,xmax=1.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey80",fill="grey80",alpha=0.1, aes(xmin=1.6,xmax=2.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey70",fill="grey70",alpha=0.1, aes(xmin=2.6,xmax=3.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey90",fill="grey90",alpha=0.1, aes(xmin=3.6,xmax=4.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey80",fill="grey80",alpha=0.1, aes(xmin=4.6,xmax=5.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey70",fill="grey70",alpha=0.1, aes(xmin=5.6,xmax=6.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey90",fill="grey90",alpha=0.1, aes(xmin=6.6,xmax=7.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey80",fill="grey80",alpha=0.1, aes(xmin=7.6,xmax=8.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey70",fill="grey70",alpha=0.1, aes(xmin=8.6,xmax=9.6,ymin=-Inf, ymax=Inf)) 
    #scale_x_discrete(breaks = c(1:9))
  return(myplot)
}

# add grey rectangles in plots (from Round 0 to Round 10)
add_grey_rect_0_10 <- function(myplot){
  myplot <- myplot +
    geom_rect(color="white", fill="white",alpha=0.1, aes(xmin=-0.6,xmax=0.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey90", fill="grey90",alpha=0.1, aes(xmin=0.6,xmax=1.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey80",fill="grey80",alpha=0.1, aes(xmin=1.6,xmax=2.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey70",fill="grey70",alpha=0.1, aes(xmin=2.6,xmax=3.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey90",fill="grey90",alpha=0.1, aes(xmin=3.6,xmax=4.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey80",fill="grey80",alpha=0.1, aes(xmin=4.6,xmax=5.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey70",fill="grey70",alpha=0.1, aes(xmin=5.6,xmax=6.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey90",fill="grey90",alpha=0.1, aes(xmin=6.6,xmax=7.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey80",fill="grey80",alpha=0.1, aes(xmin=7.6,xmax=8.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey70",fill="grey70",alpha=0.1, aes(xmin=8.6,xmax=9.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="white", fill="white",alpha=0.1, aes(xmin=9.6,xmax=10.6,ymin=-Inf, ymax=Inf)) 
    #scale_x_continuous(breaks = c(0:10))
  return(myplot)
}

# Create summary of data
data_summary <- function(x) {
   m <- mean(x)
   ymin <- m-se(x)
   ymax <- m+se(x)
   return(c(y=m,ymin=ymin,ymax=ymax))
}

# Compute the measure for adaptibility (method 3)
compute_adapt3 <- function(goodword, latest_it, listen, produce){
  # when the latest word was the "good" word
  if (latest_it == goodword & listen == goodword & produce == goodword){
    adapt3 = 0
  }
  if (latest_it == goodword & listen == goodword & produce != goodword){
    adapt3 = -1
  }
  if (latest_it == goodword & listen != goodword & produce == goodword){
    adapt3 = -0.5
  }
  if (latest_it == goodword & listen != goodword & produce == listen){
    adapt3 = 1.5
  }
  if (latest_it == goodword & listen != goodword & produce != listen & produce != goodword){
    adapt3 = -0.5
  }
  # when the latest word was *not* the "good" word
  if (latest_it != goodword & listen == goodword & produce == goodword){
    adapt3 = 1
  }
  if (latest_it != goodword & listen == goodword & produce != goodword){
    adapt3 = -1.5
  }
  if (latest_it != goodword & listen != latest_it & produce == goodword){
    adapt3 = 0
  }
  if (latest_it != goodword & listen != latest_it & produce == latest_it){
    adapt3 = 0
  }
  if (latest_it != goodword & listen != latest_it & produce != latest_it & produce != goodword){
    adapt3 = -0.5
  }
  
  if (latest_it != goodword & (listen != goodword & listen != latest_it) & produce == goodword){
    adapt3 = 0
  }
  if (latest_it != goodword & (listen != goodword & listen != latest_it) & produce == latest_it){
    adapt3 = -1
  }
  if (latest_it != goodword & (listen != goodword & listen != latest_it) & produce == listen){
    adapt3 = 1
  }
    if (latest_it != goodword & (listen != goodword & listen != latest_it) & (produce != listen & produce != goodword & produce != latest_it)){
    adapt3 = -0.5
    }
  return(adapt3)
}


compute_adapt4<- function(latest_it, listen, produce){
  d1 <- normdist(produce, listen)
  d2 <- normdist(produce, latest_it)
  adapt4 = 2*(1-d1) + d2
  return(adapt4)
}
```

```{r}
#| echo: false
#| message: false
#| warning: false

# --- READ FILES for DATA--- #

# enter path file
pathfiles = "C:/Users/Mathilde JOSSERAND/Documents/ExpCommunityVariation/InputFiles/Data_processed/"

# list all files in the folder
lfiles = list.files(path=pathfiles, pattern=NULL, all.files=FALSE,full.names=FALSE)

# read these files, add a short/long column and an ID column, and bind
df = data.frame(matrix(ncol=24, nrow=0))

for (fil in lfiles){
    # read file
    d <- read.csv(paste(pathfiles,  fil, sep=""), header=T, sep=";")
    # bind to other dataframe
    df <- rbind(df, d)
}

df <- df%>%
  mutate(GroupType = case_when(GroupType == "HT" ~ "Hetero",
                               GroupType == "HM" ~ "Control")) %>%
  mutate(Shape = case_when(Shape == 0 ~ "nusa",
                           Shape == 1 ~ "nus",
                           Shape == 2 ~ "kesip",
                           Shape == 3 ~ "esip",
                           Shape == 4 ~ "puak",
                           Shape == 5 ~ "nekuki",
                           Shape == 6 ~ "anap",
                           Shape == 7 ~ "aike")) %>%
  mutate(Round = ifelse(TypeTest=="final_testing", 10, Round)) %>%
  mutate(TypeTest = case_when(TypeTest == "testing_set" ~ "FirstTesting",
                              TypeTest == "final_testing" ~ "SecondTesting",
                              TypeTest == "ComGame_Guesser" ~ "ComGame",
                              TypeTest == "block1_passive_exp" ~ "PassiveExposure",
                              TypeTest == "block2_passive_exp" ~ "PassiveExposure")) %>%
  mutate(GroupID = paste(GroupNum, GroupType, sep="_")) %>%
  dplyr::rename(Producer = PartID,
         Guesser = Partner) %>%
  mutate(Producer = as.factor(Producer),
        Guesser = as.factor(Guesser),
         pair = as.factor(pair),
         GroupNum = as.factor(GroupNum),
         TypeTest = as.factor(TypeTest),
         Shape = as.factor(Shape),
         GroupType = as.factor(GroupType),
         GroupID = as.factor(GroupID)) %>%
  dplyr::select(-c(ChosenItem, KeyPressed, PositionItem)) 


# --- CREATE DISTANCE TO LABEL COLUMN --- #

# create a column with distance with init label
# use loop because impossible to run directly
df$DistInitLabel <- NA
for (row in c(1:nrow(df))){
  df$DistInitLabel[row] <- 1 - normdist(df$Word[row], as.character(df$Shape[row]))
}


## CREATE DISTANCE TO LABEL COLUMN ADAPTED TO BIASED (we do not keep this method as it is too biased..)

# LIST_ALPHABET <- c("s", "p", "n", "i", "e", "u", "")
# 
# # When 2 characters to change
# list_aike <- c()
# list_nekuki <- c()
# list_puak <- c()
# list_anap <- c()
# 
# for (l1 in LIST_ALPHABET){
#   for (l2 in LIST_ALPHABET){
#     # aike
#     new_aike <- gsub("a", l1, "aike")
#     new_aike <- gsub("k", l2, new_aike)
#     list_aike <- c(list_aike, new_aike)
#     # nekuki
#     new_nekuki <- gsub("a", l1, "nekuki")
#     new_nekuki <- gsub("k", l2, new_nekuki)
#     list_nekuki <- c(list_nekuki, new_nekuki)
#     # puak
#     new_puak <- gsub("a", l1, "puak")
#     new_puak <- gsub("k", l2, new_puak)
#     list_puak <- c(list_puak, new_puak)
#     # anap
#     new_anap <- gsub("a", l1, "anap")
#     new_anap <- gsub("k", l2, new_anap)
#     list_anap <- c(list_anap, new_anap)
#   }
# }
# # When 1 character to change
# list_kesip <- c()
# list_nusa <- c()
# for (l1 in LIST_ALPHABET){
#     # kesip
#     new_kesip <- gsub("a", l1, "kesip")
#     list_kesip <- c(list_kesip, new_kesip)
#     # nusa
#     new_nusa <- gsub("a", l1, "nusa")
#     list_nusa <- c(list_nusa, new_nusa)
# }
# 
# for (row in c(1:nrow(df))){
#   if ((df$GroupType[row] =="Control") | (df$Producer[row] != 1) | (df$Producer[row]==1 & df$Shape[row]=="esip") | (df$Producer[row] ==1 & df$Shape[row]=="nus")) {
#     df$DistInitLabel2[row] <- df$DistInitLabel[row]
#   }
#   else if (df$Shape[row]=="aike"){
#     df$DistInitLabel2[row] <-  min(lev_word_listword(list_aike, df$Word[row]))
#   }
#   else if (df$Shape[row]=="anap"){
#     df$DistInitLabel2[row] <-  min(lev_word_listword(list_anap, df$Word[row]))
#   }
#   else if (df$Shape[row]=="nekuki"){
#     df$DistInitLabel2[row] <-  min(lev_word_listword(list_nekuki, df$Word[row]))
#   }
#   else if (df$Shape[row]=="puak"){
#     df$DistInitLabel2[row] <-  min(lev_word_listword(list_puak, df$Word[row]))
#   }
#   else if (df$Shape[row]=="nusa"){
#     df$DistInitLabel2[row] <-  min(lev_word_listword(list_nusa, df$Word[row]))
#   }
#   else if (df$Shape[row]=="kesip"){
#     df$DistInitLabel2[row] <-  min(lev_word_listword(list_kesip, df$Word[row]))
#   }
# }

## INSTEAD we compute it based on the manual coding


for (row in c(1:nrow(df))){
  if ( !(df$GroupType[row] == "Hetero" & df$Producer[row] == 1 & df$Shape[row] !="nus" & df$Shape[row] != "esip") ){
    df$distance[row] <- 1 - as.numeric(normdist(df$Word[row], as.character(df$Shape[row])))
  } else {
    df$distance[row] <- 1 - as.numeric(df$distance[row])
  }
}
df <- df %>% 
  dplyr::rename(DistInitLabel2 = distance) %>%
  mutate(DistInitLabel2 = replace_na(DistInitLabel2, 1))



# --- READ FILES for OTHER--- #

# enter path file
pathfiles = "C:/Users/Mathilde JOSSERAND/Documents/ExpCommunityVariation/InputFiles/Other/"

# list all files in the folder
lfiles_other = list.files(path=pathfiles, pattern=NULL, all.files=FALSE,full.names=FALSE)

# read these files, add a short/long column and an ID column, and bind
df_other = data.frame(matrix(ncol=24, nrow=0))

for (fil in lfiles_other){
    # read file
    d_other <- read.csv(paste(pathfiles,  fil, sep=""), header=T, sep=",")
    if (grepl( "M", fil, fixed = TRUE)){
      d_other$GroupType = "Control"
    } else {
      d_other$GroupType = "Hetero"
    }
    # bind to other dataframe
    df_other <- rbind(df_other, d_other)
}

# little problem: sometimes they read F as FALSE instead of just F
df_other$Gender[df_other$Gender=="FALSE"] <- "F"

df_other <- df_other %>%
  dplyr::rename(WorkingMem = invefi,
         DictatorGame = Game,
         CogFlexibility = diff_norm)
```

# Method

This part provide additional information concerning the Method. For the general design, please refer to the paper.

## Participants

`r nrow(df_other)` participants participated in this study (`r nrow(df_other[df_other$Gender=="F",])` women and `r nrow(df_other[df_other$Gender=="M",])` men. They were between the ages of 18 and 50 (M= `r round(mean(df_other$Age))`, SD=`r round(sd(df_other$Age))` . Please refer to [Predictors] to see more about the distribution of age, gender, and other measures.

## Setup

![**Illustration 1.** The experimental design. Participants were sitting face to face on the chairs.](Pictures/Photo_Design.jpg){alt="Illustration 2. Visual representation of the procedure. See below for more information."}

## Stimuli

Stimuli were squares of size 300\*300 pixel when being presented the 8 together, and 400\*400 pixel the rest of the time.

## Procedure

Here are presented the instructions foe each part.

-   **Passive exposure:** Dadelijk zie je een aantal afbeeldingen een voor een op het scherm verschijnen samen met het woord in fantasietaal dat die afbeelding beschrijft. Probeer zo goed mogelijk het juiste woord bij elke afbeelding te onthouden.

-   **First Testing (Round 0):** Nu is het tijd om te testen hoe goed je de fantasietaal onthoudt! U ziet dezelfde afbeeldingen. Denk goed na over hoe je ze een naam zou geven en druk op enter als je klaar bent om te typen (tijdens het typen kun je de scene niet meer zien). Maak je geen zorgen als je de naam van de afbeelding niet meer weet en beproef je geluk door een woord te typen.

-   **Communication game, Guesser:** Je partner heeft een afbeelding gezien en een woord getypt om het te beschrijven. Lees het woord op de computer van je partner en kies de juiste afbeelding uit de 8 mogelijke afbeeldingen (gebruik 1-2-3-4-5-6-7-8 op het toetsenbord om een keuze te maken). Je krijgt feedback over je keuze, probeer er van te leren. Maak tijdens het experiment zo min mogelijk fouten! Vergeet niet om de feedback aan je partner te laten zien. Je krijgt feedback over je keuze, probeer daarvan te leren

-   **Communication game, Producer:** Nu krijg je een afbeelding te zien. Denk na over hoe je het zou noemen en druk op Enter als je klaar bent om te typen. Als je klaar bent met het schrijven van het woord, druk je nogmaals op enter en draai je de computer zodat je partner het woord kan lezen en kan raden welke afbeelding je beschrijft. Tijdens deze taak mag je de taal niet wijzigen naar Nederlands of andere bestaande talen. Gebruik ook niets dat heel erg op het Nederlands of andere talen lijkt. Ook mag je geen Nederlandse afkortingen, afkortingen of acroniemen gebruiken. Let op, je kunt niet alle letters gebruiken: alleen de letters die zichtbaar zijn op het toetsenbord kunnen worden gebruikt.

<!-- -->

-   **Testing (Round 10):** Nu hoef je niet meer met je partner te communiceren. U moet een reeks afbeeldingen een naam geven in de nieuwe taal die u gebruikte.

## Measures

All measures are described within the results.

## Additional tasks

The study included three additional tasks.

### Prosociality scale.

This questionnaire consists of 16 items that measure different aspects of prosocial behavior such as empathic concern, altruism, and volunteering using a 5-point Likert scale ranging from 1 (never) to 5 (very often).

**English version:**

The following statements describe a large number of common situations. There are no right or wrong answers; the best answer is the immediate, spontaneous one. Read each phrase carefully and fill in the number that reflects your first reaction.

The possible answers were: *Never/Almost Never*,*Rarely*,*Occasionally*,*Often*,*Always/Almost Always*

-   I am pleased to help my friends/colleagues in their activities
-   I share the things that I have with my friends
-   I try to help others.
-   I am available for volunteer activities to help those who are in need
-   I am empathic with those who are in need
-   I help immediately those who are in need
-   I do what I can to help others avoid getting into trouble.
-   I intensely feel what others feel
-   I am willing to make my knowledge and abilities available to others
-   I try to console those who are sad
-   I easily lend money or other things
-   I easily put myself in the shoes of those who are in discomfort
-   I try to be close to and take care of those who are in need
-   I easily share with friends any good opportunity that comes to me
-   I spend time with those friends who feel lonely
-   I immediately sense my friends' discomfort even when it is not directly communicated to me

This was translated into Dutch from English.

**Dutch version**:

De volgende uitspraken beschrijven een groot aantal veelvoorkomende situaties. Er zijn geen goede of foute antwoorden; het beste antwoord is het onmiddellijke, spontane antwoord. Lees elke zin aandachtig en vul het nummer in dat uw eerste reactie weergeeft. Vergeet niet dat deze gegevens volledig anoniem zijn. Gebruik 1-2-3-4-5 op het toetsenbord om een keuze te maken.

*Nooit/bijna nooit*, *Zelden*, *Af en toe*, *Vaak*, *Altijd/bijna altijd*

-   Ik help graag mijn vrienden/collega's bij hun activiteiten.
-   Ik deel de dingen die ik heb met mijn vrienden.
-   Ik probeer anderen te helpen.
-   Ik ben beschikbaar voor vrijwilligersactiviteiten om mensen in nood te helpen.
-   Ik ben empathisch voor degenen die in nood zijn.
-   Ik help onmiddellijk degenen die in nood zijn.
-   Ik doe wat ik kan om anderen te helpen voorkomen dat ze in de problemen komen.
-   Ik voel intens wat anderen voelen
-   Ik ben bereid mijn kennis en vaardigheden beschikbaar te stellen aan anderen.
-   Ik probeer degenen die verdrietig zijn te troosten.
-   Ik leen gemakkelijk geld of andere dingen uit.
-   Ik plaats mezelf gemakkelijk in de schoenen van degenen die zich ongemakkelijk voelen.
-   Ik probeer dichtbij te zijn en te zorgen voor degenen die in nood zijn
-   Ik deel gemakkelijk elke goede kans die ik krijg met vrienden.
-   Ik breng tijd door met die vrienden die zich eenzaam voelen
-   Ik voel het ongemak van mijn vrienden onmiddellijk, zelfs als het niet rechtstreeks aan mij wordt meegedeeld.

### Dictator Game

This version of the Dictator Game is adapted in the context of the experiment. We included this task as another way to measure prosociality. Participants were presented with the following fictional situation:

**English version**:

Imagine that I give you an additional amount of 100 euros due to the excellent performance of your group during this experiment. Now, you have the choice to keep the full amount for yourself or to share it with the other participants. Since the other participants are not aware of this extra reward, the choice is entirely up to you. How much do you decide to share with the other participants?

They had the choice between:

-   keeping everything for them (1)
-   sharing but keeping more for them (2)
-   equally splitting (3)
-   sharing but keeping less (4)
-   giving everything (5)

**Dutch version**:

Stel je voor dat ik je een extra bedrag van 100 euro geef vanwege de uitstekende prestaties van jouw groep tijdens dit experiment. Nu heb je de keuze om het volledige bedrag voor jezelf te houden, of het te delen met de andere deelnemers. Aangezien de andere deelnemers niet op de hoogte zijn van deze extra beloning, is de keuze geheel aan jou. Hoeveel besluit je te delen met de andere deelnemers?

-   (1): 0 euro (Ik houd alle 100 euro)
-   (2): Tussen 0 en 75 euro (Ik deel, maar houd meer voor mezelf)
-   (3): 75 euro (25 euro voor iedereen)
-   (4): Tussen 75 en 100 euro (Ik houd minder dan hen)
-   (5): 100 euro (Ik geef alles weg)

### Task-switching experiment

The task-switching experiment adapted from Roger and Monsell's paradigm. An online version is available to try at this address: <https://www.psytoolkit.org/experiment-library/taskswitching.html>

The code of the task-switching experiment and the prosciality experiment are all available in the same file as for the code of the main experiment (see my github [mathjoss/ExpCommunityVariation](https://github.com/mathjoss/ExpCommunityVariation)).

![**Illustration 2.** Instructions for the task-switching experiment as presented to the participant. The front line shows the "letter task" (press Q for consonants and P for vowels) and the bottom line shows the instructions for the "number task" (press Q for odd numbers and P for even numbers). The participant is first trained only with the first row (the combination of letter/number alternatively switch from the left to the right), then with the number task only in the bottom. After, the participant performed both conditions (letter task and number task) at the same time (the combination of letter number/number successively switch from up left, to up right, to bottom right, to bottom left.)](Pictures/InstructionsTask.PNG){width="527"}

# Data

## Terminology

Throughout the results, we will use the following terminology:

-   *Group* refers to the group ID: when using the terminology "for each group", I will mean for each group of 4 that came to the lab.

-   *Condition* refers to the group type: heterogenous or control.

-   *Initial labels* refers to the 8 initial words used to describe aliens presented in the passive exposure

-   *Unbiased participants* are participant 2, 3, and 4 (who can produce all letters) and *biased participant* designate participant 1 (who can not produce a and k). This is consistent across all groups.

-   *Unbiased letters* designate letters who can be produced by all participants (p, s, n, e, i, u) and *biased letters* designate the 2 letters that cannot be produced by the biased participants

## Read files

We proceed and clean the files using the following methods:

After each group passation, we use the file `CleanUpFiles.R` to perform the following steps:

1.  **Data.** merge the dataset obtained from the 4 participants into 1 single file using the R file

2.  **Prosociality**. For each participant, we compute the total prosociality score by additioning the results on each question

3.  **Inverse efficiency.** For each participant, we compute the inverse efficiency, where inverse efficiency is defined as $mean(time)/mean(accuracy)$

4.  **Cognitive Flexibility.** We measure each participant's cognitive flexibility by examining their performance in a task that involves both numbers and letters. To do this, we calculate two average times: one for when the participant does not switch tasks (moving between letters or numbers) and another for when they do switch tasks (moving from numbers to letters or vice versa). The difference between these two averages represents their cognitive flexibility. We further normalize this difference by dividing it by the mean time required for task switching.

The "***data***" files are named after the group number and type, and it is saved as a .csv file. For instance, Group1HT.csv represents the data file for Group 1 Heterogenous.

The "***other***" measures (prosociality, inverse efficiency, cognitive flexibility) are summarized in a separate data file starting with `Other_Groupâ€¦,` which includes the group number and type. This file also contains information about **age**, **gender**, and results in the **dictator game**.

We merge datasets from all groups, thus obtaining two datasets:

-   the dataset with ***data*** from all groups:

```{r}
#| echo: false
#| message: false
#| warning: false
summary(df)
```

-   the dataset with ***other*** information from all groups:

```{r}
#| echo: false
#| message: false
#| warning: false
summary(df_other)
```

## Raw outputs

We look at the productions during the *FirstTesting* and the last testing (called here *SecondTesting*). As a reminder, FirstTesting occurs after the passive exposure, and SecondTesting occurs after the communication game.

### Heterogenous groups

**Group 1**:

*Before* training:

```{r}
#| echo: false 
#| message: false 
#| warning: false  

# print for each group
df %>%     
  filter(TypeTest == "FirstTesting" & GroupNum == 1 & GroupType == "Hetero") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> first_name    
colnames(first_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")  

df %>%     
  filter(TypeTest == "SecondTesting" & GroupNum == 1 & GroupType == "Hetero") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> last_name
colnames(last_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")      

kable(first_name)   


```

*After training*:

```{r}
#| echo: false 
#| message: false 
#| warning: false

kable(last_name) 
```

**Group 2**:

*Before* training:

```{r}
#| echo: false 
#| message: false 
#| warning: false  

# print for each group
df %>%     
  filter(TypeTest == "FirstTesting" & GroupNum == 2 & GroupType == "Hetero") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> first_name    
colnames(first_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")  

df %>%     
  filter(TypeTest == "SecondTesting" & GroupNum == 2 & GroupType == "Hetero") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> last_name
colnames(last_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")      

kable(first_name)   


```

*After training*:

```{r}
#| echo: false 
#| message: false 
#| warning: false

kable(last_name) 
```

**Group 3**:

*Before* training:

```{r}
#| echo: false 
#| message: false 
#| warning: false  

# print for each group
df %>%     
  filter(TypeTest == "FirstTesting" & GroupNum == 3 & GroupType == "Hetero") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> first_name    
colnames(first_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")  

df %>%     
  filter(TypeTest == "SecondTesting" & GroupNum == 3 & GroupType == "Hetero") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> last_name
colnames(last_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")      

kable(first_name)   


```

*After training*:

```{r}
#| echo: false 
#| message: false 
#| warning: false

kable(last_name) 
```

**Group 4**:

*Before* training:

```{r}
#| echo: false 
#| message: false 
#| warning: false  

# print for each group
df %>%     
  filter(TypeTest == "FirstTesting" & GroupNum == 4 & GroupType == "Hetero") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> first_name    
colnames(first_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")  

df %>%     
  filter(TypeTest == "SecondTesting" & GroupNum == 4 & GroupType == "Hetero") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> last_name
colnames(last_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")      

kable(first_name)   


```

*After training*:

```{r}
#| echo: false 
#| message: false 
#| warning: false

kable(last_name) 
```

**Group 5**:

*Before* training:

```{r}
#| echo: false 
#| message: false 
#| warning: false  

# print for each group
df %>%     
  filter(TypeTest == "FirstTesting" & GroupNum == 5 & GroupType == "Hetero") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> first_name    
colnames(first_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")  

df %>%     
  filter(TypeTest == "SecondTesting" & GroupNum == 5 & GroupType == "Hetero") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> last_name
colnames(last_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")      

kable(first_name)   


```

*After training*:

```{r}
#| echo: false 
#| message: false 
#| warning: false

kable(last_name) 
```

**Group 6**:

*Before* training:

```{r}
#| echo: false 
#| message: false 
#| warning: false  

# print for each group
df %>%     
  filter(TypeTest == "FirstTesting" & GroupNum == 6 & GroupType == "Hetero") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> first_name    
colnames(first_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")  

df %>%     
  filter(TypeTest == "SecondTesting" & GroupNum == 6 & GroupType == "Hetero") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> last_name
colnames(last_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")      

kable(first_name)   


```

*After training*:

```{r}
#| echo: false 
#| message: false 
#| warning: false

kable(last_name) 
```

**Group 7**:

*Before* training:

```{r}
#| echo: false 
#| message: false 
#| warning: false  

# print for each group
df %>%     
  filter(TypeTest == "FirstTesting" & GroupNum == 7 & GroupType == "Hetero") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> first_name    
colnames(first_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")  

df %>%     
  filter(TypeTest == "SecondTesting" & GroupNum == 7 & GroupType == "Hetero") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> last_name
colnames(last_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")      

kable(first_name)   


```

*After training*:

```{r}
#| echo: false 
#| message: false 
#| warning: false

kable(last_name) 
```

### Control groups

**Group 1**:

*Before* training:

```{r}
#| echo: false 
#| message: false 
#| warning: false  

# print for each group
df %>%     
  filter(TypeTest == "FirstTesting" & GroupNum == 1 & GroupType == "Control") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> first_name    
colnames(first_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")  

df %>%     
  filter(TypeTest == "SecondTesting" & GroupNum == 1 & GroupType == "Control") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> last_name
colnames(last_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")      

kable(first_name)   


```

*After training*:

```{r}
#| echo: false 
#| message: false 
#| warning: false

kable(last_name) 
```

**Group 2**:

*Before* training:

```{r}
#| echo: false 
#| message: false 
#| warning: false  

# print for each group
df %>%     
  filter(TypeTest == "FirstTesting" & GroupNum == 2 & GroupType == "Control") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> first_name    
colnames(first_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")  

df %>%     
  filter(TypeTest == "SecondTesting" & GroupNum == 2 & GroupType == "Control") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> last_name
colnames(last_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")      

kable(first_name)   


```

*After training*:

```{r}
#| echo: false 
#| message: false 
#| warning: false

kable(last_name) 
```

**Group 3**:

*Before* training:

```{r}
#| echo: false 
#| message: false 
#| warning: false  

# print for each group
df %>%     
  filter(TypeTest == "FirstTesting" & GroupNum == 3 & GroupType == "Control") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> first_name    
colnames(first_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")  

df %>%     
  filter(TypeTest == "SecondTesting" & GroupNum == 3 & GroupType == "Control") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> last_name
colnames(last_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")      

kable(first_name)   


```

*After training*:

```{r}
#| echo: false 
#| message: false 
#| warning: false

kable(last_name) 
```

**Group 4**:

*Before* training:

```{r}
#| echo: false 
#| message: false 
#| warning: false  

# print for each group
df %>%     
  filter(TypeTest == "FirstTesting" & GroupNum == 4 & GroupType == "Control") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> first_name    
colnames(first_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")  

df %>%     
  filter(TypeTest == "SecondTesting" & GroupNum == 4 & GroupType == "Control") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> last_name
colnames(last_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")      

kable(first_name)   


```

*After training*:

```{r}
#| echo: false 
#| message: false 
#| warning: false

kable(last_name) 
```

**Group 5**:

*Before* training:

```{r}
#| echo: false 
#| message: false 
#| warning: false  

# print for each group
df %>%     
  filter(TypeTest == "FirstTesting" & GroupNum == 5 & GroupType == "Control") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> first_name    
colnames(first_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")  

df %>%     
  filter(TypeTest == "SecondTesting" & GroupNum == 5 & GroupType == "Control") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> last_name
colnames(last_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")      

kable(first_name)   


```

*After training*:

```{r}
#| echo: false 
#| message: false 
#| warning: false

kable(last_name) 
```

**Group 6**:

*Before* training:

```{r}
#| echo: false 
#| message: false 
#| warning: false  

# print for each group
df %>%     
  filter(TypeTest == "FirstTesting" & GroupNum == 6 & GroupType == "Control") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> first_name    
colnames(first_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")  

df %>%     
  filter(TypeTest == "SecondTesting" & GroupNum == 6 & GroupType == "Control") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> last_name
colnames(last_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")      

kable(first_name)   


```

*After training*:

```{r}
#| echo: false 
#| message: false 
#| warning: false

kable(last_name) 
```

**Group 7**:

*Before* training:

```{r}
#| echo: false 
#| message: false 
#| warning: false  

# print for each group
df %>%     
  filter(TypeTest == "FirstTesting" & GroupNum == 7 & GroupType == "Control") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> first_name    
colnames(first_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")  

df %>%     
  filter(TypeTest == "SecondTesting" & GroupNum == 7 & GroupType == "Control") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> last_name
colnames(last_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")      

kable(first_name)   


```

*After training*:

```{r}
#| echo: false 
#| message: false 
#| warning: false

kable(last_name) 
```

# Results

## 0 - Understanding the results

### Accuracy Learning

Here, we examine how well the participants remembered the initial labels for the images, looking at the labels written by the participants during the *FirstTesting*.

Accuracy is **binary**: a value of 1 indicates correct recall by the participant, while a value of 0 signifies the presence of at least one error. However, we made an exception for the biased participant. In their case, their responses were considered "correct" if they substituted the biased letter they were unable to produce with another letter, or if they omitted it.

```{r }
#| echo: false
#| message: false
#| warning: false
#| fig-cap: "Learning accuracy per participant ID. Dots shape indicate the group number"
#| fig-alt: ""
#| fig-width: 8
#| fig-height: 5

# # summarize accuracy only first testing by PartID, GroupNum, and GroupType
# df_agg <- df %>%
#   filter(TypeTest == "FirstTesting" ) %>%
#   dplyr::group_by(Producer, GroupNum, GroupType) %>%
#   dplyr::summarize(mean_acc = mean(ACC)*100) %>% # to get a percentage
#   mutate(Producer = ifelse(as.character(Producer) == "1", "1 (biased)", as.character(Producer))) # for better visualisation
# 
# # plot obtained data
# ggplot(df_agg, aes(x=Producer, y=mean_acc, color=Producer, group=Producer, shape=GroupNum)) +
#   geom_boxplot(data=df_agg, aes(x=Producer, y=mean_acc, fill=Producer), alpha=0.2, width=0.2, color="grey") +
#   geom_jitter(size=3, width=0.1) +
#   ylim(0,100) +
#   labs(y="Accuracy (%)", x="Participant ID", color="Participant") +
#   scale_color_viridis_d() +
#   scale_fill_viridis_d() +
#   guides(color=FALSE, fill=FALSE) +
#   facet_grid(GroupType ~ .) 
  
```

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: yy
#| fig-cap: Same as above, except that here results are aggregated per participant."
#| fig-alt: ""
#| fig-width: 8
#| fig-height: 5
 
# df %>%
#   filter(TypeTest == "FirstTesting" ) %>%
#   dplyr::group_by(GroupNum, GroupType) %>%
#   dplyr::summarize(mean_acc = mean(ACC)*100) -> df_agg
# 
# ggplot(df_agg, aes(x=GroupType, y=mean_acc, color=GroupType, group=GroupType, shape=GroupNum)) +
#   geom_boxplot(data=df_agg, aes(x=GroupType, y=mean_acc, fill=GroupType), alpha=0.2, width=0.2, color="grey") +
#   geom_jitter(size=3, width=0.1) +
#   ylim(0,100) +
#   labs(y="Accuracy (%)", x="Group type") +
#   guides(color="none", fill="none") 
  
```

### Initial production similarity

Participants were presented with the following **initial labels** during the passive exposure phase: kesip, esip, nusa, nus, aike, puak, nekuki, and anap. Our analysis focuses on the differences between participants' first productions (during FirstTesting) and the initial labels. To do this, we computed the normalized Levenshtein distance between the initial labels and the initial productions.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-learning
#| fig-cap: "Learning success (accuracy on the left, initial production similarity on the right) per group type. Dots indicate each participant. The red dot shows the mean of the group, and red pointrange shows the standard error."
#| fig-width: 10
#| fig-height: 5

# compute learning accuracy
df_agg_acc <- df %>%
  filter(TypeTest == "FirstTesting" ) %>%
  dplyr::group_by(Producer, GroupNum, GroupType) %>%
  dplyr::summarize(mean_acc = mean(ACC)*100) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))


# compute distance to initial labels
# df_agg_dist <- df %>%
#   filter(TypeTest == "FirstTesting") %>%
#   mutate(Shape = as.character(Shape)) %>%
#   mutate(lev_dis = stringdist(Word, Shape, method = "lv")/max(str_count(Word), str_count(Shape)))  %>%
#   mutate(GroupType2 = ifelse(GroupType == "Control", "Control", ifelse(Producer == 1, "Hetero_biased", "Hetero_unbiased"))) %>%
#   dplyr::group_by(Producer, GroupNum, GroupType2) %>%
#   dplyr::summarize(mean_lev_dis = mean(lev_dis)) 
# df_agg_dist <- df %>%
#   filter(TypeTest == "FirstTesting") %>%
#   mutate(Shape = as.character(Shape)) %>%
#   mutate(GroupType2 = ifelse(GroupType == "Control", "Control", ifelse(Producer == 1, "Hetero_biased", "Hetero_unbiased"))) %>%
#   dplyr::group_by(Producer, GroupNum, GroupType2) %>%
#   dplyr::summarize(mean_lev_dis = mean(DistInitLabel)) 

df_agg_dist2 <- df %>%
  filter(TypeTest == "FirstTesting") %>%
  dplyr::group_by(Producer, GroupNum, GroupType) %>%
  dplyr::summarize(mean_lev_dis = mean(DistInitLabel2))  %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))


# plot accuracy learning
p1 <- ggplot(df_agg_acc, aes(x=GroupType, y=mean_acc)) +
  geom_violin(data=df_agg_acc, aes(x=GroupType, y=mean_acc, fill=GroupType), alpha=0.2, width=0.2, color="grey") +
  geom_jitter(size=2, width=0.1, alpha=0.4) +
  ylim(0,100) +
  labs(y="Accuracy learn (%)", x="Group type") +
  guides(color="none", fill="none") +
  stat_summary(fun.data=data_summary, color="red")  +
  scale_x_discrete(guide = guide_axis(n.dodge = 2)) 

# # plot distance to initial labels
# p2 <- ggplot(df_agg_dist, aes(x=GroupType2, y=mean_lev_dis)) +
#   geom_violin(data=df_agg_dist, aes(x=GroupType2, y=mean_lev_dis, fill=GroupType2), alpha=0.2, width=0.2, color="grey") +
#   geom_jitter(size=2, width=0.1, alpha=0.4) +
#   labs(y="Init produc sim", x="Group type") +
#   guides(color="none", fill="none") +
#   stat_summary(fun.data=data_summary, color="red") +
#   scale_x_discrete(guide = guide_axis(n.dodge = 2)) 

# plot distance to initial labels
p3 <- ggplot(df_agg_dist2, aes(x=GroupType, y=mean_lev_dis)) +
  geom_violin(data=df_agg_dist2, aes(x=GroupType, y=mean_lev_dis, fill=GroupType), alpha=0.2, width=0.2, color="grey") +
  geom_jitter(size=2, width=0.1, alpha=0.4) +
  labs(y="Init produc sim", x="Group type") +
  guides(color="none", fill="none") +
  stat_summary(fun.data=data_summary, color="red") +
  scale_x_discrete(guide = guide_axis(n.dodge = 2)) 

# arrange both plots in one
grid.arrange(p1,p3, ncol=2)

```

We check whether the difference of learning is statistically different. This is not an hypothesis, just a sanity check that our two group types are similar.

With **accuracy learning**:

```{r}
#| echo: false
#| message: false
#| warning: false

# linear mixed effect model with learning accuracy
model_acc <- lmer(mean_acc ~ GroupType + (1 | GroupID), data=df_agg_acc)
summary(model_acc)

```

With **initial production similarity**:

```{r}
#| echo: false
#| message: false
#| warning: false

# linear mixed effect model with distance to initial labels
model_dist <- lmer(mean_lev_dis ~ GroupType + (1 | GroupID), data=df_agg_dist2)
summary(model_dist)
```

-\> The learning difference between the two groups is not significant

Looking at each shape:

```{r }
#| echo: false
#| message: false
#| warning: false
#| label: fig-learning-shape
#| fig-cap: "Levenshtein distance between initial words and initial productions for each word. Blue dots show biased participants."
#| fig-width: 12
#| fig-height: 6

# compute accuracy learning for each shape
df_agg_acc <- df %>%
  filter(TypeTest == "FirstTesting" ) %>%
  dplyr::group_by(GroupType, Shape) %>%
  dplyr::summarize(mean_acc = mean(ACC)*100,
                   se_acc = se(ACC)*100)

# compute production similarity for each shape
df_agg_dist <- df %>%
  filter(TypeTest == "FirstTesting" ) %>%
  dplyr::group_by(GroupType, Shape) %>%
  dplyr::summarize(mean_lev_dis = mean(DistInitLabel2),
                   se_lev_dis = se(DistInitLabel2))


# plot accuracy learning for each shape
p1 <- ggplot(df_agg_acc, aes(x=Shape, y=mean_acc, color=GroupType)) +
  geom_pointrange(data=df_agg_acc, mapping=aes(x=Shape, y=mean_acc, color=GroupType, ymin=mean_acc-se_acc, ymax=mean_acc+se_acc), position=position_dodge(0.3)) + 
  labs(y="Accuracy learning (in %)", x="", color="") +
  theme(legend.position="bottom") +
  scale_x_discrete(guide = guide_axis(n.dodge = 2))

# plot distance initial label for each shape
p2 <- ggplot(df_agg_dist, aes(x=Shape, y=mean_lev_dis, color=GroupType)) +
  geom_pointrange(data=df_agg_dist, mapping=aes(x=Shape, y=mean_lev_dis, color=GroupType, ymin=mean_lev_dis-se_lev_dis, ymax=mean_lev_dis+se_lev_dis), position=position_dodge(0.3)) + 
  labs(y="Init produc similarity", x="", color="") +
  theme(legend.position="bottom") +
  scale_x_discrete(guide = guide_axis(n.dodge = 2))

# arrange both plots in one
ggarrange(p1, p2, ncol=2, labels="AUTO", common.legend = TRUE, legend="bottom", font.label = list(size = 16, color = "black"))
```

### Participants' characteristics

```{r}
#| echo: false 
#| message: false 
#| warning: false  
#| label: fig-part-charact
#| fig-cap: "Distribution of the scores. Red shows the results for the control group, blue shows the results for the heterogenous group."
#| fig-width: 10 
#| fig-height: 6  

# Learning accuracy
df_learn <- df %>%
  filter(TypeTest == "FirstTesting" ) %>%
  group_by(Producer, GroupNum, GroupType) %>%
  summarize(AccLearning = mean(ACC)) %>%
  dplyr::select(Producer, GroupNum, AccLearning, GroupType) %>%
  dplyr::rename(PartID = Producer)  

# Distance with initial word
df_dist <- df %>%
  filter(TypeTest == "FirstTesting") %>%
  mutate(Shape = as.character(Shape)) %>%
  dplyr::group_by(Producer, GroupNum, GroupType) %>%
  dplyr::summarize(DistInitWords = mean(DistInitLabel))  %>%
  dplyr::select(Producer, GroupNum, DistInitWords, GroupType) %>%
  dplyr::rename(PartID = Producer)  
  
## merge with previous data
df_other <- merge(df_other, df_learn, by=c("PartID", "GroupNum", "GroupType"))
df_other <- merge(df_other, df_dist, by=c("PartID", "GroupNum", "GroupType"))

p1 <- ggplot(df_other, aes(x=prosoc, fill=GroupType)) +   
  geom_density(alpha=0.5) +   
  guides(fill=FALSE) 

p2 <- ggplot(df_other, aes(x=WorkingMem, fill=GroupType)) +   
  geom_density(alpha=0.5) +   
  guides(fill=FALSE) 

p3 <- ggplot(df_other, aes(x=CogFlexibility, fill=GroupType)) +   
  geom_density(alpha=0.5) +   
  guides(fill=FALSE) 

p4 <- ggplot(df_other, aes(x=DictatorGame, fill=GroupType)) +   
  geom_histogram(stat="count", position = position_dodge()) +   
  guides(fill=FALSE) 

p5 <- ggplot(df_other, aes(x=Age, fill=GroupType)) +   
  geom_density(alpha=0.5) +   
  guides(fill=FALSE) 

p6 <- ggplot(df_other, aes(x=Gender, fill=GroupType)) +   
  geom_histogram(stat="count", position = position_dodge()) +   
  guides(fill=FALSE) 

p7 <- ggplot(df_other, aes(x=AccLearning, fill=GroupType)) +   
  geom_density(alpha=0.5) +   
  guides(fill=FALSE) 

p8 <- ggplot(df_other, aes(x=DistInitWords, fill=GroupType)) +   
  geom_density(alpha=0.5) 

ggarrange(p1, p2, p3, p4, p5, p6, p7, p8, ncol=4, nrow=2, labels="AUTO", common.legend = TRUE, legend="bottom", font.label = list(size = 16, color = "black"))

#grid.arrange(p1, p2, p3, p4, p5, p6, p7, p8, ncol=4, nrow=2)
```

```{r}

mod_prosoc <- t.test(df_other$prosoc[df_other$GroupType=="Hetero"], df_other$prosoc[df_other$GroupType=="Control"])
mod_wm <- t.test(df_other$WorkingMem[df_other$GroupType=="Hetero"], df_other$WorkingMem[df_other$GroupType=="Control"])
mod_cf <- t.test(df_other$CogFlexibility[df_other$GroupType=="Hetero"], df_other$CogFlexibility[df_other$GroupType=="Control"])
mod_dg <- t.test(df_other$DictatorGame[df_other$GroupType=="Hetero"], df_other$DictatorGame[df_other$GroupType=="Control"])

mod_age <- t.test(df_other$Age[df_other$GroupType=="Hetero"], df_other$Age[df_other$GroupType=="Control"])
mod_sex <- chisq.test(table(df_other$Gender, df_other$GroupType))
mod_acc <- t.test(df_other$AccLearning[df_other$GroupType=="Hetero"], df_other$AccLearning[df_other$GroupType=="Control"])
mod_dist <- t.test(df_other$DistInitWords[df_other$GroupType=="Hetero"], df_other$DistInitWords[df_other$GroupType=="Control"])
mod_dist2 <- t.test(df_other$DistInitWords[df_other$GroupType=="Hetero" & df_other$PartID!=1], df_other$DistInitWords[df_other$GroupType=="Control" & df_other$PartID!=1])

```

When building t-tests comparing each of these characteristics for the groups, we obtain the following p-values (please note that we used a chisq test for gender):

-   For prosociality: `r round(mod_prosoc$p.value,2)`
-   For working memory: `r round(mod_wm$p.value,2)`
-   For cognitive flexibility: `r round(mod_cf$p.value,2)`
-   For dictator game: `r round(mod_dg$p.value,2)`
-   For age: `r round(mod_age$p.value,2)`
-   For gender: `r round(mod_sex$p.value,2)`
-   For accuracy learning: `r round(mod_acc$p.value,2)`
-   For distance to initial words: `r round(mod_dist$p.value,2)`

None of these values are significant, except for the distance to initial words. This can be easily explained given that the method we used to measure the initial production similarities is different for biased and unbiased participants. Thus, if we remove the biased participants, this p-value is not-significant anymore: `r round(mod_dist2$p.value,2)`.

### Strategy

In this part, we only at the patterns observed in the **heterogenous groups**.

What are the strategies used by the biased participant to produce the initial labels before communicating? In this table, we count the number of time each biased participant has performed:

-   *removal* means that the biased participant remembered the label, and decided to remove the biased letter

-   *switch* means that the biased participant remembered the label, and decided to switch the biased letter with another unbiased letter

-   *forgot* means that the biased participant has forgot the initial label

```{r}
strat_init_biased = data.frame(removal=c(0,0,4,5,5,0,0), 
                               forgot=c(1,0,2,1,1,4,6), 
                               switch=c(5,6,0,0,0,2,0)) 

rownames(strat_init_biased) = c("Group1", "Group2", "Group3", "Group4", "Group5", "Group6","Group7") 

kable(strat_init_biased)
```

Please note that these tables were filled manually.

Then, we also look at the pattern presented by the biased participant after communicating. How did this biased participant produce the label? Did this participant:

-   *removal*: used the initial label, but removed the biased letter

-   *switch*: used the initial label, but switched the biased letter with another unbiased letter (please note that in the case of "nekuki" label, we consider as "switch" things like "nepupi" or "nepipi"; it is not exactly the same word so it should be considered in the "new" column, but we think that the strategy is actually a switch (+ a weak forgot))

-   *new*: adopted a new label

-   *special*: here to condition where the participant has removed the biased letter, but has also added a letter at the end of the word. Then, the word was identifiable by the other members of the groups by the addition of this final letter (for example, esipp, and other participants produced esippp, sesss, sessss).

```{r}

strat_end_biased = data.frame(removal=c(0,0,5,0,3,1,0), 
                              new=c(1,6,0,2,1,3,4), 
                              switch=c(5,0,1,4,1,2,2), 
                              special=c(0,0,0,0,1,0,0)) 

rownames(strat_end_biased) = c("Group1", "Group2", "Group3", "Group4", "Group5", "Group6", "Group7") 

kable(strat_end_biased)
```

These tables concerned only the biased participant. Then, we can also look at the productions of the unbiased participants after they communicated (during the final testing) to look at their adaptative strategy. Please note that we do not look here at the labels that does not feature biased letters (nus and esip), only the 6 other that feature at least one biased letter. Here are the following possible options:

-   *SameBiased_Removed*: used the same label as the biased participant, in the case where the biased participant has removed a biased letter

-   *SameBiased_Removed*: used the same label as the biased participant, in the case where the biased participant has switched a biased letter with another unbiased letter

-   *SameBiased_New*: used the same label as the biased participant, in the case where the biased participant has created a new label

-   *InitialLabel*: used the initial label, even if the biased participant cannot use it the same way

-   *DiffBiased_Adapt*: use a different label as the biased participant, however this new label does not feature biased letter

-   *DiffBiased_ABitAdapt*: use a different label as the biased participant, this new label features slightly less biased letters than the original label (namely, instead of 2 biased letters, there is only one biased letter)

-   *DiffBiased_NonAdapt*: use a different label as the biased participant (which is also not the initial label), and that feature biased letters

```{r}
strat_adapt = data.frame(SameBiased_Removed=c(0,0,0,0,3,0,0), 
                         SameBiased_Switch=c(0,0,0,1,0,0,0), 
                         SameBiased_New=c(0,0,0,0,0,0,0), 
                         InitialLabel=c(2,14,10,7,3,11,6), 
                         DiffBiased_Adapt=c(2,0,2,4,7,0,6), 
                         DiffBiased_ABitAdapt=c(5,3,3,2,2,2,2), 
                         DiffBiased_NonAdapt = c(9,2,3,4,3,5,4)) 

rownames(strat_adapt) = c("Group1", "Group2", "Group3", "Group4", "Group5", "Group6","Group7") 
kable(strat_adapt) 
```

When adapating, there are three main types of strategy used by the unbiased participants to adapt to the biased participants:

-   either they use the same word as the biased participant (it has happened `r sum(strat_adapt$SameBiased_Removed) + sum(strat_adapt$SameBiased_Switch) +sum(strat_adapt$SameBiased_New)` times out of the 6 words containing a biased letter and the `r 3*nrow(strat_adapt)` unbiased participants -\> total of `r 6*(3*nrow(strat_adapt))` occurences).

-   either they use a new label, not used by the biased participants, but that does not feature any biased letters: `r sum(strat_adapt$DiffBiased_Adapt)` or that does feature less biased letters than the original label: `r sum(strat_adapt$DiffBiased_ABitAdapt)`

If they do not adapt, either by using the initial label that contains as many biased letters as the original label (or more): `r sum(strat_adapt$DiffBiased_NonAdapt) + sum(strat_adapt$InitialLabel)`

### Summary results

-   performance of learning (both using accuracy index and distance to initial learning) are similar between control and heterogenous groups

-   some words are easier to remember compared to other (such as *aike* or *nus*)

-   the participants characteristics are similar between control and heterogenous groups (in average, they have approximately the same age, but also personal characteristics such as working memory, cognitive flexibility...)

-   in order to compensate with their difference, biased participants either labels either switch the biased letter with another letter. After communicating, they also come up with new words

-   unbiased participants adapt mostly by using another label which does not feature any biased letter (or less), and sometimes they adapt by copying the label used by the biased participant

## 1 - How heterogeneity may affect language evolution

### Communicative success

Here, we examine the level of communicative success in interactions, specifically distinguishing between successful (success=1) and unsuccessful (success= 0) interaction in pairs. Please note that the variables Round2 here is the reverse order of Round (so that Round 9 becomes Round 0).

We look at the evolution of communicative success for each group:

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-comsucess-time-groups
#| fig-cap: "Evolution of communicative success for each group."
#| fig-width: 9
#| fig-height: 7

# aggregagte accuracy by group number and group type, and Round
df %>%
  filter(TypeTest == "ComGame") %>%
  group_by(Round, GroupNum, GroupType) %>%
  summarize(mean_acc = mean(ACC, na.rm=TRUE)*100) -> df_agg

# Plot       
p <- ggplot(df_agg, aes(x=Round, y=mean_acc, color=GroupNum, group=GroupNum))+ geom_point() 
p <- add_grey_rect_1_9(p)
p <- p + geom_hline(yintercept = 50, linetype="dashed") +
  geom_point(size=5, position=position_dodge(width=0.5)) +
  geom_line(size=1, position=position_dodge(width=0.5)) +
  facet_grid(GroupType ~ .) +
  ylim(0,105) +
  labs(y="Mean com success (%)", fill="Group") +
  scale_x_continuous(breaks = c(0:10)) +
  scale_color_viridis_d()
p
```

We can see that the communicative success of group 2 in the heterogeneous group is particularly high.

Let's look at the aggregated performance for each group type:

```{r }
#| echo: false  
#| message: false  
#| warning: false 
#| label: fig-comsucess-time-agg 
#| fig-cap: "Evolution of communicative success aggregated by group type: control or heterogenous." 
#| fig-width: 8 
#| fig-height: 5   

df %>%      
  filter(TypeTest == "ComGame") %>%      
  group_by(Round, GroupType) %>%      
  summarize(mean_acc = mean(ACC, na.rm=TRUE)*100,
            se_acc = se(ACC)*100) -> df_agg    

# Plot         
p <- ggplot(df_agg, aes(x=Round, y=mean_acc, color=GroupType, group=GroupType))+   geom_point()   
p <- add_grey_rect_1_9(p)  
p <- p + geom_hline(yintercept = 50, linetype="dashed") +      
  geom_point(size=5) +     
  geom_line(size=1) +      
  ylim(0,105) +      
  labs(y="Mean com success (%)", fill="Group") +       
  scale_x_continuous(breaks = c(0:10))  +
  geom_pointrange(aes(ymin=mean_acc-se_acc, ymax=mean_acc+se_acc), lwd=1, size=0.5, alpha=0.8) 

p
```

These plots raise two questions:

-   Is there a significant **improvement** of communicative success with time?

-   Is there a significant **difference** of communicative success between heterogeneous and control groups?

To investigate these questions, we build a *linear mixed-effect models* using the group type (hetero versus control) and the round as fixed effect. We use the aggregated data by pair, and we control for the random effect of Group Number.

```{r}
#| echo: false
#| message: false
#| warning: false

df_agg <- df %>%
  filter(TypeTest == "ComGame") %>%
  group_by(Round, GroupNum, GroupType, pair) %>%
  summarize(mean_acc = mean(ACC, na.rm=TRUE)*100) %>%
  mutate(Round2 = ifelse(Round == 9, 0, ifelse(Round==8, 1, ifelse(Round==7, 2, ifelse(Round==6, 3, ifelse(Round==5, 4, ifelse(Round==4, 5, ifelse(Round==3, 6, ifelse(Round==2, 7, ifelse(Round==1, 8)))))))))) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))

model <- lmer(mean_acc ~ GroupType * Round2 + (1  | GroupID), data = df_agg)
summary(model)
```

There is a significant variation in performance within each condition (control and heterogenous), with **lower performance observed in the heterogenous groups**. Notably, one group (group 2) had a very high performance. Furthermore, communicative success is significantly improving with time for both groups, but no interaction effect between group type and time is present.

From this plot, it is evident that the average communicative success is lower in heterogeneous groups compared to control groups. However, it could be due to the fact that heterogeneous groups include interactions with a biased participants. Thus, it is interesting to split the heterogeneous groups into two categories:

-   **Hetero_biased** (pairs in the heterogeneous groups that contain the biased participants: 1-2, 1-3, 1-4)

-   **Hetero_nonbiased** (pairs in the heterogeneous groups that does ***not*** contain the biased participant: 2-3, 2-4, 3-4).

This could lead to two different scenarios:

1.  Hetero_nonbiased has high communicative success similarly to control groups, because these pairs do not include the biased participants ;

2.  The confusion introduced by the biased participant spread to all participants, and the performance of hetero_unbiased is still lower than for control groups.

```{r }
#| echo: false 
#| message: false 
#| warning: false 
#| label: fig-comsucess-split-hetero
#| fig-cap: "Same as above, except that here we split heterogenous groups in 2: pairs including the biased participant and pairs without the biased participant."
#| fig-width: 6
#| fig-height: 6 

df_agg <- df %>%   
  filter(TypeTest == "ComGame") %>%   
  mutate(type = ifelse( GroupType == "Control", "Control", ifelse(Producer == 1 | Guesser == 1, "Hetero With Biased", "Hetero Without Biased"))) %>%   
  group_by(Round, GroupType, type) %>%   
  summarize(mean_acc = mean(ACC, na.rm=TRUE)*100,
            se_acc = se(ACC)*100) %>%   
  mutate(Round = as.factor(Round),          
         type = as.factor(type))    



# Plot        
p_comsuccess <- ggplot(df_agg, aes(x=Round, y=mean_acc, color=type, group=type))+ 
  geom_point() 
p_comsuccess <- add_grey_rect_1_9(p_comsuccess) 
p_comsuccess <- p_comsuccess + 
  #geom_hline(yintercept = 50, linetype="dashed") +   
  #geom_point(size=5, position=position_dodge(width=0.5)) +   
  geom_line(size=1) +   
  geom_pointrange(aes(ymin=mean_acc-se_acc, ymax=mean_acc+se_acc), lwd=1.2, size=1.1) +
  scale_color_viridis_d(end=0.8) +
  ylim(0,105) +   
  labs(y="Communicative success", fill="", color="")   +
  theme(legend.position="bottom") 
p_comsuccess 
```

The plot suggests that **hypothesis 2 is supported**: the presence of the biased participant has introduced confusion within the heterogeneous group, leading to a decrease in the communicative success in all types of pairs. However, in general, the pair with the biased individual achieves a lower accuracy score (in the heterogenous group). We used a mixed-effect model to see if this is statistically significant:

```{r}
#| echo: false
#| message: false
#| warning: false

df_agg <- df %>%   
  filter(TypeTest == "ComGame") %>%   
  mutate(type = ifelse( GroupType == "Control", "Control", ifelse(Producer == 1 | Guesser == 1, "Hetero With Biased", "Hetero Without Biased"))) %>%   
  group_by(Round, GroupType, type, GroupNum, pair) %>%   
  summarize(mean_acc = mean(ACC, na.rm=TRUE)*100) %>%
  mutate(Round2 = ifelse(Round == 9, 0, ifelse(Round==8, 1, ifelse(Round==7, 2, ifelse(Round==6, 3, ifelse(Round==5, 4, ifelse(Round==4, 5, ifelse(Round==3, 6, ifelse(Round==2, 7, ifelse(Round==1, 8))))))))))   %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))

model <- lmer(mean_acc ~ type*Round2 + (1 | GroupID), data=df_agg)
summary(model)

```

```{r}
#| echo: false
#| message: false
#| warning: false
# 
# df_agg <- df %>%   
#   filter(TypeTest == "ComGame",
#          GroupType == "Hetero") %>%   
#   mutate(type = ifelse(Producer == 1 | Guesser == 1, "Hetero_biased", "Hetero_nonbiased")) %>%   
#   group_by(Round, GroupNum, GroupType, type) %>%   
#   summarize(mean_acc = mean(ACC, na.rm=TRUE)*100) %>%   
#   filter(Round == 1) 
# 
# t.test(df_agg$mean_acc[df_agg$type == "Hetero_biased"], df_agg$mean_acc[df_agg$type == "Hetero_nonbiased"])
```

```{r }
#| echo: false
#| message: false
#| warning: false
#| label: fig-comsucess-other-plot
#| fig-cap: "Evolution of communicative success with Round and per pair. Dots color indicate which participant is in which pair. It is important to note that we excluded group number 1 from the heterogenous group from this plot (Please refer to the method section for further details.)"
#| fig-width: 10
#| fig-height: 7

# # Aggregate by Round, pair, and GroupType
# # Then perform some operations for better plotting
# df %>%
#   filter(TypeTest == "ComGame") %>%
#   dplyr::group_by(Round, pair, GroupType) %>%
#   dplyr::summarize(mean_acc = mean(ACC, na.rm=TRUE)*100) %>%
#   mutate(pair = as.factor(pair)) %>%
#   mutate(pair2 = pair) %>%
#   separate(pair2, c("parta", "partb"), "_") %>%
#   gather(condition, Participant, parta, partb) %>%
#   dplyr::select(-condition) %>%
#   mutate(Participant = as.character(Participant),
#            Round = as.factor(Round))  %>%
#   mutate(Participant = ifelse(Participant == "1", "1 (biased)",Participant)) -> df_agg
# 
# # create plot
# p <- ggplot(df_agg, aes(x=Round, y=mean_acc, fill=Participant)) + geom_point()  
# p <- add_grey_rect_1_9(p) # add grey background rectangles
# p <- p + geom_hline(yintercept = 50, linetype="dashed") + # add dashed line
#   geom_dotplot(binaxis = "y", stackdir = "centerwhole", stackgroups = TRUE, binpositions = "all", binwidth = 5) + # add dots
#   facet_grid(GroupType ~ .) + # add GroupType condition
#   labs(y="Mean com success (%)") + # rename labs
#   ylim(-5,105)  # change y limits
# 
# # print plot
# p


```

Let's just compare the pair with the biased participant and the pairs without (please note that pairs with the biased participants are considered to be the pairs with participant 1: so in the control groups, these pairs do not really include a biased participant, it is just in order to have an easy nice way of plotting):

```{r )}
#| echo: false
#| message: false
#| warning: false
#| label: fig-nn
#| fig-cap: "Communicate, comparing pairs with biased participants (1-3, 1-2, 1-4) and pairs without biased participants (2-3, 2-4, 3-4)."
#| fig-width: 10
#| fig-height: 7
#| 
# df %>%
#   filter(TypeTest == "ComGame") %>%
#   mutate(have_biased = ifelse(grepl( "1", pair, fixed = TRUE), "yes", "no")) %>%
#   group_by(have_biased, GroupNum, GroupType) %>%
#   summarize(mean_acc = mean(ACC, na.rm=TRUE)*100) -> df_agg
# 
#         
# ggplot(df_agg, aes(x=have_biased, y=mean_acc, fill=have_biased))+
#   geom_violin(alpha=0.3, width=0.3) +
#   geom_boxplot(width=0.05, alpha=0.8, fill="white") +
#   geom_jitter(width=0.1, size=2)+
#   labs(y="Mean accuracy (%)", x="Pair with biased participant?") +
#   guides(fill=FALSE) +
#   facet_grid(GroupType ~ .) +
#   ylim(0,100)
#   

```

```{r }
#| echo: false
#| message: false
#| warning: false
#| label: fig-comsuccess-pointrange
#| fig-cap: "Mean communicative success for each group, whether unbiased communicate with biased participant (part 1) or unbiased participant (part 2, 3, 4) Bars show standard error."
#| fig-width: 8
#| fig-height: 5

df_agg <- df %>%
  mutate(ACC=ACC*100) %>%
  filter(TypeTest == "ComGame" ) %>%
  mutate(have_biased = ifelse(grepl( "1", pair, fixed = TRUE), "yes", "no"))  %>%
  dplyr::group_by(pair, GroupType, GroupNum, have_biased, Round) %>%
  dplyr::summarize(mean_acc = mean(ACC, na.rm=TRUE))  %>%
  dplyr::group_by(have_biased, GroupType) %>%
  dplyr::summarize(mean_acc2 = mean(mean_acc, na.rm=TRUE), 
            se_acc = se(mean_acc)) 

ggplot(df_agg, aes(x=have_biased, y=mean_acc2, group=GroupType, color=GroupType)) +
  geom_line()+
  geom_pointrange(aes(ymin=mean_acc2-se_acc, ymax=mean_acc2+se_acc)) +
  labs(y="Mean com success (%)", x="Pair with biased participant?") 

```

```{r}
#| echo: false
#| message: false
#| warning: false

df_agg <- df %>%
  mutate(ACC=ACC*100) %>%
  filter(TypeTest == "ComGame" ) %>%
  mutate(have_biased = ifelse(grepl( "1", pair, fixed = TRUE), "yes", "no"))  %>%
  dplyr::group_by(pair, GroupType, GroupNum, have_biased, Round) %>%
  dplyr::summarize(mean_acc = mean(ACC, na.rm=TRUE)) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))

model <- lmer(mean_acc ~ GroupType * have_biased  + (1 | GroupID), data=df_agg)
summary(model)


```

**Summary results:**

-   Communicative success improves with time (for both groups)

-   Communicative success is higher in control groups

-   In heterogeneous groups, communicative success is higher in pairs that do not contain the unbiased individuals. However, the communicative of this type of pairs is still lower than the one in control groups, which suggest that introducing a biased participant has spread some confusion in the whole group.

### Evolution of production similarity

This analysis helps us gain insight into our data. We want to know if participants eventually adopt the initial labels, even if they initially didn't remember them. To find out, we calculate the average Levenshtein distance between participants' productions and the initial labels at each round.

There is subtleties: in biased agents, we **manually** computed the initial distance to the initial words. We applied the following algorithm:

-   if the shape is "esip" or "nus": compute the normalized levenshtein distance

-   for the other shapes:

    -   if the participant seems to have completely forgotten the word, or used a label for another image, we remove the biased letters from the shape and compute the normalized levenshtein distance. For example, if the shape is "puak" and the participants produced "esip", we compute the normalized levenshtein distance between "puak" and "esip"

    -   if the participants seems to have remember the word (it does not have to be the exact same word, but something similar), we replace or omitted the biased letters using the same strategy as the participant, and compute the normalized levenshtein distance between the two words. For example: if the shape is "nusa" and the participant produced "nusi", we compute the normalized levenshtein distance between "nusi" and "nusi". If the participants produced "nasi", we computed the normalized levenshtein distance between "nasi" and "nusi".

Why did we do this manually? When applying an automatic algorithm (that replace the word produced by the biased participants by a similar version of replacement or letter switch) For the unbiased participants, we just compute the normalized levenshtein distance between their production and the image name.

We look at the evolution of production similarity for each shape:

```{r }
#| echo: false
#| message: false
#| warning: false
#| label: fig-evolution-distinitwords
#| fig-cap: "Evolution of the production similarity at each round, for each shape. Please note that this plot does not include the productions of the biased participant."
#| fig-width: 10
#| fig-height: 8

# Compute
df_agg <- df %>%
  filter(TypeTest != "PassiveExposure") %>%
  mutate(Shape = as.character(Shape)) %>%
  dplyr::group_by(GroupType, Round, Shape) %>%
  dplyr::summarize(mean_lev_dis = mean(DistInitLabel2))

# Plot
p <- ggplot(df_agg, aes(x=Round, y=mean_lev_dis, color=Shape, group=Shape)) + geom_point()
p <- add_grey_rect_0_10(p) 
p <- p + geom_point(size=5) +
  geom_line(size=1) +
  facet_grid(GroupType ~ .) +
  labs(y="Production similarity", fill="Shape") +
  scale_x_continuous(breaks = c(0:10)) +
  scale_color_viridis_d()
p
```

We observe that **certain shapes are more effectively remembered than others**. For instance, "aike" and "nus" are often well-remembered, while "puak" tends to be frequently forgotten.

This plot also reveals that individuals in the control group eventually converge on the initial labels, even if they initially forget it. However, in the heterogenous group, this convergence does not occur. Participants' productions tend to become slightly closer to the initial labels, but at the end, the words still remain quite different, **even for words that did not contain a biased letter**!

We look at the same plot aggregated by group type:

```{r }
#| echo: false
#| message: false
#| warning: false
#| label: fig-evolution-distinitwords-agg
#| fig-cap: "Same plot as above, but aggregated by shape. Please note that this plot does not nclude the productions of the biased participant"
#| fig-width: 9
#| fig-height: 6

# Compute
df_agg <- df %>%
  filter(TypeTest != "PassiveExposure") %>%
  dplyr::group_by(GroupType, Round) %>%
  dplyr::summarize(mean_lev_dis = mean(DistInitLabel2),
                   se_lev_dis = se(DistInitLabel2))

# Plot
p <- ggplot(df_agg, aes(x=Round, y=mean_lev_dis, color=GroupType, group=GroupType)) + geom_point()
p <- add_grey_rect_0_10(p) 
p <- p + geom_point(size=5) +
  geom_line(size=1) +
  labs(y="Production similarity", fill="Shape") +
  scale_x_continuous(breaks = c(0:10)) +
  ylim(0.5, 1) +
  geom_pointrange(aes(ymin=mean_lev_dis-se_lev_dis, ymax=mean_lev_dis+se_lev_dis), lwd=1, size=0.5, alpha=0.8) 

  
p
```

```{r}
# Compute
df_agg <- df %>%
  filter(TypeTest != "PassiveExposure") %>%
  dplyr::group_by(GroupType, Round, GroupNum, Producer) %>%
  dplyr::summarize(mean_lev_dis = mean(DistInitLabel2)) %>%
  mutate(Round2 = ifelse(Round == 10, 0, ifelse(Round == 9, 1, ifelse(Round==8, 2, ifelse(Round==7, 3, ifelse(Round==6, 4, ifelse(Round==5, 5, ifelse(Round==4, 6, ifelse(Round==3, 7, ifelse(Round==2, 8, ifelse(Round==1, 9, ifelse(Round==0, 10)))))))))))) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))

summary(lmer(mean_lev_dis ~ GroupType*Round2 + (1 | GroupID), data=df_agg))
```

Now, we split heterogenous condition in two: participants in heterogenous groups in pairs with (*hetero_biased*) and without (*hetero_unbiased*) the biased participant, similarly with previous plots.

```{r }
#| echo: false
#| message: false
#| warning: false
#| label: fig-evolution-distinitwords-distinct
#| fig-cap: "Same plot as above, except that here, we differentiate between pairs interacting with the biased individuals, and pairs interacting without the biased individual."
#| fig-width: 6
#| fig-height: 6

# Compute
df_agg <- df %>%
  filter(TypeTest == "ComGame") %>%
  mutate(Condition = ifelse(GroupType == "Control", "Control", ifelse(Producer=="1", "Hetero With Biased", "Hetero Without Biased")),
         Shape = as.character(Shape)) %>%
  dplyr::group_by(GroupType, Round, Condition) %>%
  dplyr::summarize(mean_lev_dis = mean(DistInitLabel2),
                   se_lev_dis = se(DistInitLabel2))


# Plot
p_distlabel <- ggplot(df_agg, aes(x=Round, y=mean_lev_dis, color=Condition, group=Condition)) + geom_point()
p_distlabel <- add_grey_rect_1_9(p_distlabel) 
p_distlabel <- p_distlabel + geom_point(size=5) +
  geom_line(size=1) +
  labs(y="Production similarity", fill="", color="") +
  scale_x_continuous(breaks = c(1:9)) +
  theme(legend.position="bottom") +
  ylim(0.4,1) +
  geom_pointrange(aes(ymin=mean_lev_dis-se_lev_dis, ymax=mean_lev_dis+se_lev_dis), lwd=1, size=0.5) +
  scale_color_viridis_d(end=0.8) 

p_distlabel
```

```{r}
# Compute
df_agg <- df %>%
  filter(TypeTest == "ComGame") %>%
  mutate(Condition = ifelse(GroupType == "Control", "Control", ifelse(Producer=="1", "Hetero With Biased", "Hetero Without Biased")), Shape = as.character(Shape)) %>%
  dplyr::group_by(GroupType, Round, Condition, GroupNum) %>%
  dplyr::summarize(mean_lev_dis = mean(DistInitLabel2))  %>%
  mutate(Round2 = ifelse(Round == 10, 0, ifelse(Round == 9, 1, ifelse(Round==8, 2, ifelse(Round==7, 3, ifelse(Round==6, 4, ifelse(Round==5, 5, ifelse(Round==4, 6, ifelse(Round==3, 7, ifelse(Round==2, 8, ifelse(Round==1, 9, ifelse(Round==0, 10)))))))))))) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))

summary(lmer(mean_lev_dis ~ Condition*Round2 + (1 | GroupID), data=df_agg))
```

The observable difference between the biased and unbiased participants in the heterogeneous groups could be attributed to two factors. First, there might genuinely be a difference, and by chance, biased participants may have remembered the initial labels better than unbiased participants. Alternatively, it is possible that the method we used to measure production similarity in biased participants has inherent flaws, and the algorithm may be, in a sense, more favorable to biased participants.

### Convergence

In this part, we look at the convergence between all words produced in a round. As a reminder, each round, each participant produce one word for each label. So each round, there are 4 word productions for each labels : convergence will be high if these words are similar (such as *kesip*, *kesup*, *kesip* and *kesip*) but convergence will be low if these words are very different from each other (for example, *kesip*, *onup*, *asip* and *keku*).

Convergence is computed the following way:

1.  Calculate the normalized Levenshtein distance between all pairs of words within the set of four words.

2.  Find the average of these distances to obtain a single numerical value for each Round, each Shape, and each Group.

3.  Take the complement of this value, so that the measure of convergence increases when the words are more similar, rather than the opposite.

In other words, $convergence = 1 - (mean(dis(SetWords)))$ where dis(SetWords) is the pairwaise normalized Levenhstein distance between all words in SetWords.

The plot below includes the production of all participants, including the biased one:

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-evolution-convergence
#| fig-cap: "Evolution of convergence with time for each group."
#| fig-width: 10
#| fig-height: 8

df_agg <- df %>%
  filter(TypeTest != "PassiveExposure")   %>%
  dplyr::group_by(GroupType, GroupNum, Shape, Round) %>%
  dplyr::summarise(lev_dist_list = 1 - mean(allpairslev(Word))) %>%
  dplyr::group_by(GroupType, GroupNum, Round) %>%
  dplyr::summarise(mean_lev_dist = mean(lev_dist_list))


p <- ggplot(df_agg, aes(x=Round, y=mean_lev_dist, color=GroupNum, group=GroupNum)) +
  geom_point()
p <- add_grey_rect_0_10(p)
p <- p + geom_point(size=5) +
  geom_line(size=1) +
  labs(y="Mean convergence per group", fill="Shape") +
  scale_x_continuous(breaks = c(0:10)) +
  facet_grid(GroupType ~ .) +
  scale_color_viridis_d()
p

```

```{r }
#| echo: false
#| message: false
#| warning: false
#| label: fig-evolution-convergence2
#| fig-cap: "Evolution of convergence with time for each group."
#| fig-width: 12
#| fig-height: 9

# df_agg_with <- df %>%
#   filter(TypeTest != "PassiveExposure")   %>%
#   dplyr::group_by(GroupType, GroupNum, Shape, Round) %>%
#   dplyr::summarise(lev_dist_list = 1 - mean(allpairslev(Word))) %>%
#   dplyr::group_by(GroupType, GroupNum, Round) %>%
#   dplyr::summarise(All = mean(lev_dist_list))
# 
# df_agg_without <- df %>%
#   filter(TypeTest != "PassiveExposure",
#          Producer != "1")   %>%
#   dplyr::group_by(GroupType, GroupNum, Shape, Round) %>%
#   dplyr::summarise(lev_dist_list = 1 - mean(allpairslev(Word))) %>%
#   dplyr::group_by(GroupType, GroupNum, Round) %>%
#   dplyr::summarise(WithoutBiased = mean(lev_dist_list))
# 
# df_agg <- merge(df_agg_with, df_agg_without, by=c("GroupType", "GroupNum", "Round"))
# df_agg <- gather(df_agg, condition, mean_lev_dist, All:WithoutBiased)
# 
# p <- ggplot(df_agg, aes(x=Round, y=mean_lev_dist, color=GroupNum, group=GroupNum)) +
#   geom_point()
# p <- add_grey_rect_0_10(p)
# p <- p + geom_point(size=5) +
#   geom_line(size=1) +
#   labs(y="Mean convergence per group", fill="Shape") +
#   scale_x_continuous(breaks = c(0:10)) +
#   facet_grid(GroupType ~ condition) +
#   scale_color_viridis_d()
# p


```

We look at the same plot aggregated by group type:

First, we look at the convergence with all participants:

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-evolution-convergence33
#| fig-cap: "Same, but aggregated by group."
#| fig-width: 6
#| fig-height: 6
df_agg <- df %>%
  filter(TypeTest != "PassiveExposure")   %>%
  dplyr::group_by(GroupType, GroupNum, Shape, Round) %>%
  dplyr::summarise(lev_dist_list = 1 - mean(allpairslev(Word))) %>%
  dplyr::group_by(GroupType, Round) %>%
  dplyr::summarise(All = mean(lev_dist_list),
                   se_lev = se(lev_dist_list))

p <- ggplot(df_agg, aes(x=Round, y=All, color=GroupType, fill=GroupType)) + geom_point()
p <- add_grey_rect_0_10(p)
p <- p + geom_point(size=5) +
  geom_line(size=1) +
  #geom_smooth() +
  labs(y="Convergence", fill="", color="") +
  scale_x_continuous(breaks = c(0:10)) +
  theme(legend.position="bottom")  +
  ylim(0.3,1) +
  geom_pointrange(aes(ymin=All-se_lev, ymax=All+se_lev), lwd=1, size=0.5, alpha=0.8) 

p

```

```{r}

df_agg <- df %>%
  filter(TypeTest != "PassiveExposure")   %>%
  dplyr::group_by(GroupType, GroupNum, Shape, Round) %>%
  dplyr::summarise(lev_dist_list = 1 - mean(allpairslev(Word))) %>%
  dplyr::group_by(GroupType, GroupNum, Round) %>%
  dplyr::summarise(All = mean(lev_dist_list)) %>%
  mutate(Round2 = ifelse(Round == 10, 0, ifelse(Round == 9, 1, ifelse(Round==8, 2, ifelse(Round==7, 3, ifelse(Round==6, 4, ifelse(Round==5, 5, ifelse(Round==4, 6, ifelse(Round==3, 7, ifelse(Round==2, 8, ifelse(Round==1, 9, ifelse(Round==0, 10, "NA")))))))))))) %>%
  mutate(Round2 = as.numeric(Round2)) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))


model <- lm(All ~ GroupType * Round2, data = df_agg)
summary(model)

```

Then, we look at:

-   "Hetero With Biased": convergence in groups that include the biased participant (what was computed before; 4 data)
-   "Hetero Without Biased": convergence in groups that does not inlude the biased participant (3 data)

```{r }
#| echo: false
#| message: false
#| warning: false
#| label: fig-evolution-convergence-agg
#| fig-cap: "Same as above, aggregated by group."
#| fig-width: 6
#| fig-height: 6

df_agg_with <- df %>%
  filter(TypeTest != "PassiveExposure")   %>%
  dplyr::group_by(GroupType, GroupNum, Shape, Round) %>%
  dplyr::summarise(lev_dist_list = 1 - mean(allpairslev(Word))) %>%
  dplyr::group_by(GroupType, Round) %>%
  dplyr::summarise(All = mean(lev_dist_list),
                   SE_all = se(lev_dist_list))

df_agg_without <- df %>%
  filter(TypeTest != "PassiveExposure",
         Producer != "1")   %>%
  dplyr::group_by(GroupType, GroupNum, Shape, Round) %>%
  dplyr::summarise(lev_dist_list = 1 - mean(allpairslev(Word))) %>%
  dplyr::group_by(GroupType, Round) %>%
  dplyr::summarise(WithoutBiased = mean(lev_dist_list),
                   SE_withoutBiased = se(lev_dist_list))

df_agg <- merge(df_agg_with, df_agg_without, by=c("GroupType", "Round"))
df_agg_mean <- df_agg %>% dplyr::select(-c(SE_all,SE_withoutBiased))
df_agg_mean <- gather(df_agg_mean, condition, mean_lev_dist, All:WithoutBiased)
df_agg_se <- df_agg %>% 
  dplyr::select(-c(All,WithoutBiased)) %>%
  dplyr::rename(All = SE_all,
         WithoutBiased = SE_withoutBiased)
df_agg_se <- gather(df_agg_se, condition, se_lev_dist, All:WithoutBiased)
df_agg <- merge(df_agg_mean, df_agg_se, by=c("GroupType", "Round", "condition"))

df_agg <- df_agg %>%
  filter(!(GroupType == "Control" & condition == "WithoutBiased")) %>%
  mutate(TypeGroup = ifelse(GroupType == "Control", "Control", ifelse(condition=="All", "Hetero With Biased", "Hetero Without Biased")))

p_converg <- ggplot(df_agg, aes(x=Round, y=mean_lev_dist, color=TypeGroup, group=TypeGroup)) + geom_point()
p_converg <- add_grey_rect_0_10(p_converg)
p_converg <- p_converg + geom_point(size=5) +
  geom_line(size=1) +
  #geom_smooth() +
  labs(y="Convergence", fill="", color="") +
  scale_x_continuous(breaks = c(0:10)) +
  theme(legend.position="bottom")  +
  ylim(0.3,1) +
  geom_pointrange(aes(ymin=mean_lev_dist-se_lev_dist, ymax=mean_lev_dist+se_lev_dist), lwd=1, size=0.5) +
  scale_color_viridis_d(end=0.8) 

p_converg

```

```{r}
df_agg_with <- df %>%
  filter(TypeTest != "PassiveExposure")   %>%
  dplyr::group_by(GroupType, GroupNum, Shape, Round) %>%
  dplyr::summarise(lev_dist_list = 1 - mean(allpairslev(Word))) %>%
  dplyr::group_by(GroupType, Round, GroupNum) %>%
  dplyr::summarise(All = mean(lev_dist_list))

df_agg_without <- df %>%
  filter(TypeTest != "PassiveExposure",
         Producer != "1")   %>%
  dplyr::group_by(GroupType, GroupNum, Shape, Round) %>%
  dplyr::summarise(lev_dist_list = 1 - mean(allpairslev(Word))) %>%
  dplyr::group_by(GroupType, Round, GroupNum) %>%
  dplyr::summarise(WithoutBiased = mean(lev_dist_list))

df_agg <- merge(df_agg_with, df_agg_without, by=c("GroupType", "Round", "GroupNum"))
df_agg <- gather(df_agg, condition, mean_lev_dist, All:WithoutBiased)

df_agg <- df_agg %>%
  filter(!(GroupType == "Control" & condition == "WithoutBiased")) %>%
  mutate(TypeGroup = ifelse(GroupType == "Control", "Control", ifelse(condition=="All", "Hetero With Biased", "Hetero Without Biased"))) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))

summary(lm(mean_lev_dist ~ TypeGroup*Round, data=df_agg))

```

```{r }
#| echo: false
#| message: false
#| warning: false
#| label: fig-evolution-convergence-group-pair
#| fig-cap: "Evolution of convergence with time for each type of pair."
#| fig-width: 10
#| fig-height: 8

# We look at the same convergence measure for the two types of pairs: pairs including the biased participant (1 - 2, 1- 3, 1 - 4) and pairs excluding the biased participant (2 - 3, 2 - 4, 3 - 4). The plot belows shows the aggregated measure for all groups.

# df_agg <- df %>%
#   filter(TypeTest == "ComGame")   %>%
#   mutate(have_biased = ifelse(grepl( "1", pair, fixed = TRUE), "yes", "no")) %>%
#   dplyr::group_by(GroupType, GroupNum, Shape, Round, have_biased) %>%
#   dplyr::summarise(lev_dist_list = 1 - mean(allpairslev(Word))) %>%
#   dplyr::group_by(GroupType, Round, have_biased) %>%
#   dplyr::summarise(mean_lev_dist = mean(lev_dist_list))
# 
# p <- ggplot(df_agg, aes(x=Round, y=mean_lev_dist, color=have_biased, group=have_biased)) + geom_point()
# p <- add_grey_rect_1_9(p)
# p <- p + geom_point(size=5) +
#   geom_line(size=1) +
#   geom_smooth() +
#   scale_x_continuous(breaks = c(0:10))+
#   facet_grid(GroupType ~ .) +
#   labs(color="Pair with biased", y="Mean convergence per pair")
# p

```

### Stability

Stability is a measure of the levenstein distances between all pairs of words from rounds n and n-1

First, we look at the **evolution of stability for each shape**.

To better understand how the function works, let's take an example for the shape *kesip*:

-   At round 7 participants produced *puise*, *kesip*, *esip*, *epi*
-   At round 8 participants produced *puie*, *suki*, *kesip*, *kesip*

Stability is computed by computing the levenshtein distance between all pairs of words (*puise* and *puie*, then *puise* and *suki*, and so on). In this case stability between round 7 and 8 for the shape *kesip* is equal to 0.59.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-evolution-stability-with
#| fig-cap: "Evolution of stability with time for the group (including biased participants."
#| fig-width: 10
#| fig-height: 8

### compute stability for all (with biased)
for ( gr in unique(df$GroupID)){
  for ( myr in c(1:10)){
    for( mys in unique(df$Shape)){
      list1 <- df$Word[df$GroupID == gr & df$Round == myr & df$Shape == mys]
      list2 <- df$Word[df$GroupID == gr & df$Round == myr-1 & df$Shape == mys]
      stab <- mean(allpairslev_rounds(c(list1, list2), length(list1)), na.rm=TRUE)
      df$Stab[df$GroupID == gr & df$Round == myr & df$Shape == mys] <- 1 - stab
    }
  }
}

# aggregate (it is not very important here because the value is same for each)
df_agg <- df %>%
  filter(Round != 0) %>%
  dplyr::group_by(Round, GroupType, Shape) %>%
  dplyr::summarize(stab = mean(Stab))


p <- ggplot(df_agg, aes(x=Round, y=stab, color=Shape, group=Shape)) + geom_point()
p <- add_grey_rect_0_10(p)
p <- p + geom_point(size=5) +
  geom_line(size=1) +
  #geom_smooth() +
  scale_x_continuous(breaks = c(0:10))+
  facet_grid(GroupType ~ .) +
  labs(color="Pair with biased", y="Stability") +
  scale_color_viridis_d()
p

```

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-evolution-stability2
#| fig-cap: "Evolution of stability with time for the group (including biased participants."
#| fig-width: 10
#| fig-height: 8

# ### compute stability for all (with biased)
# for ( gr in unique(df$GroupID)){
#   for ( myr in c(1:10)){
#     for( mys in unique(df$Shape)){
#       list1 <- df$Word[df$GroupID == gr & df$Round == myr & df$Shape == mys]
#       list2 <- df$Word[df$GroupID == gr & df$Round == myr-1 & df$Shape == mys]
#       stab <- mean(allpairslev_rounds(c(list1, list2), length(list1)), na.rm=TRUE)
#       df$Stab[df$GroupID == gr & df$Round == myr & df$Shape == mys] <- 1 - stab
#     }
#   }
# }
# 
# # aggregate (it is not very important here because the value is same for each)
# df_agg_with <- df %>%
#   filter(Round != 0) %>%
#   dplyr::group_by(Round, GroupType, Shape) %>%
#   dplyr::summarize(All = mean(Stab))
# 
# ### compute stability for groups without biased
# df2 <- df %>%
#   filter(Producer != 1)
# 
# for ( gr in unique(df2$GroupID)){
#   for ( myr in c(1:10)){
#     for( mys in unique(df$Shape)){
#       list1 <- df2$Word[df2$GroupID == gr & df2$Round == myr & df2$Shape == mys]
#       list2 <- df2$Word[df2$GroupID == gr & df2$Round == myr-1 & df2$Shape == mys]
#       stab <- mean(allpairslev_rounds(c(list1, list2), length(list1)), na.rm=TRUE)
#       df2$Stab[df2$GroupID == gr & df2$Round == myr & df2$Shape == mys] <- 1 - stab
#     }
#   }
# }
# 
# # aggregate 
# df_agg_without <- df2 %>%
#   filter(Round != 0) %>%
#   dplyr::group_by(Round, GroupType, Shape) %>%
#   dplyr::summarize(WithoutBiased = mean(Stab))
# 
# ## merge
# df_agg <- merge(df_agg_with, df_agg_without, by=c("Round", "GroupType", "Shape"))
# df_agg <- gather(df_agg, condition, Stab, All:WithoutBiased)
# 
# p <- ggplot(df_agg, aes(x=Round, y=Stab, color=Shape, group=Shape)) + geom_point()
# p <- add_grey_rect_0_10(p)
# p <- p + geom_point(size=5) +
#   geom_line(size=1) +
#   #geom_smooth() +
#   scale_x_continuous(breaks = c(0:10))+
#   facet_grid(GroupType ~ condition) +
#   labs(color="Pair with biased", y="Stability") +
#   scale_color_viridis_d()
# p

```

We look at the same type of data, except that it is aggregated by shape.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-evolution-stability-without
#| fig-cap: "Evolution of stability with time for the group (excluding biased participants."
#| fig-width: 10
#| fig-height: 8

# # compute stability
# for ( gr in unique(df$GroupID)){
#   for ( myr in c(1:10)){
#     for( mys in unique(df$Shape)){
#       list1 <- df$Word[df$GroupID == gr & df$Round == myr & df$Shape == mys]
#       list2 <- df$Word[df$GroupID == gr & df$Round == myr-1 & df$Shape == mys]
#       stab <- mean(allpairslev_rounds(c(list1, list2), length(list1)), na.rm=TRUE)
#       df$Stab[df$GroupID == gr & df$Round == myr & df$Shape == mys] <- 1 - stab
#     }
#   }
# }
# 
# # aggregate (it is not very important here because the value is same for each)
# df_agg <- df %>%
#   filter(Round != 0) %>%
#   dplyr::group_by(Round, GroupType, GroupNum) %>%
#   dplyr::summarize(stab = mean(Stab))
# 
# p <- ggplot(df_agg, aes(x=Round, y=stab, color=GroupNum, group=GroupNum)) + geom_point()
# p <- add_grey_rect_0_10(p)
# p <- p + geom_point(size=5) +
#   geom_line(size=1) +
#   geom_smooth() +
#   scale_x_continuous(breaks = c(0:10))+
#   facet_grid(GroupType ~ .) +
#   labs(color="GroupNum", y="Stability") +
#   ylim(0,1) +
#   scale_color_viridis_d()
# p

```

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-evolution-entropy-without-agg
#| fig-cap: "Evolution of stability aggregated with time for each type of group: everyone (all) or everyone except the biased participant (Without Biased)"
#| fig-width: 10
#| fig-height: 5

### compute stability for groups with biased
for ( gr in unique(df$GroupID)){
  for ( myr in c(1:10)){
    for( mys in unique(df$Shape)){
      list1 <- df$Word[df$GroupID == gr & df$Round == myr & df$Shape == mys]
      list2 <- df$Word[df$GroupID == gr & df$Round == myr-1 & df$Shape == mys]
      stab <- mean(allpairslev_rounds(c(list1, list2), length(list1)), na.rm=TRUE)
      df$Stab[df$GroupID == gr & df$Round == myr & df$Shape == mys] <- 1 - stab
    }
  }
}

# aggregate 
df_agg_with <- df %>%
  filter(Round != 0) %>%
  dplyr::group_by(Round, GroupType) %>%
  dplyr::summarize(All = mean(Stab))

### compute stability for groups without biased
df2 <- df %>%
  filter(Producer != 1)

for ( gr in unique(df2$GroupID)){
  for ( myr in c(1:10)){
    for( mys in unique(df2$Shape)){
      list1 <- df2$Word[df2$GroupID == gr & df2$Round == myr & df2$Shape == mys]
      list2 <- df2$Word[df2$GroupID == gr & df2$Round == myr-1 & df2$Shape == mys]
      stab <- mean(allpairslev_rounds(c(list1, list2), length(list1)), na.rm=TRUE)
      df2$Stab[df2$GroupID == gr & df2$Round == myr & df2$Shape == mys] <- 1 - stab
    }
  }
}

# aggregate 
df_agg_without <- df2 %>%
  filter(Round != 0) %>%
  dplyr::group_by(Round, GroupType) %>%
  dplyr::summarize(WithoutBiased = mean(Stab))


## merge
df_agg <- merge(df_agg_with, df_agg_without, by=c("Round", "GroupType"))
df_agg <- gather(df_agg, condition, Stab, All:WithoutBiased)

df_agg <- df_agg %>%
  filter(!(GroupType == "Control" & condition == "WithoutBiased")) %>%
  mutate(TypeGroup = ifelse(GroupType == "Control", "Control", ifelse(condition=="All", "Hetero_All", "Hetero_Unbiased")))

## plot
p <- ggplot(df_agg, aes(x=Round, y=Stab, color=TypeGroup, group=TypeGroup)) + geom_point()
p <- add_grey_rect_0_10(p)
p <- p + geom_point(size=5) +
  geom_line(size=1) +
  #geom_smooth() +
  scale_x_continuous(breaks = c(0:10))+
  labs(color="Which participants?", y="Stability") +
  ylim(0,1) +
  scale_color_viridis_d(end=0.8) 
p

```

```{r}
#| echo: false
#| message: false
#| warning: false
# 
# df %>%
#   filter(TypeTest == "testing_set" | TypeTest == "final_testing") %>%
#   mutate(PartID = as.factor(PartID),
#          Shape = as.factor(Shape)) -> df2
# 
# df_all <- data.frame()
# for (gt in unique(df2$GroupType)){
#   for (gnum in unique(df2$GroupNum)){
#     for (part_id in unique(df2$PartID)){
#       for (shape in unique(df2$Shape)){
#         subdf <- df2[df2$PartID==part_id & df2$Shape==shape,]
#         after_learn <- subdf$Word[subdf$TypeTest=="testing_set"]
#         LEARN_ent_per_word = Entropy(table(after_learn), base=exp(1))
#         LEARN_char_per_word = nchar(paste(after_learn, collapse=""))/length(after_learn)
#         LEARN_ent_per_character = LEARN_ent_per_word/LEARN_char_per_word
#         
#         after_test <- subdf$Word[subdf$TypeTest=="final_testing"]
#         TEST_ent_per_word = Entropy(table(after_test), base=exp(1))
#         TEST_char_per_word = nchar(paste(after_test, collapse=""))/length(after_test)
#         TEST_ent_per_character = TEST_ent_per_word/TEST_char_per_word
#         
#         mydf <- data.frame(GroupType = gt, GroupNum = gnum, PartID=part_id, Shape=shape, EntLearnWord=LEARN_ent_per_word, EntLearnChar = LEARN_ent_per_character, EntTestWord=TEST_ent_per_word, EntTestChar = TEST_ent_per_character)
#         df_all <- rbind(df_all, mydf)
#       }
#     }
#   }
# }
# 
# 
# # this computes the entropy using the following:
# # take a frequency table
# # then convert it to probability table
# # then for each prob compute prob*log(prob)
# # do the sum for each and multiply by -1
# 
# df_all_gat <- gather(df_all, condition, measurement, EntLearnWord:EntTestChar)
# df_all_gat %>%
#   filter(condition == "EntLearnWord" | condition == "EntTestWord") %>%
#   mutate(condition = case_when(condition == "EntLearnWord" ~ "After learning",
#                                condition == "EntTestWord" ~ "After testing")) %>%
#   mutate(Shape = case_when(Shape == 0 ~ "nusa",
#                            Shape == 1 ~ "nus",
#                            Shape == 2 ~ "kesip",
#                            Shape == 3 ~ "esip",
#                            Shape == 4 ~ "puak",
#                            Shape == 5 ~ "nekuki",
#                            Shape == 6 ~ "anap",
#                            Shape == 7 ~ "aike")) -> df_all_gat2
# 



```

## 2 - Group-adaptation to the biased participants

### Per group

#### For all rounds

Here, we calculate the frequency of biased and unbiased letters. For each round, we determine the total frequency of "k" and "a" out of all the letters used in that round to obtain the frequency of biased letters. Similarly, we compute the frequency of "p", "n", "s", "e", "i", and "u" out of the total frequency of letters used in the round to obtain the frequency of unbiased letters. Since there are 6 unbiased letters and 2 biased letters, we divide the frequency of biased letters by 2 and the frequency of unbiased letters by 6.

Please note that the initial labels have slightly more biased letters than unbiased letters. The frequency of each letter in the initial labels (**kesip, esip, nus, nusa, aike, puak, nekuki, anap**) is:

```{r}
#| echo: false
#| message: false
#| warning: false 

# vector of initial words
concat <- paste(unique(df$Word[df$TypeTest=="PassiveExposure"]), sep="", collapse="")

# Look at the frequency table
table(strsplit(concat, ""))

# compute mean initial frequency of biased letter
#init_freq_biased <- mean(str_count(concat, "k")/str_count(concat))*100
#init_freq_unbiased <- mean(str_count(concat, "p")/str_count(concat))*100

# we multiply this by 2 because there are two biased letters
init_freq_biased <- mean(str_count(concat, "k")/str_count(concat))*100*2
```

Thus, the initial frequency of each **biased** letter is of `r round(init_freq_biased, 2)` %.

In all the following plots, we will represent these initial frequencies with a black dashed line.

```{r }
#| echo: false
#| message: false
#| warning: false 
#| label: fig-freq-round-all
#| fig-cap: "Plot showing the evolution of frequency of both biased letters (red) and unbiased letters (blue). Each line represent a group, and the thick line shows the linear regression applied to all these groups."
#| fig-width: 9
#| fig-height: 7

# compute frequency (only biased letters)
df_agg <- df %>%
  filter(TypeTest != "PassiveExposure",
         Producer != "1") %>%
  dplyr::group_by(GroupType, GroupNum, Round) %>% 
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Freq = (biased_count / total_count)*100) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))  %>%
  mutate(Round2 = ifelse(Round == 10, 0, ifelse(Round == 9, 1, ifelse(Round==8, 2, ifelse(Round==7, 3, ifelse(Round==6, 4, ifelse(Round==5, 5, ifelse(Round==4, 6, ifelse(Round==3, 7, ifelse(Round==2, 8, ifelse(Round==1, 9, ifelse(Round==0, 10, NA)))))))))))) %>%
  mutate(RoundType = ifelse(Round == 1 | Round == 3 | Round == 6, "T1", ifelse(Round == 2 | Round == 4 | Round == 7, "T2", ifelse(Round == 3 | Round == 6 | Round == 9, "T3", "TTest"))))


# plot
p_round <- ggplot(df_agg, aes(x=Round, y=Freq, color=GroupType, group = interaction(GroupNum, GroupType)))+ geom_point()
p_round <- add_grey_rect_0_10(p_round)
p_round <- p_round + 
  geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
  geom_point(alpha=0.5, size=1)+
  geom_line(alpha=0.5)+
  geom_smooth(method="lm", data=df_agg, aes(x=Round, y=Freq, color=GroupType, group = GroupType)) +
  labs(y="Mean freq of biased letters (%)", fill="Group") +
  #facet_grid(GroupType ~ .) +
  scale_x_continuous(breaks = c(0:10)) +
  theme(axis.title.y = element_text(size = 17))

p_round

```

Let's use a linear model to study if there is an effect of time and group type on the frequency of biased and unbiased letters.

We ran two types of models: one where we include the testing sessions (as Round 0 and Round 10), and one where we only look at the communication games. For both types of model, we run a model with Round as random slopes, and one simpler model only controlling for the random effect of group ID.

We use models including testing sessions (round 0 to 10):

```{r}
#| echo: false
#| message: false
#| warning: false 

# model with random slopes
model <- lmer(Freq ~ Round2 * GroupType + (1 + RoundType | GroupID), data=df_agg, control=lmerControl(optimizer="bobyqa"))
summary(model)
```

The model with round as a random slope does not converge. We can also control for the type of round: round 1, 3, and 6 involves the same types of pairs, as well as rounds 2, 4, and 7 and rounds 3,6,9.

```{r}
# model without random slopes
model <- lmer(Freq ~ Round2 * GroupType + (1 + RoundType | GroupID), data=df_agg, control=lmerControl(optimizer="bobyqa"))
summary(model)

```

This model also does not converge.

Thus, we look only at a model which have group ID as a random factor.

```{r}
# model without random slopes
model <- lmer(Freq ~ Round2 * GroupType + (1 | GroupID), data=df_agg)
summary(model)

```

The plot and model suggests:

-   There are more variation in heterogenous groups compared to control groups

-   In control groups, the proportion of biased and unbiased letters remain similar to the initial frequency of these letters

-   In heterogenous groups, the proportion of unbiased letters slightly increase with time, while the proportion of biased letters slightly decrease with time.

Let's look at the same plot, but using aggregated values for all groups:

```{r }
#| echo: false
#| message: false
#| warning: false 
#| label: fig-freq-round-all-agg
#| fig-cap: "Same plot as above, aggregated by group number."
#| fig-width: 8
#| fig-height: 6


df_agg <- df %>%
  filter(TypeTest != "PassiveExposure",
         Producer != "1") %>%
  dplyr::group_by(GroupType, Round) %>%
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Freq = (biased_count / total_count)*100)

p <- ggplot(df_agg, aes(x=Round, y=Freq, color=GroupType))+ geom_point()
p <- add_grey_rect_0_10(p)
p <- p +  geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
  geom_point(size=5)+
  geom_line(size=1)+
  #geom_smooth() +
  labs(y="Mean frequency (in %)", fill="Group") +
  scale_x_continuous(breaks = c(0:10)) 
p
```

#### For Testing

The previous plot focused on the evolution of the frequency of biased and unbiased letters across all rounds (0 to 10). Now, we will focus solely on the **Round 0 and the Round 10**, namely, the initial (*FirstTest*, after the passive exposure) and the final testing (*LastTest*, after the communication game).

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-freq-testing2
#| fig-cap: "Change in the frequency of biased and unbiased letters in the first testing (before the communication game) and in the second testing (after the communication game) at a group-level. Each point represent a group, and the thin grey line indicate the within design (each group is tested before and after)."
#| fig-width: 7
#| fig-height: 5

# compute frequency (only biased letters)
df_agg <- df %>%
  filter(TypeTest=="FirstTesting" | TypeTest=="SecondTesting",
         Producer != "1") %>%
  dplyr::group_by(GroupType, GroupNum, Round, TypeTest) %>% 
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Freq = (biased_count / total_count)*100) %>%
  dplyr::select(-c(biased_count, total_count, Words)) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))  %>%
  mutate(Round2 = ifelse(Round == 10, 0, ifelse(Round == 9, 1, ifelse(Round==8, 2, ifelse(Round==7, 3, ifelse(Round==6, 4, ifelse(Round==5, 5, ifelse(Round==4, 6, ifelse(Round==3, 7, ifelse(Round==2, 8, ifelse(Round==1, 9, ifelse(Round==0, 10, NA)))))))))))) %>%
  mutate(TypeTest = case_when(TypeTest == "FirstTesting" ~ "First Test",
                              TypeTest == "SecondTesting" ~ "Last Test")) %>%
  mutate(TypeTest = as.factor(TypeTest)) %>%
  mutate(GroupType = as.character(GroupType)) %>%
  mutate(GroupType = case_when(GroupType=="Hetero" ~ "Heterogenous",
                               GroupType=="Control" ~ "Control")) %>%
  mutate(GroupType = factor(GroupType, levels=c("Heterogenous", "Control"))) %>%
  mutate(RoundType = ifelse(Round == 1 | Round == 3 | Round == 6, "T1", ifelse(Round == 2 | Round == 4 | Round == 7, "T2", ifelse(Round == 3 | Round == 6 | Round == 9, "T3", NA))))

# Plot
p_test <- ggplot(df_agg, aes(x=TypeTest, y=Freq, fill=GroupType))+
  geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
  geom_point(data=df_agg, aes(x=TypeTest, y=Freq, group=GroupNum), size=2) +
  geom_boxplot(color="black", alpha=0.4,position= position_dodge(), width=0.3)+
  theme_bw(base_size=20) +
  geom_line(data=df_agg, aes(x=TypeTest, y=Freq, group=GroupNum), color="grey")+
  labs(x="", y="Mean frequency of biased letters") +
  facet_grid(. ~ GroupType) +
  guides(fill=FALSE, color=FALSE)

p_test
```

```{r}
#| echo: false
#| message: false
#| warning: false


# with random slopes
#mod <- lmer(Freq ~ TypeTest * GroupType + (1 + TypeTest | GroupID), data=df_agg)
#summary(mod)
# this model crashes, because there are as many number of observations as random effects

# without random slopes
mod <- lmer(Freq ~ TypeTest * GroupType + (1 | GroupID), data=df_agg)
summary(mod)
```

##### Boostrapping

Bootstrapping is a resampling technique used in statistics to estimate the uncertainty associated with a sample statistic. It involves repeatedly drawing random samples with replacement from the original data set. By creating multiple bootstrap samples, the method allows for the estimation of sampling variability, constructing confidence intervals, and assessing the statistical significance of results. Bootstrapping is particularly useful when the sample size is small or when the underlying data distribution is unknown or non-normal, as it provides a robust and flexible approach for inference.

```{r}

# Here we used two methods, just to make sure that our results are OK - since they gave the same type of results we only look at method 2


#### ---- Method 1 ---- ####

# # Fit the mixed-effects model
# model <- lmer(Freq ~ GroupType * TypeTest + (1 | GroupID), data = df_agg)
# 
# # Bootstrapping
# num_iterations <- 100  
# boot_results <- matrix(NA, nrow = num_iterations, ncol = 4)  # 4 for coefficients of the Intercept v1, v2, and their interaction
# 
# for (i in 1:num_iterations) {
#   # Resampling
#   sampled_groups <- sample(unique(df_agg$GroupID), replace = TRUE)
#   boot_data <- df_agg[df_agg$GroupID %in% sampled_groups, ]
# 
#   # Model fitting
#   boot_model <- lmer(Freq ~ GroupType * TypeTest + (1 | GroupID), data = boot_data)
# 
#   # Record results
#   boot_results[i, ] <- fixef(boot_model)
# }
# 
# # add names
# colnames(boot_results) <- c("Intercept", "GroupTypeControl", "LastTest", "GroupType:LastTest")
# 
# # Aggregate and summarize results
# mean_coef <- colMeans(boot_results, na.rm = TRUE)
# conf_interval <- quantile(boot_results[,4], c(0.025, 0.975), na.rm = TRUE)
# 
# # Display results
# print("Mean Coefficients:")
# print(mean_coef)
# print("95% Confidence Intervals:")
# print(conf_interval)

#### ---- Method 2 via lmersmapler:---- ####

mod1 <- lmer(Freq ~ GroupType * TypeTest  + (1 | GroupID), data = df_agg)
lmer_par_boot <- bootstrap(mod1, .f = fixef, type = "parametric", B = 100)

### output:

# summary(mod1) # here to compare with the original fit 
#summary(lmer_par_boot)

# get confidence intervals:
confint(lmer_par_boot)
#print(lmer_par_boot,  ci = TRUE)

### plot
plot(lmer_par_boot)

```

##### How to explain Group 2 and Group 6 performance?

@fig-freq-testing2 also highlights two groups within the heterogenous group (**Group 2 and Group 6**) that deviate from this pattern. Our hypothesis is that these groups did not adapt to the biased participant because their participants remembered too well the initial labels, causing them to stick with those words. To further investigate, let's examine the accuracy of the initial learning phase for all groups:

```{r }
#| echo: false
#| message: false
#| warning: false
#| label: fig-acc-group2-and6
#| fig-cap: "Investigating more the relation between adaptability and performance at learning the initial words. Here, we look at the initial accuracy (binary, 0 or 1) and the initial distance words (levenshtein distance) in the first testing for each group. We expect the performance to be better for Group 2 and Group 6."
#| fig-width: 10
#| fig-height: 9

# Look at the learning accuracy for each group
df_agg <- df %>%
  filter(TypeTest == "FirstTesting",
         GroupType == "Hetero") %>%
  group_by(Producer, TypeTest, GroupNum, GroupType) %>%
  summarize(mean_acc = mean(ACC)*100) %>%
  mutate(Producer = as.character(Producer)) %>%
  mutate(Producer = ifelse(Producer == "1", "1 (biased)",Producer)) 

# Plot
p1 <- ggplot(df_agg, aes(x=Producer, y=mean_acc, fill=Producer)) +
  geom_bar(stat="identity") +
  ylim(-5,105) +
  labs(y="Accuracy first learning", x="Participant ID") +
  guides(color=FALSE, fill=FALSE) +
  facet_grid(GroupNum ~ .) +
  coord_flip() +
  geom_hline(yintercept=50, linetype="dashed") 
  
# Compute
df_agg <- df %>%
  filter(TypeTest == "FirstTesting", GroupType == "Hetero") %>%
  mutate(Shape = as.character(Shape)) %>%
  dplyr::group_by(Producer, GroupNum, GroupType) %>%
  dplyr::summarize(mean_lev_dis = mean(DistInitLabel2)) %>%
  mutate(Producer = as.character(Producer)) %>%
  mutate(Producer = ifelse(Producer == "1", "1 (biased)",Producer))

# plot obtained data
p2 <- ggplot(df_agg, aes(x=Producer, y=mean_lev_dis, fill=Producer)) +
  geom_bar(stat="identity") +
  ylim(0,1) +
  labs(y="Norm Levenshtein dist", x="Participant ID") +
  facet_grid(GroupNum ~ .) +
  coord_flip() +
  guides(fill=FALSE)

grid.arrange(p1, p2, ncol=2)

```

It appears that Group 2 and Group 6 (the groups that did not adapt to the biased participants) also exhibited higher learning accuracy. Let's verify whether our hypothesis is encouraged by checking if these groups had nearly identical words at the end compared to the initial words.

**For group 2:**

Before communicating labels:

```{r}
#| echo: false
#| message: false
#| warning: false


df %>%
    filter(TypeTest == "FirstTesting" & GroupNum == 2 & GroupType == "Hetero") %>%
    dplyr::select(Producer, Word, Shape) %>%
    spread(Shape, Word) -> first_name

df %>%
    filter(TypeTest == "SecondTesting" & GroupNum == 2 & GroupType == "Hetero") %>%
    dplyr::select(Producer, Word, Shape) %>%
    spread(Shape, Word) -> last_name
  
  colnames(first_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")
  colnames(last_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")
  
kable(first_name)

```

After communicating labels:

```{r}
#| echo: false
#| message: false
#| warning: false

kable(last_name)
```

**For Group 6:**

Before communicating labels:

```{r}
#| echo: false
#| message: false
#| warning: false

df %>%
    filter(TypeTest == "FirstTesting" & GroupNum == 6 & GroupType == "Hetero") %>%
    dplyr::select(Producer, Word, Shape) %>%
    spread(Shape, Word) -> first_name

df %>%
    filter(TypeTest == "SecondTesting" & GroupNum == 6 & GroupType == "Hetero") %>%
    dplyr::select(Producer, Word, Shape) %>%
    spread(Shape, Word) -> last_name
  
  colnames(first_name) <- c("PartID", "nusa","nus", "kesip", "esip", "puak", "nekuki","anap","aike")
  colnames(last_name) <- c("PartID", "nusa","nus", "kesip", "esip", "puak", "nekuki","anap","aike")
  
kable(first_name)
```

After communicating labels:

```{r}
#| echo: false
#| message: false
#| warning: false

kable(last_name)
```

In order to look more at the relation between learning accuracy and adaptability, please refer to the part \[3 - Adaptability\] and subpart [What do predict adaptation?]

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-adapt-learning
#| fig-cap: "Investigating more the relation between adaptability and performance at learning the initial words. Each point represent a participant, and the blue line shows the linear regression between all these points."
#| fig-width: 6
#| fig-height: 4

# Now, let's take a closer look at how adaptability relates to the average accuracy of learning. To do this, we introduce a measure of adaptability. This measure reflects the difference between the frequency of biased letters during the initial testing and the frequency of biased letters during the final testing for each participant. A higher value indicates a greater reduction in the number of biased letters in their final vocabulary. On the other hand, a negative score for adaptability means that the participant has increased the number of biased letters. More details about adaptability will be available in the part [Relative to participants characteristics].

# # dataset with accuracy
# df_acc <- df %>%
#   filter(TypeTest == "FirstTesting",
#          GroupType == "Hetero", 
#          Producer != 1) %>%
#   group_by(Producer, TypeTest, GroupNum) %>%
#   summarize(mean_acc = mean(ACC)*100) 
# 
# # dataframe with frequency
# df_freq <- df %>%
#   filter(TypeTest == "SecondTesting" | TypeTest == "FirstTesting",
#          Producer != "1",
#          GroupType == "Hetero") %>%
#   dplyr::group_by(GroupNum, TypeTest, Producer) %>% 
#   dplyr::summarise(Words = paste(Word, collapse = "")) %>%
#   mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
#          total_count = str_count(Words, "\\S"),
#          Biased = (biased_count / total_count)/2) %>%
#   dplyr::select(-c(biased_count, total_count, Words)) %>%
#   spread(TypeTest, Biased) %>%
#   mutate(Adaptability = (FirstTesting - SecondTesting)*100) 
#   
# # merge the two dataframes
# df_merged <- merge(df_acc, df_freq, by=c("GroupNum", "Producer"))
# 
# # Plot
# ggplot(df_merged, aes(x=Adaptability, y=mean_acc))+
#   geom_point() +
#   geom_smooth(method="lm") +
#   labs(y="Mean accuracy of learning") +
#   geom_vline(xintercept=0, linetype="dashed")

#There is indeed a relationship between adaptability and mean learning accuracy: the more participants remember the initial labels, the less likely they are to adapt to the biased participants.

```

```{r }
#| echo: false
#| message: false
#| warning: false
#| label: fig-adapt-learning2
#| fig-cap: "Investigating more the relation between adaptability and performance at learning the initial words. Each point represent a participant, and the blue line shows the linear regression between all these points."
#| fig-width: 6
#| fig-height: 4

# 
# # compute frequency
# df_agg <- df %>%
#   filter(TypeTest=="FirstTesting" | TypeTest=="SecondTesting",
#          Producer != "1") %>%
#   dplyr::group_by(GroupType, GroupNum, TypeTest) %>% 
#   dplyr::summarise(Words = paste(Word, collapse = "")) %>%
#   mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
#          total_count = str_count(Words, "\\S"),
#          Biased = (biased_count / total_count)/2,#because there are 2 biased let
#          Normal = (1 - Biased)/6) %>% # because there are 6 unbiased let
#   gather(TypeLetter, Freq, Biased:Normal) %>%
#   dplyr::group_by(GroupType, TypeTest, TypeLetter) %>%
#   dplyr::summarize(mean_freq = mean(Freq),
#                    se_freq = se(Freq))
# 
# 
# ggplot(df_agg, aes(x=TypeTest, y=mean_freq, color=TypeLetter, fill=TypeLetter, group=interaction(TypeTest, TypeLetter)))+
#   geom_pointrange(aes(ymin=mean_freq-se_freq, ymax=mean_freq+se_freq), position=position_dodge()) +
#     geom_line()+
#   facet_grid(GroupType ~ .) +
#   labs(y="Mean frequency", x="")

```

Now, we look at the evolution of the production similarity with the initial labels with time with a specific focus on these two groups:

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-evolution-distinitwords_group
#| fig-cap: "Evolution of the production similarity at each round and for each group. Please note that this plot does not include the productions of the biased participant."
#| fig-width: 8
#| fig-height: 6

# Compute
df_agg <- df %>%
  filter(TypeTest != "PassiveExposure") %>%
  filter(GroupType == "Hetero") %>%
  mutate(GroupNum = as.character(GroupNum)) %>%
  dplyr::group_by(GroupType, Round, GroupNum) %>%
  dplyr::summarize(mean_lev_dis = mean(DistInitLabel2)) %>%
  mutate(colorr = ifelse(GroupNum == 2, "Group2", ifelse(GroupNum==6, "Group6", "Other"))) %>%
  mutate(alphaa = ifelse(colorr=="Other", "high", "low"))

# Plot
p <- ggplot(df_agg, aes(x=Round, y=mean_lev_dis, color=colorr, group=GroupNum, alpha=alphaa)) + geom_point()
p <- add_grey_rect_0_10(p) 
p <- p + geom_point(size=5) +
  geom_line(size=1) +
  facet_grid(GroupType ~ .) +
  labs(y="Production similarity", fill="Shape") +
  scale_x_continuous(breaks = c(0:10)) +
  scale_color_viridis_d(end=0.8) +
  scale_alpha_manual(values=c(0.4, 0.8)) +
  guides(alpha=FALSE)
p

```

This plot helps understand the non adaptability of group 2 - participants of this group converged on the initial labels. However, we do not know more about the performance of Group 6.

### Per individual

#### For all rounds

This is the same plot as before, except that we plot here the results for each participant.

```{r }
#| echo: false
#| message: false
#| warning: false 
#| label: fig-freq-round-indiv-all
#| fig-cap: "Plot showing the evolution of frequency of both biased letters (red) and unbiased letters (blue). Each line represent a group, and the thick line shows the linear regression applied to all these groups."
#| fig-width: 10
#| fig-height: 8

# compute frequency (only biased letters)
df_agg <- df %>%
  filter(TypeTest != "PassiveExposure",
         Producer != "1") %>%
  dplyr::group_by(GroupType, GroupNum, Round, Producer) %>% 
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Freq = (biased_count / total_count)*100) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))  %>%
  mutate(Round2 = ifelse(Round == 10, 0, ifelse(Round == 9, 1, ifelse(Round==8, 2, ifelse(Round==7, 3, ifelse(Round==6, 4, ifelse(Round==5, 5, ifelse(Round==4, 6, ifelse(Round==3, 7, ifelse(Round==2, 8, ifelse(Round==1, 9, ifelse(Round==0, 10, NA)))))))))))) %>%
  mutate(RoundType = ifelse(Round == 1 | Round == 3 | Round == 6, "T1", ifelse(Round == 2 | Round == 4 | Round == 7, "T2", ifelse(Round == 3 | Round == 6 | Round == 9, "T3", NA)))) %>%
  mutate(PartID_unique = paste(GroupType, GroupNum, Producer, sep="_")) %>%
  ungroup()

# plot
p <- ggplot(df_agg, aes(x=Round, y=Freq, color=GroupType, group = PartID_unique))+ geom_point()
p <- add_grey_rect_0_10(p)
p <- p + 
  geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
  geom_point(alpha=0.5, size=1)+
  geom_line(alpha=0.5)+
  geom_smooth(method="lm", data=df_agg, aes(x=Round, y=Freq, color=GroupType, group = GroupType)) +
  labs(y="Mean Freq of biased letters (%)", fill="Group") +
  #facet_grid(GroupType ~ .) +
  scale_x_continuous(breaks = c(0:10))
p

```

The model failed to converge when including Round as a random slope.

```{r}

# with random slopes
model <- lmer(Freq ~ Round2 * GroupType + (1 + Round2 | GroupID / PartID_unique) , data =  df_agg, control=lmerControl(optimizer="bobyqa"))
summary(model)
```

Instead, we can control for the type of pairs in which participants are talking:

```{r}

df_agg$pairs <- ifelse( ((df_agg$Round == 1 | df_agg$Round == 4 | df_agg$Round == 7) & df_agg$Producer == 2), "1_2", 
                        ifelse(((df_agg$Round == 1 | df_agg$Round == 4 | df_agg$Round == 7) & df_agg$Producer != 2), "3_4", 
                               ifelse(((df_agg$Round == 2 | df_agg$Round == 5 | df_agg$Round == 8) & df_agg$Producer == 3), "1_3", 
                                      ifelse(((df_agg$Round == 2 | df_agg$Round == 5 | df_agg$Round == 8) & df_agg$Producer != 3), "2_4", 
                                            ifelse(((df_agg$Round == 3 | df_agg$Round == 6 | df_agg$Round == 9) & df_agg$Producer == 4), "1_4", 
                                                ifelse(((df_agg$Round == 3 | df_agg$Round == 6 | df_agg$Round == 9) & df_agg$Producer != 4), "2_3", "None"))))))

# without random slopes
model <- lmer(Freq ~ Round2 * GroupType + (1 + pairs | GroupID / PartID_unique), data = df_agg)
summary(model)

```

This model does not converge either. Thus, we keep only the model with Participant ID and group ID as random factors.

```{r}

# with random slopes
model <- lmer(Freq ~ Round2 * GroupType + (1 | GroupID / PartID_unique), data =  df_agg)
summary(model)
```

#### For Testing

This plot is the same as before, except that we plot here the output for each participant.

```{r}
#| echo: false
#| message: false
#| warning: false 
#| label: fig-freq-indv
#| fig-cap: "Evolution of the mean frequency of biased  and unbiased letters for each individual in each group type."
#| fig-width: 9
#| fig-height: 7

df_freq <- df %>%
  filter(TypeTest == "FirstTesting" | TypeTest == "SecondTesting") %>%
  dplyr::group_by(GroupType, GroupNum, Round, Producer) %>% 
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Freq = (biased_count / total_count)*100) %>%
  dplyr::select(-c(Words, biased_count, total_count)) %>%
  filter(!(Producer == 1 & GroupType == "Hetero")) %>%
  mutate(Round = case_when(Round == 0 ~ "First Test",
                           Round == 10 ~ "Last Test")) %>%
  dplyr::rename(TypeTest = Round) %>%
  mutate(ID = paste(GroupNum,  Producer, sep="_")) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_")) %>%
  mutate(PartID_unique = paste(GroupType, GroupNum, Producer, sep="_")) %>%
  ungroup()

# plot
ggplot(df_freq, aes(x=TypeTest, y=Freq, fill=GroupType)) +
  facet_grid(. ~ GroupType) +
  #geom_hline(aes(yintercept=Value_DashedLine), linetype="dashed", size=0.6)+
  geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
  #geom_hline(yintercept = init_freq_unbiased, linetype = "dashed") +
  geom_point(data=df_freq, aes(x=TypeTest, y=Freq, group=ID), size=2) +
  geom_boxplot(color="black", alpha=0.2,position= position_dodge(), width=0.3)+
  theme_bw(base_size=15) +
  geom_line(data=df_freq, aes(x=TypeTest, y=Freq, group=ID), color="grey") +
  labs(y="Mean Freq of biased letters (%)")

```

```{r}
#| echo: false
#| message: false
#| warning: false

# without random slopes
model <- lmer(Freq ~ TypeTest * GroupType + (1 | GroupID / PartID_unique) , data = df_freq)
summary(model)

# with random slopes: does not work
#model <- lmer(Freq ~ TypeTest * GroupType + (1 + TypeTest | GroupID / PartID_unique) , data = df_freq)
#summary(model)

```

```{r}
#| echo: false
#| message: false
#| warning: false 
#| label: fig-freq-indiv2
#| fig-cap: "Same as before, except that here we don't have an index Before and After, but an index that shows the difference between the two instead."
#| fig-width: 8
#| fig-height: 5

# Now, we compute the difference before and after. We plot it:


# df_freq_diff <- df_freq %>%
#   spread(TypeTest, Freq) %>%
#   mutate(diff = `Last Test` - `First Test`) %>%
#   dplyr::select(-c(`Last Test`, `First Test`))
# 
# 
# # Visual look
# ggplot(df_freq_diff, aes(x=GroupType, y=diff, color=GroupType, fill=GroupType)) +
#   geom_boxplot(color="black", alpha=0.3) +
#   geom_hline(yintercept = 0, linetype="dashed") +
#   geom_point(pch = 21, position = position_jitterdodge()) +
#   labs(y="Diff in BL freq - After and Before Interact") +
#   guides(color=FALSE, fill=FALSE)

```

### Summary: per group & per pair

```{r}
#| echo: false
#| message: false
#| warning: false 
#| label: fig-freq-all
#| fig-cap: "Plot showing the evolution of frequency of both biased letters (red) and unbiased letters (blue). Each line represent a group, and the thick line shows the linear regression applied to all these groups. The grey dashed lines shows the initial frequencies of biased and unbiased letters in the initial labels."
#| fig-width: 10
#| fig-height: 8

# # compute frequency
# df_agg <- df %>%
#   filter(TypeTest != "PassiveExposure",
#          Producer != "1") %>%
#   filter(Round == 0 | Round == 7 | Round == 8 | Round==9 | Round == 10) %>%
#   mutate(Moment = ifelse(Round == 0, "FirstTest", ifelse(Round==10, "FinalTest", ifelse(Round==9 & Producer==4, "LastBiased", ifelse(Round==8 & Producer==3, "LastBiased", ifelse(Round==7 & Producer==2, "LastBiased", ifelse(Round==8 & Producer==4, "LastUnbiased", ifelse(Round==9 & (Producer==2 | Producer==3), "LastUnbiased", NA)))))))) %>%
#   filter(is.na(Moment)==FALSE) %>%
#   dplyr::group_by(GroupType, GroupNum, Producer, Moment) %>% 
#   dplyr::summarise(Words = paste(Word, collapse = "")) %>%
#   mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
#          unbiased_count = str_count(Words, "p") + str_count(Words, "s") + str_count(Words, "n") + str_count(Words, "i") + str_count(Words, "u") + str_count(Words, "e"),
#          total_count = str_count(Words, "\\S"),
#          Biased = (biased_count / total_count)/2*100,#because there are 2 biased let
#          Normal = (unbiased_count / total_count)/6*100) %>% # because there are 6 unbiased let
#   #dplyr::select(-c(k_count, a_count, total_count, a_frequency, k_frequency, Words)) %>%
#   gather(TypeLetter, Freq, Biased:Normal) %>%
#   mutate(Moment = factor(Moment, levels=c("FirstTest", "LastUnbiased", "LastBiased", "FinalTest"))) 
# 
# df_agg2 <- df_agg %>%
#   dplyr::group_by(GroupType, Moment, TypeLetter) %>%
#   dplyr::summarize(mean_freq = mean(Freq),
#                    se_freq = se(Freq))
# 
# ggplot(df_agg, aes(x=Moment, y=Freq, color=TypeLetter, fill=TypeLetter))+ 
#   geom_point(alpha=0.7, position=position_jitterdodge(0.2))+
#   #geom_boxplot(width=0.3, color="black", alpha=0.3, position=position_dodge(0.5)) +
#   geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
#   geom_hline(yintercept = init_freq_unbiased, linetype = "dashed")+
#   guides(fill=FALSE) +
#   geom_pointrange(data=df_agg2, mapping=aes(x=Moment, y=mean_freq, ymin=mean_freq-se_freq, color=TypeLetter, ymax=mean_freq+se_freq),position = position_dodge(width = 0.6), color="black")  +
#   facet_grid(GroupType ~ .) 
# 
# ggplot(df_agg, aes(x=Moment, y=Freq, color=TypeLetter, fill=TypeLetter))+ 
#   geom_violin(alpha=0.7, position=position_dodge(0.5))+
#   #geom_boxplot(width=0.3, color="black", alpha=0.3, position=position_dodge(0.5)) +
#   geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
#   geom_hline(yintercept = init_freq_unbiased, linetype = "dashed")+
#   guides(fill=FALSE) +
#   geom_pointrange(data=df_agg2, mapping=aes(x=Moment, y=mean_freq, ymin=mean_freq-se_freq, color=TypeLetter, ymax=mean_freq+se_freq),position = position_dodge(width = 0.5), color="black")  +
#   facet_grid(GroupType ~ .) 
# 
# summary(lmer(Freq ~ Moment*TypeLetter*GroupType + (1 | GroupNum), data=df_agg))



```

Using violin plots and stadnard errors

```{r}
#| echo: false
#| message: false
#| warning: false 
#| label: fig-freq-all2
#| fig-cap: "Plot showing the evolution of frequency of both biased letters (red) and unbiased letters (blue). Each point represents a participant, and its production at specific moment: with it lasts interaction with a unbiased participant (left panel, left side), and a biased participant (left panel, right side), and during its first testing before communication game (right panel, left side), and during the last testing after communication game (right panel, right side). "
#| fig-width: 10
#| fig-height: 8

# 1 - compute frequency for last three rounds
df_agg1 <- df %>%
  filter(TypeTest != "PassiveExposure",
         Producer != "1") %>%
  filter(Round == 7 | Round == 8 | Round==9) %>%
  mutate(Moment = ifelse(GroupType == "Control", "Control", ifelse(Round==9 & Producer==4, "Biased", ifelse(Round==8 & Producer==3, "Biased", ifelse(Round==7 & Producer==2, "Biased", ifelse(Round==8 & Producer==4, "Unbiased", ifelse(Round==9 & (Producer==2 | Producer==3), "Unbiased", NA))))))) %>%
  filter(is.na(Moment)==FALSE) %>%
  dplyr::group_by(GroupType, GroupNum, Producer, Moment) %>% 
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Freq = (biased_count / total_count)*100) %>%
  mutate(TypeMoment = "LastInteraction")

# 2 - compute frequency for first and last
df_agg3 <- df %>%
  filter(TypeTest != "PassiveExposure",
         Producer != "1") %>%
  filter(Round == 0 | Round == 10) %>%
  mutate(Moment = ifelse(Round == 0, "First Test", ifelse(Round==10, "Last Test", "NA"))) %>%
  filter(is.na(Moment)==FALSE) %>%
  dplyr::group_by(GroupType, GroupNum, Producer, Moment) %>% 
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Freq = (biased_count / total_count)*100)  %>%
  mutate(TypeMoment = "Test")

# 3 - merge this two dataset and change order factors
df_agg <- rbind(df_agg1, df_agg3)
df_agg <- df_agg %>% 
  mutate(Moment = factor(Moment, levels=c("Control", "First Test", "Unbiased", "Biased", "Last Test"))) 

# 4 - summarize frequency by moment
df_agg2 <- df_agg %>%
  dplyr::group_by(GroupType, Moment, TypeMoment) %>%
  dplyr::summarize(mean_freq = mean(Freq),
                   se_freq = se(Freq)) 

# 5 - reformat
df_agg2 <- df_agg2 %>%
  mutate(Moment = as.character(Moment)) %>%
  mutate(ValueColor = df_agg2$mean_freq[df_agg2$Moment=="Control"]) %>%
  mutate(SeColor = df_agg2$se_freq[df_agg2$Moment=="Control"]) %>%
  filter(Moment!="Control")


### VIOLIN PLOT ###

p1 <- ggplot(df_agg[df_agg$TypeMoment=="LastInteraction",], aes(x=Moment, y=Freq, color=GroupType, fill=GroupType))+ 
  #geom_point(alpha=0.2, position=position_jitterdodge(0.2))+
  geom_violin(alpha=0.2)+
  geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
  geom_pointrange(data=df_agg2[df_agg2$TypeMoment=="LastInteraction",], mapping=aes(x=Moment, y=mean_freq, ymin=mean_freq-se_freq,  ymax=mean_freq+se_freq),position = position_dodge(width = 0.9))  +
  facet_grid(. ~ TypeMoment) +
  theme(legend.position="bottom") +
  ylim(12,42)+
  labs(x="", y="Mean Freq of biased letters (%)")

p2 <- ggplot(df_agg[df_agg$TypeMoment=="Test",], aes(x=Moment, y=Freq, color=GroupType, fill=GroupType))+ 
  #geom_point(alpha=0.2, position=position_jitterdodge(0.2))+
  #geom_boxplot(width=0.3, color="black", alpha=0.3, position=position_dodge(0.5)) +
  geom_violin(alpha=0.2)+
  geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
  geom_pointrange(data=df_agg2[df_agg2$TypeMoment=="Test",], mapping=aes(x=Moment, y=mean_freq, ymin=mean_freq-se_freq, ymax=mean_freq+se_freq),position = position_dodge(width = 0.9))  +
  facet_grid(. ~ TypeMoment) +
   theme(legend.position="bottom") +
  scale_y_continuous(breaks = seq(10, 20, by = 5)) +
  ylim(12,42) +
  labs(x="", y="Mean Freq of biased letters (%)")

ggarrange(p1, p2, ncol=2, nrow=1, common.legend = TRUE, legend="bottom")

### STANDARD ERROR PLOT ###

p1 <- ggplot(df_agg2[df_agg2$TypeMoment=="LastInteraction",], aes(x=Moment, y=mean_freq))+ 
  #geom_point(alpha=0.2, position=position_jitterdodge(0.2))+
  #geom_violin(alpha=0.2)+
  geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
  geom_pointrange(data=df_agg2[df_agg2$TypeMoment=="LastInteraction",], mapping=aes(x=Moment, y=mean_freq, ymin=mean_freq-se_freq,  ymax=mean_freq+se_freq),position = position_dodge(width = 0.9), color="cyan3")  +
  facet_grid(. ~ TypeMoment) +
  theme(legend.position="bottom") +
  ylim(20,31) +
  labs(x="", y="Mean Freq of biased letters (%)") +
  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = ValueColor-SeColor, ymax = ValueColor+SeColor), alpha=0.1, fill="red") +
  geom_hline(aes(yintercept = ValueColor), color="red3", size=1)   


p2 <- ggplot(df_agg[df_agg$TypeMoment=="Test",], aes(x=Moment, y=Freq, color=GroupType, fill=GroupType))+ 
  #geom_point(alpha=0.2, position=position_jitterdodge(0.2))+
  #geom_boxplot(width=0.3, color="black", alpha=0.3, position=position_dodge(0.5)) +
  #geom_violin(alpha=0.2)+
  geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
  geom_pointrange(data=df_agg2[df_agg2$TypeMoment=="Test",], mapping=aes(x=Moment, y=mean_freq, ymin=mean_freq-se_freq, ymax=mean_freq+se_freq),position = position_dodge(width = 0.9))  +
  facet_grid(. ~ TypeMoment) +
   theme(legend.position="bottom") +
  scale_y_continuous(breaks = seq(10, 20, by = 5)) +
  ylim(20,31) +
  labs(x="", y="Mean Freq of biased letters (%)")


ggarrange(p1, p2, ncol=2, nrow=1, common.legend = TRUE, legend="bottom")

```

## 3 - Pair-level adaptation to the biased participant

We focus here on the pair-level: we compare the productions of the participants in the pair excluding the biased participants (pair between 2 - 3, 3 - 4, and 2 - 4), to the production used by pairs involving the biased participant (pair with 1 - 2, 1 - 3, and 1 - 4). Important note: the length of input between pair without and with the biased participant do not have the same length, as we do not look at the productions of Participant 1. For example, in Round 1, we compare the output of:

-   Pair without the biased participant (*Hetero_unbiased*): production of participant 3 and participant 4 -\> **16 words in total**

-   Pair involving the biased participant (*Hetero_biased*): production of participant 2 only (we did not look at the frequency of biased letter for participant 1 because this participant is unable to produce any of these letters) -\> **8 words in total**

```{r}
#| echo: false
#| message: false
#| warning: false 
#| label: fig-freq-testing3
#| fig-cap: "Evolution of the mean frequency of biased letters comparing two types of pair: pair including the biased participant (1-2, 1-3, and 1-4) and pair excluding the biased participant (2-3, 3-4, 2-4)."
#| fig-width: 10
#| fig-height: 8

# # compute frequency
# df_agg <- df %>%
#   filter(TypeTest == "ComGame",
#          Producer != "1") %>%
#   dplyr::group_by(GroupType, Round, pair) %>% 
#   dplyr::summarise(Words = paste(Word, collapse = "")) %>%
#   mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
#          unbiased_count = str_count(Words, "p") + str_count(Words, "s") + str_count(Words, "n") + str_count(Words, "i") + str_count(Words, "u") + str_count(Words, "e"),
#          total_count = str_count(Words, "\\S"),
#          Biased = ((biased_count / total_count)/2), #because there are 2 biased let
#          Normal = ((unbiased_count / total_count)/6)) %>% # because there are 6 unbiased let
#   dplyr::select(-c(biased_count, total_count, Words)) %>%
#   gather(TypeLetter, Freq, Biased:Normal) %>%
#   mutate(Freq = Freq*100)
# 
# # create this format that enable the nice plotting
# df_agg2 <- df_agg %>%
#   group_by(pair,Round, TypeLetter, GroupType) %>%
#   summarize(mean_freq = mean(Freq))  %>%
#   mutate(pair = as.factor(pair)) %>%
#   mutate(pair2 = pair) %>%
#   separate(pair2, c("parta", "partb"), "_") %>%
#   gather(condition, Producer, parta, partb) %>%
#   dplyr::select(-condition) %>%
#   mutate(Producer = as.factor(Producer),
#          Round = as.character(Round)) %>%
#   filter(Producer != "1")
# 
# # plot
# p <-  ggplot(df_agg2[df_agg2$TypeLetter=="Biased",], aes(x=Round, y=mean_freq, fill=Producer)) + geom_point()
# p <- add_grey_rect_1_9(p)
# p <- p +  labs(y="Mean frequency of biased letter (%)", x="Round", fill="Participant")  +
#   geom_dotplot(binaxis = "y", stackdir = "centerwhole", stackgroups = TRUE, binpositions = "all", binwidth = 0.5) +
#   facet_grid(GroupType ~ .) +
#   geom_hline(yintercept = init_freq_biased, linetype="dashed")+
#   geom_hline(yintercept = init_freq_unbiased, linetype="dashed")
# 
# p
```

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-freq-testing
#| fig-cap: "Change in the frequency of biased and unbiased letters in the first testing (before the communication game) and in the second testing (after the communication game) at a group-level. Each point represent a group, and the thin grey line indicate the within design (each group is tested before and after)."
#| fig-width: 12
#| fig-height: 7


# compute frequency
df_agg <- df %>%
  filter(TypeTest == "ComGame",
         Producer != "1") %>%
  mutate(type = ifelse(GroupType == "Control", "Control", ifelse(grepl( "1", pair, fixed = TRUE), "Hetero_Biased", "Hetero_Unbiased"))) %>%
  dplyr::group_by(type, Round) %>% 
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Freq = (biased_count / total_count)) %>%
  dplyr::select(-c(biased_count, total_count, Words)) %>%
  mutate(Freq = Freq*100) %>%
  mutate(Round = as.factor(Round))


p <- ggplot(df_agg, aes(x=Round, y=Freq, color=type, group=type))+ 
  geom_point() 
p <- add_grey_rect_1_9(p) 
p <- p +   
  geom_hline(yintercept = init_freq_biased, linetype="dashed")+
  geom_point(size=5, position=position_dodge(width=0.5)) +   
  geom_line(size=1, position=position_dodge(width=0.5)) +   
  labs(y="Mean frequency (in %)", fill="Group")  
p 


# mod <- lmer(mean_freq ~ TypeLetter * TypeTest * GroupType + (1 | GroupNum), data=df_agg)
# summary(mod)

```

A very interesting observation appear: in Round 3, pairs with unbiased individuals use very few biased letters! This can be explained by the fact that these two unbiased participants have been paired with the biased participant in the rounds just before.

We merge these results per round, to have a look at the global picture:

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-3-chapter
#| fig-cap: "Evolution of the mean frequency of biased letters comparing two types of pair: pair including the biased participant (1-2, 1-3, and 1-4) and pair excluding the biased participant (2-3, 3-4, 2-4)."
#| fig-width: 7
#| fig-height: 5

# compute frequency for heterogenous groups
df_agg_hetero <- df %>%
  filter(TypeTest == "ComGame",
         Producer != "1",
         GroupType=="Hetero") %>%
  mutate(TalkToBiased = ifelse(Guesser=="1", "Yes", "No")) %>% 
  dplyr::group_by(GroupType, GroupNum, Producer, TalkToBiased) %>% 
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Freq = ((biased_count / total_count))) %>%
  dplyr::select(-c(biased_count, total_count, Words)) %>%
  mutate(Freq = as.numeric(Freq*100))

# compute frequency for control groups
df_agg_control <- df %>%
  filter(TypeTest == "ComGame",
         GroupType=="Control") %>%
  dplyr::group_by(GroupType, GroupNum, Producer) %>% 
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Freq = ((biased_count / total_count))) %>% 
  dplyr::select(-c(biased_count, total_count, Words)) %>%
  mutate(Freq = as.numeric(Freq*100))

# ggplot(df_agg, aes(x=TypeLetter, y=Freq, fill=TalkToBiased))+
#   geom_violin(width=0.5, alpha=0.2) +
#   geom_point(pch = 21, position = position_jitterdodge(jitter.width=0.3) ) +
#   theme_bw(base_size=15) +
#   labs(y="Freq letter", x="Biased letter", fill="Talk to") +
#   facet_grid(GroupType ~ .)

# Compute mean and se for heterogenous groups
df_agg_hetero2 <- df_agg_hetero %>%
  group_by(GroupType, TalkToBiased) %>%
  summarize(se_freq = se(Freq),
            Freq = mean(Freq))

# Compute mean and se for control groups
df_agg_control2 <- df_agg_control %>%
  group_by(GroupType) %>%
  summarize(se_freq = se(Freq),
            Freq = mean(Freq)) %>%
  mutate(TalkToBiased=NA)

# add the value for color in hetero groups
df_agg2 <- df_agg_hetero2 %>% 
  mutate(ValueColor = df_agg_control2$Freq) %>%
  mutate(SeColor = df_agg_control2$se_freq) 

# Plot
ggplot(df_agg2, aes(x=TalkToBiased, y=Freq))+
  geom_line()+
  geom_violin(data=df_agg_hetero, aes(x=TalkToBiased, y=Freq, fill=TalkToBiased), alpha=0.3)+
  #geom_jitter(data=df_agg_hetero, aes(x=TalkToBiased, y=Freq, color=TalkToBiased), alpha=0.3)+
  geom_pointrange(data=df_agg_hetero2, aes(x=TalkToBiased, y=Freq, ymin=Freq-se_freq, ymax=Freq+se_freq),lwd=1.1, size=0.7) +
  theme_bw(base_size=20) +
  labs(y="Mean freq of biased letters (%)", x="Communicate with biased participant?") +
  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = ValueColor-SeColor, ymax = ValueColor+SeColor), alpha=0.1, fill="red") +
  geom_hline(aes(yintercept = ValueColor), color="red3", size=1)  +  
  geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
  guides(fill=FALSE) +
  theme(axis.title.y = element_text(size = 17),
        axis.title.x = element_text(size = 17))


# ggplot(df_agg2, aes(x=TalkToBiased, y=Freq))+
#   geom_line()+
#   #geom_violin(data=df_agg_hetero, aes(x=TalkToBiased, y=Freq, fill=TalkToBiased), alpha=0.3)+
#   #geom_jitter(data=df_agg_hetero, aes(x=TalkToBiased, y=Freq, color=TalkToBiased), alpha=0.3)+
#   geom_pointrange(data=df_agg2, aes(x=TalkToBiased, y=Freq, ymin=Freq-se_freq, ymax=Freq+se_freq), size=0.7) +
#   theme_bw(base_size=20) +
#   labs(y="Mean frequency of biased letters", x="Talk to biased participant?") +
#   geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = ValueColor-SeColor, ymax = ValueColor+SeColor), alpha=0.1, fill="red") +
#   geom_hline(aes(yintercept = ValueColor), color="red3", size=1)  +  
#   geom_hline(yintercept = init_freq_biased, linetype = "dashed") 


```

We build two models: one in which the group type is a fixed effect (but please note that this introduces a bias, since in control groups, there is no "talk to bias" or "talk to unbias" - instead, it reflects whether participants 2, 3, and 4 talk to participant1 or not).

```{r }

# # compute frequency
df_agg <- df %>%
  filter(TypeTest == "ComGame",
         Producer != "1") %>%
  mutate(TalkToBiased = ifelse(Guesser=="1", "Yes", "No")) %>%
  dplyr::group_by(GroupType, GroupNum, Producer, TalkToBiased) %>%
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Freq = ((biased_count / total_count)/2)) %>%
  dplyr::select(-c(biased_count, total_count, Words)) %>%
  mutate(Freq = Freq*100) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_")) %>%
  mutate(PartID_unique = paste(GroupType, GroupNum, Producer, sep="_"))

# model
model <- lmer(Freq ~ GroupType * TalkToBiased + (1 | GroupID / PartID_unique), data=df_agg)
summary(model)

```

Then, we also look only at heterogenous groups:

```{r }

# # compute frequency
df_agg <- df %>%
  filter(TypeTest == "ComGame",
         Producer != "1",
         GroupType=="Hetero") %>%
  mutate(TalkToBiased = ifelse(Guesser=="1", "Yes", "No")) %>%
  dplyr::group_by(GroupType, GroupNum, Producer, TalkToBiased) %>%
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Freq = ((biased_count / total_count)/2)) %>%
  dplyr::select(-c(biased_count, total_count, Words)) %>%
  mutate(Freq = Freq*100) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_")) %>%
  mutate(PartID_unique = paste(GroupType, GroupNum, Producer, sep="_"))

# model
model <- lmer(Freq ~ TalkToBiased + (1 | GroupID / PartID_unique), data=df_agg)
summary(model)

```

```{r}
#| echo: false
#| message: false
#| warning: false

# We apply a linear mixed-effect models, where we look at the frequency of biased letters for each participant. We study the effect of the variable "condition":
# 
#  - Heterogeneous, talk to biased
#  - Heterogeneous, talk to unbiased
#  - Control group, talk to both
#  
# The random effect are Group Num and Producer.
# 
# First, we include all variables:
# 
# 
# # compute frequency
# df_agg_hetero <- df %>%
#   filter(TypeTest == "ComGame",
#          Producer != "1",
#          GroupType=="Hetero") %>%
#   mutate(TalkToBiased = ifelse(Guesser=="1", "Biased", "Unbiased")) %>% 
#   dplyr::group_by(GroupType, GroupNum, Producer, TalkToBiased) %>% 
#   dplyr::summarise(Words = paste(Word, collapse = "")) %>%
#   mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
#          total_count = str_count(Words, "\\S"),
#          Freq = ((biased_count / total_count))) %>%
#   dplyr::select(-c(biased_count, total_count, Words)) %>%
#   mutate(Freq = as.numeric(Freq*100)) %>%
#   mutate(condition = paste("Hetero", TalkToBiased, sep="_")) %>%
#   ungroup() %>%
#   dplyr::select(-TalkToBiased)
# 
# df_agg_control <- df %>%
#   filter(TypeTest == "ComGame",
#          GroupType=="Control") %>%
#   dplyr::group_by(GroupType, GroupNum, Producer) %>% 
#   dplyr::summarise(Words = paste(Word, collapse = "")) %>%
#   mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
#          total_count = str_count(Words, "\\S"),
#          Freq = ((biased_count / total_count))) %>% 
#   dplyr::select(-c(biased_count, total_count, Words)) %>%
#   mutate(Freq = as.numeric(Freq*100)) %>%
#   mutate(condition = "Control")
# 
# df_agg <- rbind(df_agg_hetero, df_agg_control)
# df_agg <- df_agg %>% 
#   mutate(GroupID = paste(GroupType, GroupNum, sep="_")) %>%
#   mutate(PartID_unique = paste(GroupType, GroupNum, Producer, sep="_"))
# 
# # model <- lmer(Freq ~ condition + (1 | GroupID) + (1 | PartID_unique) , data=df_agg)
# # summary(model)
# 
# 
# model <- lmer(Freq ~ condition + (1 | GroupID), data=df_agg[df_agg$condition != "Hetero_Unbiased",])
# summary(model)
```

We create an index for each participant: the difference in frequency of letter when this participant is talking to the Biased compared to when talking to the other. A high value in "yes" mean that the participant uses way less (biased or unbiased) letters when talking to the biased participant.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-freq-pair2
#| fig-cap: "Evolution of the mean frequency of biased letters comparing two types of pair: pair including the biased participant (1-2, 1-3, and 1-4) and pair excluding the biased participant (2-3, 3-4, 2-4)."
#| fig-width: 6
#| fig-height: 6

# df_agg3 <- df_agg %>%
#   spread(TalkToBiased, Freq) %>%
#   mutate(diff = No - Yes) 
# 
# ggplot(df_agg3, aes(x=GroupType, y = diff, fill=GroupType)) +
#   geom_boxplot(alpha=0.3, color="black") +
#   geom_jitter(pch = 21) +
#   geom_hline(yintercept = 0, linetype = "dashed") +
#   labs(y="no <- Adaptation -> yes")
# 
# model <- lmer(diff ~ GroupType + (1 | GroupNum), data=df_agg3)
# summary(model)

```

## 3bis - Adaptability

### Measures

We compute three measures of adaptability based on the ratio of letter frequency:

-   **Adapt1.** The first one reflects, for each participant, the difference between the frequency of biased letter in the *FirstTesting* and the frequency of biased letter in the *SecondTesting*. A larger number indicates a greater decrease in the number of biased letters in the participants' final vocabulary (so the participant adapted to the peculiarities of the biased participant). Conversely, a negative score for adaptability means that the person has increased the number of biased letters (so the participant did ***not*** adapt to the peculiarities of the biased participant).

-   **Adapt2.** The measure is very similar to the first one, except that here we do not look at the First and Second Testing, but at all interactions with the biased participants made from Round 1 to 9.

-   **Adapt3**. This measure is the most complex, and the most likely to efficiently represent adaptability. We arbitrarily created a score based on a decision tree, see image below:

![](Pictures/Adaptation_scale.jpg){width="780"}

-   Adapt4. This is similar to Adapt3, except that here, we look at the normalized distance between:

    -   d1: the new item produced and the item the partner has said

    -   d2: the new item produced and the last item produced by the participant.

        Then, we computed the Adapt4 as 2\*(1-d1) + d2 (see below)

        ![](Pictures/Adaptation_scale2.jpg)

We look at this only in **heterogenous** groups for Adapt1 and Adapt2, and for both groups (**heterogeneous and control**) in Adapt3.

```{r}
#| echo: false
#| message: false
#| warning: false 

# ------------------ADAPT1 --------------------- #
df_adapt1 <- df %>%
  filter(TypeTest == "SecondTesting" | TypeTest == "FirstTesting",
         Producer != "1",
         GroupType == "Hetero") %>%
  dplyr::group_by(GroupNum, TypeTest, Producer, GroupType) %>% 
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Biased = (biased_count / total_count)) %>%
  dplyr::select(-c(biased_count, total_count, Words)) %>%
  spread(TypeTest, Biased) %>%
  mutate(Adaptability1 = (FirstTesting - SecondTesting)*100) %>%
  dplyr::rename(PartID = Producer)

# ------------------ADAPT2 --------------------- #
df_adapt2 <- df %>%
  filter(TypeTest == "ComGame",
         Producer != "1",
         GroupType == "Hetero")  %>%
  mutate(TalkToBiased = ifelse(Guesser=="1", "Yes", "No")) %>%
  dplyr::group_by(GroupType, GroupNum, Producer, TalkToBiased) %>% 
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Biased = ((biased_count / total_count))) %>% 
  dplyr::select(-c(biased_count, total_count, Words)) %>%
  spread(TalkToBiased, Biased) %>%
  mutate(Adaptability2 = (No - Yes)*100) %>%
  dplyr::rename(PartID = Producer)

# ------------------ADAPT3 --------------------- #

# Initiliaze the data frame with the first word pronounced by all
df %>%
  filter(TypeTest == "FirstTesting") %>%
  dplyr::select(GroupID, Round, Producer, Shape, Word) %>%
  mutate(adapt3 = NA) -> df_adapt3

# filter dataframe to look at every Round for each group
for (gid in unique(df$GroupID)){
  for (myround in c(1:9)){
    for (mypair in unique(df$pair[df$TypeTest=="ComGame"])){
      subdf <- df %>%
        filter(TypeTest == "ComGame",
               GroupID == gid,
               Round == myround,
               pair == mypair) %>%
        filter(GroupID != "1_Hetero") 
        subdf <- subdf[order(subdf$index),]
        
        # look at each shape, find who is the second producer
        for (myshape in unique(subdf$Shape)){
          id_second <- subdf$Producer[subdf$Shape == myshape][2]
          
          # Find out which word this person has listened to
          listen <- subdf$Word[subdf$Shape == myshape & subdf$Producer != id_second ]
          # ... and then which word this producer has produced
          produce <- subdf$Word[subdf$Shape == myshape & subdf$Producer == id_second ]
          
          # then retrieve in the memory what was the latest word pronound by this person
          subdf2 <- df_adapt3 %>% filter(GroupID == gid,
                            Shape == myshape,
                            Producer == id_second)
          latest_it <- subdf2$Word[length(subdf2$Word)]
          
          # Find what is the initial label for the word
          goodword <- myshape
          
          # Compute a measure of adaptability based on these items
          adapt3 <- compute_adapt3(goodword, latest_it, listen, produce)
          row <- c(gid, myround, id_second, myshape, produce, adapt3)
          
          # And add to dataframe
          df_adapt3[nrow(df_adapt3) + 1,] <- row
  
        }
     }
  }
}
df_adapt3$adapt3 <- as.numeric(df_adapt3$adapt3)
df_adapt3 <- df_adapt3 %>% separate(GroupID, c("GroupNum", "GroupType"))

# We first aggregate it per Participant, to see how adaptability evolves
df_adapt3 %>%
  filter(Round != 0) %>%
  dplyr::group_by(Producer, GroupNum, GroupType) %>%
  dplyr::summarize(Adaptability3 = mean(adapt3)) %>%
  dplyr::rename(PartID = Producer) -> adapt3_id


# ------------------ADAPT4--------------------- #
# Initiliaze the data frame with the first word pronounced by all
df %>%
  filter(TypeTest == "FirstTesting") %>%
  dplyr::select(GroupID, Round, Producer, Shape, Word) %>%
  mutate(adapt4 = NA) -> df_adapt4

# filter dataframe to look at every Round for each group
for (gid in unique(df$GroupID)){
  for (myround in c(1:9)){
    for (mypair in unique(df$pair[df$TypeTest=="ComGame"])){
      subdf <- df %>%
        filter(TypeTest == "ComGame",
               GroupID == gid,
               Round == myround,
               pair == mypair) %>%
        filter(GroupID != "1_Hetero") 
        subdf <- subdf[order(subdf$index),]
        
        # look at each shape, find who is the second producer
        for (myshape in unique(subdf$Shape)){
          id_second <- subdf$Producer[subdf$Shape == myshape][2]
          
          # Find out which word this person has listened to
          listen <- subdf$Word[subdf$Shape == myshape & subdf$Producer != id_second ]
          # ... and then which word this producer has produced
          produce <- subdf$Word[subdf$Shape == myshape & subdf$Producer == id_second ]
          
          # then retrieve in the memory what was the latest word pronound by this person
          subdf2 <- df_adapt4 %>% filter(GroupID == gid,
                            Shape == myshape,
                            Producer == id_second)
          latest_it <- subdf2$Word[length(subdf2$Word)]
          
          # Find what is the initial label for the word
          goodword <- myshape
          
          # Compute a measure of adaptability based on these items
          adapt4 <- compute_adapt4(latest_it, listen, produce)
          row <- c(gid, myround, id_second, myshape, produce, adapt4)
          
          # And add to dataframe
          df_adapt4[nrow(df_adapt4) + 1,] <- row
  
        }
     }
  }
}
df_adapt4$adapt4 <- as.numeric(df_adapt4$adapt4)
df_adapt4 <- df_adapt4 %>% separate(GroupID, c("GroupNum", "GroupType"))


# We first aggregate it per Participant, to see how adaptability evolves
df_adapt4 %>%
  filter(Round != 0) %>%
  dplyr::group_by(Producer, GroupNum, GroupType) %>%
  dplyr::summarize(Adaptability4 = mean(adapt4)) %>%
  dplyr::rename(PartID = Producer) -> adapt4_id

# --------------------------------------- #

# merge the two dataframe with previous data
df_other <- merge(df_other, df_adapt1[,c("GroupNum", "GroupType", "PartID", "Adaptability1")], by=c("GroupNum", "GroupType", "PartID"), all.x=TRUE)

# merge all
df_other <- merge(df_other, df_adapt2[,c("GroupNum", "GroupType", "PartID", "Adaptability2")], by=c("GroupNum", "GroupType", "PartID"), all.x=TRUE)

# merge all
df_other <- merge(df_other, adapt3_id[,c("GroupNum", "GroupType", "PartID", "Adaptability3")], by=c("GroupNum", "GroupType", "PartID"), all.x=TRUE)

# merge all
df_other <- merge(df_other, adapt4_id[,c("GroupNum", "GroupType", "PartID", "Adaptability4")], by=c("GroupNum", "GroupType", "PartID"), all.x=TRUE)




```

```{r}
#| echo: false
#| message: false
#| warning: false 
#| label: fig-distrib-adapt
#| fig-cap: "Correlation between the adaptability scores."
#| fig-width: 10
#| fig-height: 6
# What distribution for these measures?
# p1 <- ggplot(df_other, aes(x=Adaptability1)) +
#   geom_histogram()
# p1bis <- ggplot(df_other, aes(x=Adaptability1)) +
#   geom_density()
# p2 <- ggplot(df_other, aes(x=Adaptability2)) +
#   geom_histogram()
# p2bis <- ggplot(df_other, aes(x=Adaptability2)) +
#   geom_density()
# p3 <- ggplot(df_other, aes(x=Adaptability3)) +
#   geom_histogram()
# p3bis <- ggplot(df_other, aes(x=Adaptability3)) +
#   geom_density()
# p4 <- ggplot(df_other, aes(x=Adaptability4)) +
#   geom_histogram()
# p4bis <- ggplot(df_other, aes(x=Adaptability4)) +
#   geom_density()
# grid.arrange(p1, p2, p3,p4, ncol=4, nrow=1)
```

Do these measures correlate with each other, and how are they distributed?

```{r }
#| echo: false
#| message: false
#| warning: false 
#| label: fig-corr-adapt
#| fig-cap: "Correlation between the adaptability scores."
#| fig-width: 7
#| fig-height: 6

df_other %>%
  dplyr::select(Adaptability1, Adaptability2, Adaptability3, Adaptability4) %>%
  drop_na() %>%
  ggpairs(lower=list(continuous=wrap("smooth", colour="black")),
          upper = list(continuous = wrap("cor", size=6, colour = "black"))) +
  theme(strip.text = element_text(size = 10),
        axis.text = element_text(size = 10))

# # plot
# p1 <- ggplot(df_other, aes(x=Adaptability1, y=Adaptability2)) +
#   geom_point()+
#   geom_smooth(method="lm")
# p2 <- ggplot(df_other, aes(x=Adaptability2, y=Adaptability3)) +
#   geom_point()+
#   geom_smooth(method="lm")
# p3 <- ggplot(df_other, aes(x=Adaptability1, y=Adaptability3)) +
#   geom_point()+
#   geom_smooth(method="lm")
# grid.arrange(p1, p2, p3, ncol= 3)
# 
# # corr 1 - 2
# p12 <- cor(df_other$Adaptability1[is.na(df_other$Adaptability1)==FALSE], df_other$Adaptability2[is.na(df_other$Adaptability1)==FALSE], method = "pearson")
# s12 <- cor(df_other$Adaptability1[is.na(df_other$Adaptability1)==FALSE], df_other$Adaptability2[is.na(df_other$Adaptability1)==FALSE], method = "spearman")
# 
# # corr 2 - 3
# p23 <- cor(df_other$Adaptability2[is.na(df_other$Adaptability2)==FALSE & is.na(df_other$Adaptability3)==FALSE], df_other$Adaptability3[is.na(df_other$Adaptability2)==FALSE & is.na(df_other$Adaptability3)==FALSE], method="pearson")
# s23 <- cor(df_other$Adaptability2[is.na(df_other$Adaptability2)==FALSE & is.na(df_other$Adaptability3)==FALSE], df_other$Adaptability3[is.na(df_other$Adaptability2)==FALSE & is.na(df_other$Adaptability3)==FALSE], method="spearman")
# 
# # corr 1 - 3
# p13 <- cor(df_other$Adaptability1[is.na(df_other$Adaptability1)==FALSE & is.na(df_other$Adaptability3)==FALSE], df_other$Adaptability3[is.na(df_other$Adaptability1)==FALSE & is.na(df_other$Adaptability3)==FALSE], method="pearson")
# s13 <- cor(df_other$Adaptability1[is.na(df_other$Adaptability1)==FALSE & is.na(df_other$Adaptability3)==FALSE], df_other$Adaptability3[is.na(df_other$Adaptability1)==FALSE & is.na(df_other$Adaptability3)==FALSE], method="spearman")

```

The correlation netween the measure for Adaptability 1 and 2 is quite low, while it should be higher.

```{r}
#| echo: false
#| message: false
#| warning: false 
#| label: fig-evolution-adapt3
#| fig-cap: "Evolution of Adaptability 3 with time."
#| fig-width: 9
#| fig-height: 7
 
# How does the third measure of adaptability evolve with time?

# # We now have a measure for each participant in each Round, and each interaction. 
# # We first aggregate it per Round, to see how adaptability evolves
# df_adapt3 %>%
#   filter(Round != 0) %>%
#   dplyr::group_by(Round, GroupType, GroupNum) %>%
#   dplyr::summarize(mean_adapt3 = mean(adapt3)) -> adapt3_round
# 
# # show evolution per round
# p <- ggplot(data = adapt3_round, aes(x=Round, y=mean_adapt3, color=GroupNum, group=GroupNum)) + geom_point()
# p <- add_grey_rect_0_10(p)
# p <- p + geom_point(size=5) +
#   geom_line(size=1) +
#   facet_grid(GroupType ~ .) +
#   geom_hline(yintercept = 0, linetype="dashed") +
#   labs(y="Adapt3") +
#   scale_color_viridis_d()
# p

```

### Predictors

However, we will still try to observe how our different metrics (such as age, gender...: see [Method]) correlate with the adaptability scores. First, we look at the variable distribution.

```{r}
#| echo: false
#| message: false
#| warning: false 
#| label: fig-distrib-var
#| fig-cap: "Distribution of the scores. Red shows the results for the control group, blue shows the results for the heterogenous group."
#| fig-width: 10
#| fig-height: 6

p1 <- ggplot(df_other, aes(x=prosoc, fill=GroupType)) +
  geom_density(alpha=0.5) +
  guides(fill=FALSE)
p2 <- ggplot(df_other, aes(x=WorkingMem, fill=GroupType)) +
  geom_density(alpha=0.5) +
  guides(fill=FALSE)
p3 <- ggplot(df_other, aes(x=CogFlexibility, fill=GroupType)) +
  geom_density(alpha=0.5) +
  guides(fill=FALSE)
p4 <- ggplot(df_other, aes(x=DictatorGame, fill=GroupType)) +
  geom_histogram(stat="count", position = position_dodge()) +
  guides(fill=FALSE)
p5 <- ggplot(df_other, aes(x=Age, fill=GroupType)) +
  geom_density(alpha=0.5) +
  guides(fill=FALSE)
p6 <- ggplot(df_other, aes(x=Gender, fill=GroupType)) +
  geom_histogram(stat="count", position = position_dodge()) +
  guides(fill=FALSE)
p7 <- ggplot(df_other, aes(x=AccLearning, fill=GroupType)) +
  geom_density(alpha=0.5) +
  guides(fill=FALSE)
p8 <- ggplot(df_other, aes(x=DistInitWords, fill=GroupType)) +
  geom_density(alpha=0.5) +
  guides(fill=FALSE)

grid.arrange(p1, p2, p3, p4, p5, p6, p7, p8, ncol=4, nrow=2)
```

Just a reminder:

-   the global working memory is the overall inverse efficiency (reaction time divided by accuracy) in the task-switching experiment, only in letters+numbers task: **the higher, the worst the workig memory**
-   the cognitive flexibility is measured in the letters+numbers task in the task switching experiment. It is the normalized difference (by time) of the time needed to switch between two tasks and the time needed when performing the same task: **the higher, the worst the cognitive flexibility**

Let's look at the correlations between the numerical variables:

```{r}
#| echo: false
#| message: false
#| warning: false 
#| label: fig-corr-predictors
#| fig-cap: "Correlation between the predictors."
#| fig-width: 12
#| fig-height: 11
#| 
df_other %>%
  dplyr::select(prosoc, DictatorGame, Age, WorkingMem, CogFlexibility, AccLearning, DistInitWords, Gender) %>%
  drop_na() %>%
  ggpairs(lower=list(continuous=wrap("smooth", colour="black")),
          upper = list(continuous = wrap("cor", size=6, colour = "black"))) +
  theme(strip.text = element_text(size = 10),
        axis.text = element_text(size = 10))
```

### What do predict adaptation?

We can look at all scores together:

```{r}

# df_other  %>%
#   dplyr::select(PartID, prosoc, DictatorGame, Age, WorkingMem, CogFlexibility, AccLearning, DistInitWords, Adaptability1, Adaptability2, Adaptability3, Adaptability4) %>%
#   pivot_longer(names_to = "Feature", values_to = "Value", -c(PartID, Adaptability1, Adaptability2, Adaptability3, Adaptability4)) %>%
#   pivot_longer(names_to = "Density", values_to = "dens_Value", -c(PartID, Feature, Value) ) %>%
#   drop_na %>%
#   ggplot(aes(x = Value, y = dens_Value)) +
#   geom_point() +
#   geom_smooth(method = "lm") +
#   facet_grid(Density~Feature, scales = "free") +
#   theme(legend.position = "top") +
#   labs(x="",y="")

```

But, in order to see more clearly (and also add the effect of gender, which we could not see in the plot above, we will have a closer look at each of our Adaptability measures.

We first look at the measure using the score of ***Adaptability1***:

(please note that this variable only includes participants from heterogenous groups)

```{r }
#| echo: false
#| message: false
#| warning: false 
#| label: fig-adapt1
#| fig-cap: "Correlations between the different individual measures and our score for Adaptability1. Reminder: in the dictator game 1 is keeping all the money for oneself, 5 is to share it all."
#| fig-width: 10
#| fig-height: 8


# rename column
df_other2 <- df_other %>%
  filter(GroupType == "Hetero")

# plot
p1 <- ggplot(df_other2, aes(x=prosoc, y=Adaptability1))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15) 

p2 <- ggplot(df_other2, aes(x=WorkingMem, y=Adaptability1))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

p3 <- ggplot(df_other2, aes(x=CogFlexibility, y=Adaptability1))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

p4 <- ggplot(df_other2, aes(x=DictatorGame, y=Adaptability1))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15) 

p5 <- ggplot(df_other2, aes(x=Age, y=Adaptability1))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15) 

p6 <- ggplot(df_other2, aes(x=Gender, y=Adaptability1))+
  geom_boxplot()+
  theme_bw(base_size=15) 

p7 <- ggplot(df_other2, aes(x=AccLearning, y=Adaptability1))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

p8 <- ggplot(df_other2, aes(x=DistInitWords, y=Adaptability1))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

grid.arrange(p1,p2,p3,p4,p5,p6,p7,p8, nrow=2, ncol=4)
```

Model:

```{r}

model <- lmer(Adaptability1 ~ prosoc + WorkingMem + CogFlexibility + DictatorGame + Age + Gender + AccLearning + DistInitWords + (1 | GroupNum), data = df_other2)
summary(model)
r.squaredGLMM(model)

```

RÂ²m focuses solely on the fixed effects' contribution to explaining variance, while RÂ²c takes into account both the fixed effects and the random effects.

We look at the exact same plots using the score for ***Adaptability2***:

```{r }
#| echo: false
#| message: false
#| warning: false 
#| label: fig-adapt2
#| fig-cap: "Correlations between the different individual measures and our score for Adaptability2. Reminder: in the dictator game 1 is keeping all the money for oneself, 5 is to share it all."
#| fig-width: 10
#| fig-height: 8

# rename column
df_other2 <- df_other %>%
  filter(GroupType == "Hetero")

# plot
p1 <- ggplot(df_other2, aes(x=prosoc, y=Adaptability2))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15) 

p2 <- ggplot(df_other2, aes(x=WorkingMem, y=Adaptability2))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

p3 <- ggplot(df_other2, aes(x=CogFlexibility, y=Adaptability2))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

p4 <- ggplot(df_other2, aes(x=DictatorGame, y=Adaptability2))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15) 

p5 <- ggplot(df_other2, aes(x=Age, y=Adaptability2))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15) 

p6 <- ggplot(df_other2, aes(x=Gender, y=Adaptability2))+
  geom_boxplot()+
  theme_bw(base_size=15) 

p7 <- ggplot(df_other2, aes(x=AccLearning, y=Adaptability2))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

p8 <- ggplot(df_other2, aes(x=DistInitWords, y=Adaptability2))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

grid.arrange(p1,p2,p3,p4,p5,p6,p7,p8, nrow=2, ncol=4)

```

Model:

```{r}

model <- lmer(Adaptability2 ~ prosoc + WorkingMem + CogFlexibility + DictatorGame + Age + Gender + AccLearning + DistInitWords + (1 | GroupNum), data = df_other2)
summary(model)
r.squaredGLMM(model)

```

We look at the exact same plots using the score for ***Adaptability3***:

```{r }
#| echo: false
#| message: false
#| warning: false 
#| label: fig-adapt3
#| fig-cap: "Correlations between the different individual measures and our score for Adaptability3. Reminder: in the dictator game 1 is keeping all the money for oneself, 5 is to share it all."
#| fig-width: 10
#| fig-height: 8

# rename column
df_other2$GroupID <- paste(df_other2$GroupType, df_other2$GroupNum, sep="_")
df_other$GroupID <- paste(df_other$GroupType, df_other$GroupNum, sep="_")

# plot
p1 <- ggplot(df_other2, aes(x=prosoc, y=Adaptability3))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15) 

p2 <- ggplot(df_other2, aes(x=WorkingMem, y=Adaptability3))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

p3 <- ggplot(df_other2, aes(x=CogFlexibility, y=Adaptability3))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

p4 <- ggplot(df_other2, aes(x=DictatorGame, y=Adaptability3))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15) 

p5 <- ggplot(df_other2, aes(x=Age, y=Adaptability3))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15) 

p6 <- ggplot(df_other2, aes(x=Gender, y=Adaptability3))+
  geom_boxplot()+
  theme_bw(base_size=15) 

p7 <- ggplot(df_other2, aes(x=AccLearning, y=Adaptability3))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

p8 <- ggplot(df_other2, aes(x=DistInitWords, y=Adaptability3))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

grid.arrange(p1,p2,p3,p4,p5,p6,p7,p8, nrow=2, ncol=4)

```

Model:

```{r}

model <- lmer(Adaptability3 ~ prosoc + WorkingMem + CogFlexibility + DictatorGame + Age + Gender + AccLearning + DistInitWords + (1 | GroupID), data = df_other)
summary(model)
r.squaredGLMM(model)

```

We look at the exact same plots using the score for ***Adaptability4***:

```{r }
#| echo: false
#| message: false
#| warning: false 
#| label: fig-adapt4
#| fig-cap: "Correlations between the different individual measures and our score for Adaptability4. Reminder: in the dictator game 1 is keeping all the money for oneself, 5 is to share it all."
#| fig-width: 10
#| fig-height: 8


# plot
p1 <- ggplot(df_other2, aes(x=prosoc, y=Adaptability4))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15) 

p2 <- ggplot(df_other2, aes(x=WorkingMem, y=Adaptability4))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

p3 <- ggplot(df_other2, aes(x=CogFlexibility, y=Adaptability4))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

p4 <- ggplot(df_other2, aes(x=DictatorGame, y=Adaptability4))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15) 

p5 <- ggplot(df_other2, aes(x=Age, y=Adaptability4))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15) 

p6 <- ggplot(df_other2, aes(x=Gender, y=Adaptability4))+
  geom_boxplot()+
  theme_bw(base_size=15) 

p7 <- ggplot(df_other2, aes(x=AccLearning, y=Adaptability4))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

p8 <- ggplot(df_other2, aes(x=DistInitWords, y=Adaptability4))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

grid.arrange(p1,p2,p3,p4,p5,p6,p7,p8, nrow=2, ncol=4)


```

```{r}

model <- lmer(Adaptability4 ~ prosoc + WorkingMem + CogFlexibility + DictatorGame + Age + Gender + AccLearning + DistInitWords + (1 | GroupID), data = df_other)
summary(model)
r.squaredGLMM(model)
car::vif(model)

# model <- lmer(Adaptability4 ~ prosoc*Age*Gender*CogFlexibility*DistInitWords + (1 | GroupID), data = df_other)
# summary(model)

```

```{r}
# Same but with the variables being centered:
# 
# df_other_z <- df_other %>%
#   mutate(prosoc_z = scale(prosoc, center = TRUE, scale = FALSE),
#          WorkingMem_z = scale(WorkingMem, center = TRUE, scale = FALSE),
#          CogFlexibility_z = scale(CogFlexibility, center = TRUE, scale = FALSE),
#          DictatorGame_z = scale(DictatorGame, center = TRUE, scale = FALSE),
#          Age_z = scale(Age, center = TRUE, scale = FALSE),
#          AccLearning_z = scale(AccLearning, center = TRUE, scale = FALSE),
#          DistInitWords_z = scale(DistInitWords, center = TRUE, scale = FALSE))
# 
# model <- lmer(Adaptability4 ~ prosoc_z + WorkingMem_z + CogFlexibility_z + DictatorGame_z + Age_z + Gender + AccLearning_z + DistInitWords_z + (1 | GroupID), data = df_other_z)
# summary(model)
# r.squaredGLMM(model)

```

Let's have a look at how the Adaptbility score of participants evolve with time:

```{r}
# We first aggregate it per Participant, to see how adaptability evolves
df_adapt4 %>%
  filter(Round != 0) %>%
  dplyr::group_by(GroupType, Round) %>%
  dplyr::summarize(Adaptability4 = mean(adapt4))  -> adapt44

ggplot(adapt44, aes(x=Round, y=Adaptability4, color=GroupType, group=GroupType)) +
  geom_point() +
  geom_line() + 
  geom_smooth()
```

# Chapter plots

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-1-chapter
#| fig-cap: "Evolution of stability aggregated with time for each type of group: everyone (all) or everyone except the biased participant (Without Biased)"
#| fig-width: 12
#| fig-height: 5

ggarrange(p_comsuccess, p_converg, p_distlabel, ncol=3, labels="AUTO", common.legend = TRUE, legend="bottom", font.label = list(size = 16, color = "black"))
```

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-2-chapter
#| fig-cap: ""
#| fig-width: 11
#| fig-height: 5

# compute frequency (only biased letters)
df_agg <- df %>%
  filter(TypeTest != "PassiveExposure",
         Producer != "1") %>%
  dplyr::group_by(GroupType, GroupNum, Round) %>% 
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Freq = (biased_count / total_count)*100) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))  %>%
  mutate(Round2 = ifelse(Round == 10, 0, ifelse(Round == 9, 1, ifelse(Round==8, 2, ifelse(Round==7, 3, ifelse(Round==6, 4, ifelse(Round==5, 5, ifelse(Round==4, 6, ifelse(Round==3, 7, ifelse(Round==2, 8, ifelse(Round==1, 9, ifelse(Round==0, 10, NA))))))))))))

# plot
p_round <- ggplot(df_agg[!(df_agg$Round == 0 |df_agg$Round==10),], aes(x=Round, y=Freq, color=GroupType, group = interaction(GroupNum, GroupType)))+ geom_point()
p_round <- add_grey_rect_1_9(p_round)
p_round <- p_round + 
  geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
  geom_point(alpha=0.5, size=1)+
  geom_line(alpha=0.5)+
  geom_smooth(method="lm", data=df_agg[!(df_agg$Round == 0 |df_agg$Round==10),], aes(x=Round, y=Freq, color=GroupType, group = GroupType)) +
  labs(y="Mean freq of biased letters (%)    ", fill="Group") +
  #facet_grid(GroupType ~ .) +
  scale_x_continuous(breaks = c(0:10)) +
  theme(axis.title.y = element_text(size = 17),
        axis.title.x = element_text(size = 17)) +
  scale_x_continuous(breaks = 1:9)




# compute frequency (only biased letters)
df_agg <- df %>%
  filter(TypeTest=="FirstTesting" | TypeTest=="SecondTesting",
         Producer != "1") %>%
  dplyr::group_by(GroupType, GroupNum, Round, TypeTest) %>% 
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Freq = (biased_count / total_count)*100) %>%
  dplyr::select(-c(biased_count, total_count, Words)) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))  %>%
  mutate(Round2 = ifelse(Round == 10, 0, ifelse(Round == 9, 1, ifelse(Round==8, 2, ifelse(Round==7, 3, ifelse(Round==6, 4, ifelse(Round==5, 5, ifelse(Round==4, 6, ifelse(Round==3, 7, ifelse(Round==2, 8, ifelse(Round==1, 9, ifelse(Round==0, 10, NA)))))))))))) %>%
  mutate(TypeTest = case_when(TypeTest == "FirstTesting" ~ "First Test",
                              TypeTest == "SecondTesting" ~ "Last Test")) %>%
  mutate(TypeTest = as.factor(TypeTest)) %>%
  mutate(GroupType = as.character(GroupType)) %>%
  mutate(GroupType = case_when(GroupType=="Hetero" ~ "Heterogenous",
                               GroupType=="Control" ~ "Control")) %>%
  mutate(GroupType = factor(GroupType, levels=c("Control", "Heterogenous")))


# Plot
p_test <- ggplot(df_agg, aes(x=TypeTest, y=Freq, fill=GroupType))+
  geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
  geom_point(data=df_agg, aes(x=TypeTest, y=Freq, group=GroupNum), size=2) +
  geom_boxplot(color="black", alpha=0.7,position= position_dodge(), width=0.3)+
  theme_bw(base_size=20) +
  geom_line(data=df_agg, aes(x=TypeTest, y=Freq, group=GroupNum), color="grey")+
  labs(x="", y="Mean freq of biased letters (%)") +
  facet_grid(. ~ GroupType) +
  guides(fill=FALSE, color=FALSE) +
  theme(axis.title.y = element_text(size = 17))


ggarrange(p_round, p_test, ncol=2, nrow=1, labels="AUTO", common.legend = TRUE, legend="bottom", font.label = list(size = 16, color = "black"))

```



```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-2-chapterbis
#| fig-cap: ""
#| fig-width: 11
#| fig-height: 5

# compute frequency (only biased letters)
df_agg <- df %>%
  filter(TypeTest != "PassiveExposure",
         Producer != "1") %>%
  dplyr::group_by(GroupType, GroupNum, Round) %>% 
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Freq = (biased_count / total_count)*100) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))  %>%
  mutate(Round2 = ifelse(Round == 10, 0, ifelse(Round == 9, 1, ifelse(Round==8, 2, ifelse(Round==7, 3, ifelse(Round==6, 4, ifelse(Round==5, 5, ifelse(Round==4, 6, ifelse(Round==3, 7, ifelse(Round==2, 8, ifelse(Round==1, 9, ifelse(Round==0, 10, NA))))))))))))

# plot
p_round <- ggplot(df_agg, aes(x=Round, y=Freq, color=GroupType, group = interaction(GroupNum, GroupType)))+ geom_point()
p_round <- add_grey_rect_0_10(p_round)
p_round <- p_round + 
  geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
  geom_point(alpha=0.5, size=1)+
  geom_line(alpha=0.5)+
  geom_smooth(method="lm", data=df_agg, aes(x=Round, y=Freq, color=GroupType, group = GroupType)) +
  labs(y="Mean freq of biased letters (%)    ", fill="Group") +
  #facet_grid(GroupType ~ .) +
  scale_x_continuous(breaks = c(0:10)) +
  theme(axis.title.y = element_text(size = 17),
        axis.title.x = element_text(size = 17)) 




# compute frequency (only biased letters)
df_agg <- df %>%
  filter(TypeTest=="FirstTesting" | TypeTest=="SecondTesting",
         Producer != "1") %>%
  dplyr::group_by(GroupType, GroupNum, Round, TypeTest) %>% 
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Freq = (biased_count / total_count)*100) %>%
  dplyr::select(-c(biased_count, total_count, Words)) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))  %>%
  mutate(Round2 = ifelse(Round == 10, 0, ifelse(Round == 9, 1, ifelse(Round==8, 2, ifelse(Round==7, 3, ifelse(Round==6, 4, ifelse(Round==5, 5, ifelse(Round==4, 6, ifelse(Round==3, 7, ifelse(Round==2, 8, ifelse(Round==1, 9, ifelse(Round==0, 10, NA)))))))))))) %>%
  mutate(TypeTest = case_when(TypeTest == "FirstTesting" ~ "First Test",
                              TypeTest == "SecondTesting" ~ "Last Test")) %>%
  mutate(TypeTest = as.factor(TypeTest)) %>%
  mutate(GroupType = as.character(GroupType)) %>%
  mutate(GroupType = case_when(GroupType=="Hetero" ~ "Heterogenous",
                               GroupType=="Control" ~ "Control")) %>%
  mutate(GroupType = factor(GroupType, levels=c("Control", "Heterogenous")))


# Plot
p_test <- ggplot(df_agg, aes(x=TypeTest, y=Freq, fill=GroupType))+
  geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
  geom_point(data=df_agg, aes(x=TypeTest, y=Freq, group=GroupNum), size=2) +
  geom_boxplot(color="black", alpha=0.7,position= position_dodge(), width=0.3)+
  theme_bw(base_size=20) +
  geom_line(data=df_agg, aes(x=TypeTest, y=Freq, group=GroupNum), color="grey")+
  labs(x="", y="Mean freq of biased letters (%)") +
  facet_grid(. ~ GroupType) +
  guides(fill=FALSE, color=FALSE) +
  theme(axis.title.y = element_text(size = 17))


ggarrange(p_round, p_test, ncol=2, nrow=1, labels="AUTO", common.legend = TRUE, legend="bottom", font.label = list(size = 16, color = "black"))

```
