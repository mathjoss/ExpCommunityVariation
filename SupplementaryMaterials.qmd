---
title: "Analysis"
subtitle: "Full analyses and plots"
author: "Anonymous"
date: "`r date()`"
format:
  html: 
    toc: true
    html-math-method: katex
    toc-depth: 3
    theme: cerulean
    fontsize: 0.95em
    #number-sections: true
crossref:
  fig-title: '**Figure**'
  labels: arabic
  title-delim: "**.**"
---

```{r}
#| message: false
#| warning: false
#| echo: false

# load libraries
library(dplyr)
library(ggplot2)
library(stringr)
library(tidyr)
library(stringdist) # for levenshtein distance
library(DescTools) # for entropy
library(gridExtra)
library(cba) # for distance between words
#library(kableExtra)
library(knitr)
library(rstatix) # for anova tests
library(lmerTest) # for mixed effect models
library(boot) # for bootstrapping
library(MuMIn) # for computing R2 in mixed effect model
library(reshape) # for function melt to create heatmap
library(GGally)
library(ggpubr)
library(lmeresampler) # for bootstrapping
library(lme4) # for bootstrapping too
library(sjPlot) # for diagnostic plots

## Knitting options:
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE,   
                      fig.pos = "!H", # default code chunk options
                      fig.width=10, fig.height=7, fig.align="center", comment=NA, 
                      fig.path="./figures/",                                      
                      dpi=100, dev="jpeg", cache=FALSE, autodep=TRUE);              

## Various folders:
if( !dir.exists("./figures") ) dir.create("./figures", showWarnings=FALSE)

## affect colour
scale_colour_continuous <- scale_colour_viridis_c(end=0.8)
scale_colour_discrete <- scale_colour_viridis_d(end=0.8)
scale_colour_binned <- scale_colour_viridis_b(end=0.8)
scale_fill_continuous <- scale_fill_viridis_c(end=0.8)
scale_fill_discrete <- scale_fill_viridis_d(end=0.8)
scale_fill_binned <- scale_fill_viridis_b(end=0.8)

## affect general theme
theme_set(theme_bw(base_size = 20))
```

```{r}
#| message: false
#| warning: false
#| echo: false

# Standard error function
se <- function(x) sd(x)/sqrt(length(x))

# normalized levenstein distance between x and y
# weights correspond to deletion, insertion, match and replacement
normdist <- function(x,y) {
  sdists(x,y, weight=c(1,1,0,1))[,]/max(nchar(x),nchar(y))
}

normdist.vec <- function(x,y){
# This is a convenience wrapper for vectorizing normdist()
  sapply(x, normdist, y, simplify = TRUE, USE.NAMES = FALSE)
}

meandist_motion <- function(m1, m2) {
# distance between two meanings with continous motion

  # penalty for mismatched shape
  (m1$Shape != m2$Shape) + 
    # standardized, directionless difference in angle note that this may not
    # translate perfectly to other programming languages depending on how they
    # handle the modulus of negative numbers
    pmin( (m1$Angle - m2$Angle) %% 360,
          (m2$Angle - m1$Angle) %% 360 ) / 180
}


#levenstein distances between all pairs of words in a given list
# weights correspond to deletion, insertion, match and replacement
normdist <- function(x,y) {
  sdists(x,y, weight=c(1,1,0,1))[,]/max(nchar(x),nchar(y))
}
allpairslev <- function(words) {
  l <- length(words)
  unlist(sapply(1:(l-1),function(x) sapply((x+1):l,function(y) normdist(words[x],words[y]))))
}
# modify function to return mean Levenshtein distance
allpairslev_mean <- function(words) {
  l <- length(words)
  pairwise_distances <- unlist(sapply(1:(l-1),function(x) sapply((x+1):l,function(y) normdist(words[x],words[y]))))
  return(mean(pairwise_distances))
}


#levenstein distances between all pairs of words from rounds n and n-1 
allpairslev_rounds <- function(itemwords,l1) {
if (l1==0) return(NA) else
  l <- length(itemwords)
  unlist(sapply(1:l1,function(x) sapply((l1+1):l,function(y) normdist(itemwords[x],itemwords[y]))))
}

#semantic distances between all pairs of meanings (without same item)
allpairshamm <- function(ID,meanings) {
  l <-length(meanings)/2  # number of semantic dimensions
  unlist(sapply(1:(l-1),function(x) sapply((x+1):l,function(y)  if (ID[x]!=ID[y]) meandist_motion(meanings[,x],meanings[,y]))))
}

#levenstein distances between all pairs of words (without same item)
allpairslev_diff <- function(ID, words) {
  l <- length(words)
  unlist(sapply(1:(l-1),function(x) sapply((x+1):l,function(y) if (ID[x]!=ID[y]) normdist(words[x],words[y]))))
}

# levenstein distances between a word and all rest in one list (input variability)
allpairslev_var2 <- function(words) {
   l <- length(words)
   if (l>0) {
     words <- na.omit(words)
      sapply(1:l, function(x) sapply(1:l, function(y) if (x!=y) {normdist(words[x],words[y])} else {NA}))
   } else {NA}
}

# minimum Levenshtein distance between a word and a list of words
lev_word_listword <- function(ListWords, MyWord) {
   l <- length(ListWords)
   if (l>0) {
     ListWords <- na.omit(ListWords)
      sapply(1:l, function(x) if (x!=MyWord) {normdist(MyWord,ListWords[x])} else {NA})
   } else {NA}
}

#the structure calculation: calculate the correlation between meaning distances and word distances in a participant's languages
correlation_test <- function(ID,meanings,words) {
  hamms <- allpairshamm(ID, meanings)
  hamms <- hamms[hamms!=0]
  levs <- allpairslev_diff(ID,words)
  veridical <- cor(hamms,levs,use="complete.obs")
  
  return(list(veridical=veridical))
}

# add grey rectangles in plots (from Round 1 to Round 9)
add_grey_rect_1_9 <- function(myplot){
  myplot <- myplot +
    geom_rect(color="grey90", fill="grey90",alpha=0.1, aes(xmin=0.6,xmax=1.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey80",fill="grey80",alpha=0.1, aes(xmin=1.6,xmax=2.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey70",fill="grey70",alpha=0.1, aes(xmin=2.6,xmax=3.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey90",fill="grey90",alpha=0.1, aes(xmin=3.6,xmax=4.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey80",fill="grey80",alpha=0.1, aes(xmin=4.6,xmax=5.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey70",fill="grey70",alpha=0.1, aes(xmin=5.6,xmax=6.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey90",fill="grey90",alpha=0.1, aes(xmin=6.6,xmax=7.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey80",fill="grey80",alpha=0.1, aes(xmin=7.6,xmax=8.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey70",fill="grey70",alpha=0.1, aes(xmin=8.6,xmax=9.6,ymin=-Inf, ymax=Inf)) 
    #scale_x_discrete(breaks = c(1:9))
  return(myplot)
}

# add grey rectangles in plots (from Round 0 to Round 10)
add_grey_rect_0_10 <- function(myplot){
  myplot <- myplot +
    geom_rect(color="white", fill="white",alpha=0.1, aes(xmin=-0.6,xmax=0.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey90", fill="grey90",alpha=0.1, aes(xmin=0.6,xmax=1.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey80",fill="grey80",alpha=0.1, aes(xmin=1.6,xmax=2.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey70",fill="grey70",alpha=0.1, aes(xmin=2.6,xmax=3.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey90",fill="grey90",alpha=0.1, aes(xmin=3.6,xmax=4.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey80",fill="grey80",alpha=0.1, aes(xmin=4.6,xmax=5.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey70",fill="grey70",alpha=0.1, aes(xmin=5.6,xmax=6.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey90",fill="grey90",alpha=0.1, aes(xmin=6.6,xmax=7.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey80",fill="grey80",alpha=0.1, aes(xmin=7.6,xmax=8.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="grey70",fill="grey70",alpha=0.1, aes(xmin=8.6,xmax=9.6,ymin=-Inf, ymax=Inf)) +
    geom_rect(color="white", fill="white",alpha=0.1, aes(xmin=9.6,xmax=10.6,ymin=-Inf, ymax=Inf)) 
    #scale_x_continuous(breaks = c(0:10))
  return(myplot)
}

# Create summary of data
data_summary <- function(x) {
   m <- mean(x)
   ymin <- m-se(x)
   ymax <- m+se(x)
   return(c(y=m,ymin=ymin,ymax=ymax))
}

# Compute the measure for adaptibility (method 3)
compute_adapt3 <- function(goodword, latest_it, listen, produce){
  # when the latest word was the "good" word
  if (latest_it == goodword & listen == goodword & produce == goodword){
    adapt3 = 0
  }
  if (latest_it == goodword & listen == goodword & produce != goodword){
    adapt3 = -1
  }
  if (latest_it == goodword & listen != goodword & produce == goodword){
    adapt3 = -0.5
  }
  if (latest_it == goodword & listen != goodword & produce == listen){
    adapt3 = 1.5
  }
  if (latest_it == goodword & listen != goodword & produce != listen & produce != goodword){
    adapt3 = -0.5
  }
  # when the latest word was *not* the "good" word
  if (latest_it != goodword & listen == goodword & produce == goodword){
    adapt3 = 1
  }
  if (latest_it != goodword & listen == goodword & produce != goodword){
    adapt3 = -1.5
  }
  if (latest_it != goodword & listen != latest_it & produce == goodword){
    adapt3 = 0
  }
  if (latest_it != goodword & listen != latest_it & produce == latest_it){
    adapt3 = 0
  }
  if (latest_it != goodword & listen != latest_it & produce != latest_it & produce != goodword){
    adapt3 = -0.5
  }
  
  if (latest_it != goodword & (listen != goodword & listen != latest_it) & produce == goodword){
    adapt3 = 0
  }
  if (latest_it != goodword & (listen != goodword & listen != latest_it) & produce == latest_it){
    adapt3 = -1
  }
  if (latest_it != goodword & (listen != goodword & listen != latest_it) & produce == listen){
    adapt3 = 1
  }
    if (latest_it != goodword & (listen != goodword & listen != latest_it) & (produce != listen & produce != goodword & produce != latest_it)){
    adapt3 = -0.5
    }
  return(adapt3)
}


compute_adapt4<- function(latest_it, listen, produce){
  d1 <- normdist(produce, listen)
  d2 <- normdist(produce, latest_it)
  adapt4 = 2*(1-d1) + d2
  return(adapt4)
}
```

```{r}
#| echo: false
#| message: false
#| warning: false

# --- READ FILES for DATA--- #

# enter path file
pathfiles = "C:/Users/Mathilde JOSSERAND/Documents/ExpCommunityVariation/InputFiles/Data/"

# list all files in the folder
lfiles = list.files(path=pathfiles, pattern=NULL, all.files=FALSE,full.names=FALSE)

# read these files, add a short/long column and an ID column, and bind
df = data.frame(matrix(ncol=24, nrow=0))

for (fil in lfiles){
    # read file
    d <- read.csv(paste(pathfiles,  fil, sep=""), header=T, sep=";")
    # bind to other dataframe
    df <- rbind(df, d)
}

df <- df%>%
  mutate(GroupType = case_when(GroupType == "HT" ~ "Hetero",
                               GroupType == "HM" ~ "Control")) %>%
  mutate(Shape = case_when(Shape == 0 ~ "nusa",
                           Shape == 1 ~ "nus",
                           Shape == 2 ~ "kesip",
                           Shape == 3 ~ "esip",
                           Shape == 4 ~ "puak",
                           Shape == 5 ~ "nekuki",
                           Shape == 6 ~ "anap",
                           Shape == 7 ~ "aike")) %>%
  mutate(Round = ifelse(TypeTest=="final_testing", 10, Round)) %>%
  mutate(TypeTest = case_when(TypeTest == "testing_set" ~ "FirstTesting",
                              TypeTest == "final_testing" ~ "SecondTesting",
                              TypeTest == "ComGame_Guesser" ~ "ComGame",
                              TypeTest == "block1_passive_exp" ~ "PassiveExposure",
                              TypeTest == "block2_passive_exp" ~ "PassiveExposure")) %>%
  mutate(GroupID = paste(GroupNum, GroupType, sep="_")) %>%
  dplyr::rename(Producer = PartID,
         Guesser = Partner) %>%
  mutate(Producer = as.factor(Producer),
        Guesser = as.factor(Guesser),
         pair = as.factor(pair),
         GroupNum = as.factor(GroupNum),
         TypeTest = as.factor(TypeTest),
         Shape = as.factor(Shape),
         GroupType = as.factor(GroupType),
         GroupID = as.factor(GroupID)) %>%
  dplyr::select(-c(ChosenItem, KeyPressed, PositionItem)) 


# --- CREATE DISTANCE TO LABEL COLUMN --- #

# create a column with distance with init label
# use loop because impossible to run directly
df$ProducSim <- NA
for (row in c(1:nrow(df))){
  df$ProducSim[row] <- 1 - normdist(df$Word[row], as.character(df$Shape[row]))
}


## CREATE DISTANCE TO LABEL COLUMN ADAPTED TO BIASED (we do not keep this method as it is too biased..)

# LIST_ALPHABET <- c("s", "p", "n", "i", "e", "u", "")
# 
# # When 2 characters to change
# list_aike <- c()
# list_nekuki <- c()
# list_puak <- c()
# list_anap <- c()
# 
# for (l1 in LIST_ALPHABET){
#   for (l2 in LIST_ALPHABET){
#     # aike
#     new_aike <- gsub("a", l1, "aike")
#     new_aike <- gsub("k", l2, new_aike)
#     list_aike <- c(list_aike, new_aike)
#     # nekuki
#     new_nekuki <- gsub("a", l1, "nekuki")
#     new_nekuki <- gsub("k", l2, new_nekuki)
#     list_nekuki <- c(list_nekuki, new_nekuki)
#     # puak
#     new_puak <- gsub("a", l1, "puak")
#     new_puak <- gsub("k", l2, new_puak)
#     list_puak <- c(list_puak, new_puak)
#     # anap
#     new_anap <- gsub("a", l1, "anap")
#     new_anap <- gsub("k", l2, new_anap)
#     list_anap <- c(list_anap, new_anap)
#   }
# }
# # When 1 character to change
# list_kesip <- c()
# list_nusa <- c()
# for (l1 in LIST_ALPHABET){
#     # kesip
#     new_kesip <- gsub("a", l1, "kesip")
#     list_kesip <- c(list_kesip, new_kesip)
#     # nusa
#     new_nusa <- gsub("a", l1, "nusa")
#     list_nusa <- c(list_nusa, new_nusa)
# }
# 
# for (row in c(1:nrow(df))){
#   if ((df$GroupType[row] =="Control") | (df$Producer[row] != 1) | (df$Producer[row]==1 & df$Shape[row]=="esip") | (df$Producer[row] ==1 & df$Shape[row]=="nus")) {
#     df$ProducSim[row] <- df$DistInitLabel[row]
#   }
#   else if (df$Shape[row]=="aike"){
#     df$ProducSim[row] <-  min(lev_word_listword(list_aike, df$Word[row]))
#   }
#   else if (df$Shape[row]=="anap"){
#     df$ProducSim[row] <-  min(lev_word_listword(list_anap, df$Word[row]))
#   }
#   else if (df$Shape[row]=="nekuki"){
#     df$ProducSim[row] <-  min(lev_word_listword(list_nekuki, df$Word[row]))
#   }
#   else if (df$Shape[row]=="puak"){
#     df$ProducSim[row] <-  min(lev_word_listword(list_puak, df$Word[row]))
#   }
#   else if (df$Shape[row]=="nusa"){
#     df$ProducSim[row] <-  min(lev_word_listword(list_nusa, df$Word[row]))
#   }
#   else if (df$Shape[row]=="kesip"){
#     df$ProducSim[row] <-  min(lev_word_listword(list_kesip, df$Word[row]))
#   }
# }

### We also tried a manual coding, based on a previous algorithm, but we don't keep it either
## indeed, it was less biased than the previous method but still quite biased
## this data was available in a folder called "Data_processed"

# for (row in c(1:nrow(df))){
#   if ( !(df$GroupType[row] == "Hetero" & df$Producer[row] == 1 & df$Shape[row] !="nus" & df$Shape[row] != "esip") ){
#     df$distance[row] <- 1 - as.numeric(normdist(df$Word[row], as.character(df$Shape[row])))
#   } else {
#     df$distance[row] <- 1 - as.numeric(df$distance[row])
#   }
# }
# df <- df %>% 
#   dplyr::rename(ProducSim = distance) %>%
#   mutate(ProducSim = replace_na(ProducSim, 1))



# --- READ FILES for OTHER--- #

# enter path file
pathfiles = "C:/Users/Mathilde JOSSERAND/Documents/ExpCommunityVariation/InputFiles/Other/"

# list all files in the folder
lfiles_other = list.files(path=pathfiles, pattern=NULL, all.files=FALSE,full.names=FALSE)

# read these files, add a short/long column and an ID column, and bind
df_other = data.frame(matrix(ncol=24, nrow=0))

for (fil in lfiles_other){
    # read file
    d_other <- read.csv(paste(pathfiles,  fil, sep=""), header=T, sep=",")
    if (grepl( "M", fil, fixed = TRUE)){
      d_other$GroupType = "Control"
    } else {
      d_other$GroupType = "Hetero"
    }
    # bind to other dataframe
    df_other <- rbind(df_other, d_other)
}

# little problem: sometimes they read F as FALSE instead of just F
df_other$Gender[df_other$Gender=="FALSE"] <- "F"

df_other <- df_other %>%
  dplyr::rename(WorkingMem = invefi,
         DictatorGame = Game,
         CogFlexibility = diff_norm)
```

# Method

This section provides additional information concerning the Method. For the general design, please refer to the main text.

**If you want to replicate the experiment, you will find the code for the experiment and also a file (`How to conduct the experiment.docx`) explaining steps by step how to proceed in the folder `Program_Experiment` in my github [ANONYMOUS-TO-REPLACE].**

## Participants

`r nrow(df_other)` participants participated in this study (`r nrow(df_other[df_other$Gender=="F",])` women and `r nrow(df_other[df_other$Gender=="M",])` men). They were between the ages of 18 and 50 (M= `r round(mean(df_other$Age))`, SD=`r round(sd(df_other$Age))` ). Please refer to [Predictors] to see more about the distribution of age, gender, and other measures.

## Setup

The setup is composed of four tables (labeled "A," "B," "C," and "D"), each hosting a computer. Tables "A" and "C" are facing each other, and tables "B" and "D" too. Curtains are placed between the pair of table AC and BD to prevent the pairs of individuals sitting at one block of table from observing those at another. Stickers are affixed to the computer keyboards to indicate which keys participants can press. Following each round, two out of the four participants switch tables, taking their computers with them. The designated table to which they need to go is specified both in the computer program and on a piece of paper attached to the computer. The laptops are placed on a rotating device, which makes it easier for the participant to rotate their screen. When they arrived to the room, the first thing they do is to read and sign the consent form. Participants were paid 21 euros for their participation.

![**Illustration 1.** The experimental design. Participants were sitting face to face on the chairs.](Pictures/Photo_Design.jpg){alt="Illustration 2. Visual representation of the procedure. Please note that there also two more tables. See below for more information."}

## Stimuli

Stimuli were squares of size 300\*300 pixel when being presented the 8 together, and 400\*400 pixel the rest of the time.

## Procedure

Here are presented the instructions for each part.

-   **Passive exposure:** Dadelijk zie je een aantal afbeeldingen een voor een op het scherm verschijnen samen met het woord in fantasietaal dat die afbeelding beschrijft. Probeer zo goed mogelijk het juiste woord bij elke afbeelding te onthouden.

-   **First Testing (Round 0):** Nu is het tijd om te testen hoe goed je de fantasietaal onthoudt! U ziet dezelfde afbeeldingen. Denk goed na over hoe je ze een naam zou geven en druk op enter als je klaar bent om te typen (tijdens het typen kun je de scene niet meer zien). Maak je geen zorgen als je de naam van de afbeelding niet meer weet en beproef je geluk door een woord te typen.

-   **Communication game, Guesser:** Je partner heeft een afbeelding gezien en een woord getypt om het te beschrijven. Lees het woord op de computer van je partner en kies de juiste afbeelding uit de 8 mogelijke afbeeldingen (gebruik 1-2-3-4-5-6-7-8 op het toetsenbord om een keuze te maken). Je krijgt feedback over je keuze, probeer er van te leren. Maak tijdens het experiment zo min mogelijk fouten! Vergeet niet om de feedback aan je partner te laten zien. Je krijgt feedback over je keuze, probeer daarvan te leren

-   **Communication game, Producer:** Nu krijg je een afbeelding te zien. Denk na over hoe je het zou noemen en druk op Enter als je klaar bent om te typen. Als je klaar bent met het schrijven van het woord, druk je nogmaals op enter en draai je de computer zodat je partner het woord kan lezen en kan raden welke afbeelding je beschrijft. Tijdens deze taak mag je de taal niet wijzigen naar Nederlands of andere bestaande talen. Gebruik ook niets dat heel erg op het Nederlands of andere talen lijkt. Ook mag je geen Nederlandse afkortingen, afkortingen of acroniemen gebruiken. Let op, je kunt niet alle letters gebruiken: alleen de letters die zichtbaar zijn op het toetsenbord kunnen worden gebruikt.

-   **Testing (Round 10):** Nu hoef je niet meer met je partner te communiceren. U moet een reeks afbeeldingen een naam geven in de nieuwe taal die u gebruikte.

## Measures

All measures are described within the results.

## Additional tasks

The study included three additional tasks.

### Prosociality scale.

This questionnaire consists of 16 items that measure different aspects of prosocial behavior such as empathic concern, altruism, and volunteering using a 5-point Likert scale ranging from 1 (never) to 5 (very often).

**English version:**

The following statements describe a large number of common situations. There are no right or wrong answers; the best answer is the immediate, spontaneous one. Read each phrase carefully and fill in the number that reflects your first reaction.

The possible answers were: *Never/Almost Never*,*Rarely*,*Occasionally*,*Often*,*Always/Almost Always*

-   I am pleased to help my friends/colleagues in their activities
-   I share the things that I have with my friends
-   I try to help others.
-   I am available for volunteer activities to help those who are in need
-   I am empathic with those who are in need
-   I help immediately those who are in need
-   I do what I can to help others avoid getting into trouble.
-   I intensely feel what others feel
-   I am willing to make my knowledge and abilities available to others
-   I try to console those who are sad
-   I easily lend money or other things
-   I easily put myself in the shoes of those who are in discomfort
-   I try to be close to and take care of those who are in need
-   I easily share with friends any good opportunity that comes to me
-   I spend time with those friends who feel lonely
-   I immediately sense my friends' discomfort even when it is not directly communicated to me

This was translated into Dutch from English.

**Dutch version**:

De volgende uitspraken beschrijven een groot aantal veelvoorkomende situaties. Er zijn geen goede of foute antwoorden; het beste antwoord is het onmiddellijke, spontane antwoord. Lees elke zin aandachtig en vul het nummer in dat uw eerste reactie weergeeft. Vergeet niet dat deze gegevens volledig anoniem zijn. Gebruik 1-2-3-4-5 op het toetsenbord om een keuze te maken.

*Nooit/bijna nooit*, *Zelden*, *Af en toe*, *Vaak*, *Altijd/bijna altijd*

-   Ik help graag mijn vrienden/collega's bij hun activiteiten.
-   Ik deel de dingen die ik heb met mijn vrienden.
-   Ik probeer anderen te helpen.
-   Ik ben beschikbaar voor vrijwilligersactiviteiten om mensen in nood te helpen.
-   Ik ben empathisch voor degenen die in nood zijn.
-   Ik help onmiddellijk degenen die in nood zijn.
-   Ik doe wat ik kan om anderen te helpen voorkomen dat ze in de problemen komen.
-   Ik voel intens wat anderen voelen
-   Ik ben bereid mijn kennis en vaardigheden beschikbaar te stellen aan anderen.
-   Ik probeer degenen die verdrietig zijn te troosten.
-   Ik leen gemakkelijk geld of andere dingen uit.
-   Ik plaats mezelf gemakkelijk in de schoenen van degenen die zich ongemakkelijk voelen.
-   Ik probeer dichtbij te zijn en te zorgen voor degenen die in nood zijn
-   Ik deel gemakkelijk elke goede kans die ik krijg met vrienden.
-   Ik breng tijd door met die vrienden die zich eenzaam voelen
-   Ik voel het ongemak van mijn vrienden onmiddellijk, zelfs als het niet rechtstreeks aan mij wordt meegedeeld.

### Dictator Game

This version of the Dictator Game is adapted in the context of the experiment. We included this task as another way to measure prosociality. Participants were presented with the following fictional situation:

**English version**:

Imagine that I give you an additional amount of 100 euros due to the excellent performance of your group during this experiment. Now, you have the choice to keep the full amount for yourself or to share it with the other participants. Since the other participants are not aware of this extra reward, the choice is entirely up to you. How much do you decide to share with the other participants?

They had the choice between:

-   keeping everything for them (1)
-   sharing but keeping more for them (2)
-   equally splitting (3)
-   sharing but keeping less (4)
-   giving everything (5)

**Dutch version**:

Stel je voor dat ik je een extra bedrag van 100 euro geef vanwege de uitstekende prestaties van jouw groep tijdens dit experiment. Nu heb je de keuze om het volledige bedrag voor jezelf te houden, of het te delen met de andere deelnemers. Aangezien de andere deelnemers niet op de hoogte zijn van deze extra beloning, is de keuze geheel aan jou. Hoeveel besluit je te delen met de andere deelnemers?

-   (1): 0 euro (Ik houd alle 100 euro)
-   (2): Tussen 0 en 75 euro (Ik deel, maar houd meer voor mezelf)
-   (3): 75 euro (25 euro voor iedereen)
-   (4): Tussen 75 en 100 euro (Ik houd minder dan hen)
-   (5): 100 euro (Ik geef alles weg)

### Task-switching experiment

The task-switching experiment adapted from Roger and Monsell's paradigm. An online version is available to try at this address: <https://www.psytoolkit.org/experiment-library/taskswitching.html>

The code of the task-switching experiment and the prosociality experiment are all available in the same file as for the code of the main experiment (see my github [mathjoss/ExpCommunityVariation](https://github.com/mathjoss/ExpCommunityVariation)).

![**Illustration 2.** Instructions for the task-switching experiment as presented to the participant. The front line shows the "letter task" (press Q for consonants and P for vowels) and the bottom line shows the instructions for the "number task" (press Q for odd numbers and P for even numbers). The participant is first trained only with the first row (the combination of letter/number alternatively switch from the left to the right), then with the number task only in the bottom. After, the participant performed both conditions (letter task and number task) at the same time (the combination of letter number/number successively switch from up left, to up right, to bottom right, to bottom left.)](Pictures/InstructionsTask.PNG){width="527"}

# Data

## Terminology & typographic conventions

Throughout the results, we will use the following terminology:

-   **Group**: when using the terminology "for each group", I will mean for each group of 4 that came to the lab. In the R data, we used several variables: *GroupNum* refers to the number of the group (e.g, 1, 2, 3, 4, 5, 6, 7), *GroupType* refers to the type of the group (control versus homogenous), and *GroupID* is the combination of the two (1_Control, 2_Control..., 1_Hetero.., 7_Hetero). When saying "for each group", I implicitely imply "for each GroupID".

-   **Initial labels** refers to the 8 initial words used to describe aliens presented in the passive exposure phase (aike, nusa, ...)

-   **Unbiased participants** are participants 2, 3, and 4 (who can produce all letters) and **biased participant** refers to participant 1 (who cannot produce a and k). This is consistent across all groups.

-   **Unbiased letters** designate letters who can be produced by all participants (p, s, n, e, i, u) and **biased letters** designate the 2 letters that cannot be produced by the biased participants (k, a)

Typographic conventions:

- *variable names* is represented using *italic text*

- **emphasis** is represented using **bold text**

- `software`, `programming concepts`, or `files/folders'` name (e.g., applications, packages or function names) are represented using `fixed font text`

## Read files

We proceed and clean the files using the following methods:

After each group passation, we use `CleanUpFiles.R` (see folder `InputFiles` of my github folder [ANONYMOUS]) to perform the following steps:

1.  **Data.** merge the dataset obtained from the 4 participants into 1 single file using the R script

2.  **Prosociality**. For each participant, we compute the total prosociality score by additionning the results on each question

3.  **Inverse efficiency.** For each participant, we compute the inverse efficiency, where inverse efficiency is defined as $mean(time)/mean(accuracy)$

4.  **Cognitive Flexibility.** We measure each participant's cognitive flexibility by examining their performance in a task that involves both numbers and letters. To do this, we calculate two average times: one for when the participant does not switch tasks (moving between letters or numbers) and another for when they do switch tasks (moving from numbers to letters or vice versa). The difference between these two averages represents their cognitive flexibility. We further normalize this difference by dividing it by the mean time required for task switching.

The "***data***" files are named after the group number and type, and it is saved as a .csv file. For instance, Group1HT.csv represents the data file for Group 1 Heterogenous.

The "***other***" measures (prosociality, inverse efficiency, cognitive flexibility) are summarized in a separate data file starting with `Other_Groupâ€¦,` which includes the group number and type. This file also contains information about **age**, **gender**, and results in the **dictator game**.

We merge datasets from all groups, thus obtaining two datasets:

-   the dataset with ***data*** from all groups:

```{r}
#| echo: false
#| message: false
#| warning: false
summary(df)
```

-   the dataset with ***other*** information from all groups:

```{r}
#| echo: false
#| message: false
#| warning: false
summary(df_other)
```

## Raw outputs

We look at the productions during the *FirstTesting* and the last testing (called here *SecondTesting*). As a reminder, FirstTesting occurs after the passive exposure, and SecondTesting occurs after the communication game.

### Heterogenous groups

**Group 1**:

*Before* training:

```{r}
#| echo: false 
#| message: false 
#| warning: false  

# print for each group
df %>%     
  filter(TypeTest == "FirstTesting" & GroupNum == 1 & GroupType == "Hetero") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> first_name    
colnames(first_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")  

df %>%     
  filter(TypeTest == "SecondTesting" & GroupNum == 1 & GroupType == "Hetero") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> last_name
colnames(last_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")      

kable(first_name)   


```

*After training*:

```{r}
#| echo: false 
#| message: false 
#| warning: false

kable(last_name) 
```

**Group 2**:

*Before* training:

```{r}
#| echo: false 
#| message: false 
#| warning: false  

# print for each group
df %>%     
  filter(TypeTest == "FirstTesting" & GroupNum == 2 & GroupType == "Hetero") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> first_name    
colnames(first_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")  

df %>%     
  filter(TypeTest == "SecondTesting" & GroupNum == 2 & GroupType == "Hetero") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> last_name
colnames(last_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")      

kable(first_name)   


```

*After training*:

```{r}
#| echo: false 
#| message: false 
#| warning: false

kable(last_name) 
```

**Group 3**:

*Before* training:

```{r}
#| echo: false 
#| message: false 
#| warning: false  

# print for each group
df %>%     
  filter(TypeTest == "FirstTesting" & GroupNum == 3 & GroupType == "Hetero") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> first_name    
colnames(first_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")  

df %>%     
  filter(TypeTest == "SecondTesting" & GroupNum == 3 & GroupType == "Hetero") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> last_name
colnames(last_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")      

kable(first_name)   


```

*After training*:

```{r}
#| echo: false 
#| message: false 
#| warning: false

kable(last_name) 
```

**Group 4**:

*Before* training:

```{r}
#| echo: false 
#| message: false 
#| warning: false  

# print for each group
df %>%     
  filter(TypeTest == "FirstTesting" & GroupNum == 4 & GroupType == "Hetero") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> first_name    
colnames(first_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")  

df %>%     
  filter(TypeTest == "SecondTesting" & GroupNum == 4 & GroupType == "Hetero") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> last_name
colnames(last_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")      

kable(first_name)   


```

*After training*:

```{r}
#| echo: false 
#| message: false 
#| warning: false

kable(last_name) 
```

**Group 5**:

*Before* training:

```{r}
#| echo: false 
#| message: false 
#| warning: false  

# print for each group
df %>%     
  filter(TypeTest == "FirstTesting" & GroupNum == 5 & GroupType == "Hetero") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> first_name    
colnames(first_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")  

df %>%     
  filter(TypeTest == "SecondTesting" & GroupNum == 5 & GroupType == "Hetero") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> last_name
colnames(last_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")      

kable(first_name)   


```

*After training*:

```{r}
#| echo: false 
#| message: false 
#| warning: false

kable(last_name) 
```

**Group 6**:

*Before* training:

```{r}
#| echo: false 
#| message: false 
#| warning: false  

# print for each group
df %>%     
  filter(TypeTest == "FirstTesting" & GroupNum == 6 & GroupType == "Hetero") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> first_name    
colnames(first_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")  

df %>%     
  filter(TypeTest == "SecondTesting" & GroupNum == 6 & GroupType == "Hetero") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> last_name
colnames(last_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")      

kable(first_name)   


```

*After training*:

```{r}
#| echo: false 
#| message: false 
#| warning: false

kable(last_name) 
```

**Group 7**:

*Before* training:

```{r}
#| echo: false 
#| message: false 
#| warning: false  

# print for each group
df %>%     
  filter(TypeTest == "FirstTesting" & GroupNum == 7 & GroupType == "Hetero") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> first_name    
colnames(first_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")  

df %>%     
  filter(TypeTest == "SecondTesting" & GroupNum == 7 & GroupType == "Hetero") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> last_name
colnames(last_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")      

kable(first_name)   


```

*After training*:

```{r}
#| echo: false 
#| message: false 
#| warning: false

kable(last_name) 
```

### Control groups

**Group 1**:

*Before* training:

```{r}
#| echo: false 
#| message: false 
#| warning: false  

# print for each group
df %>%     
  filter(TypeTest == "FirstTesting" & GroupNum == 1 & GroupType == "Control") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> first_name    
colnames(first_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")  

df %>%     
  filter(TypeTest == "SecondTesting" & GroupNum == 1 & GroupType == "Control") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> last_name
colnames(last_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")      

kable(first_name)   


```

*After training*:

```{r}
#| echo: false 
#| message: false 
#| warning: false

kable(last_name) 
```

**Group 2**:

*Before* training:

```{r}
#| echo: false 
#| message: false 
#| warning: false  

# print for each group
df %>%     
  filter(TypeTest == "FirstTesting" & GroupNum == 2 & GroupType == "Control") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> first_name    
colnames(first_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")  

df %>%     
  filter(TypeTest == "SecondTesting" & GroupNum == 2 & GroupType == "Control") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> last_name
colnames(last_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")      

kable(first_name)   


```

*After training*:

```{r}
#| echo: false 
#| message: false 
#| warning: false

kable(last_name) 
```

**Group 3**:

*Before* training:

```{r}
#| echo: false 
#| message: false 
#| warning: false  

# print for each group
df %>%     
  filter(TypeTest == "FirstTesting" & GroupNum == 3 & GroupType == "Control") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> first_name    
colnames(first_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")  

df %>%     
  filter(TypeTest == "SecondTesting" & GroupNum == 3 & GroupType == "Control") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> last_name
colnames(last_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")      

kable(first_name)   


```

*After training*:

```{r}
#| echo: false 
#| message: false 
#| warning: false

kable(last_name) 
```

**Group 4**:

*Before* training:

```{r}
#| echo: false 
#| message: false 
#| warning: false  

# print for each group
df %>%     
  filter(TypeTest == "FirstTesting" & GroupNum == 4 & GroupType == "Control") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> first_name    
colnames(first_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")  

df %>%     
  filter(TypeTest == "SecondTesting" & GroupNum == 4 & GroupType == "Control") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> last_name
colnames(last_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")      

kable(first_name)   


```

*After training*:

```{r}
#| echo: false 
#| message: false 
#| warning: false

kable(last_name) 
```

**Group 5**:

*Before* training:

```{r}
#| echo: false 
#| message: false 
#| warning: false  

# print for each group
df %>%     
  filter(TypeTest == "FirstTesting" & GroupNum == 5 & GroupType == "Control") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> first_name    
colnames(first_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")  

df %>%     
  filter(TypeTest == "SecondTesting" & GroupNum == 5 & GroupType == "Control") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> last_name
colnames(last_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")      

kable(first_name)   


```

*After training*:

```{r}
#| echo: false 
#| message: false 
#| warning: false

kable(last_name) 
```

**Group 6**:

*Before* training:

```{r}
#| echo: false 
#| message: false 
#| warning: false  

# print for each group
df %>%     
  filter(TypeTest == "FirstTesting" & GroupNum == 6 & GroupType == "Control") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> first_name    
colnames(first_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")  

df %>%     
  filter(TypeTest == "SecondTesting" & GroupNum == 6 & GroupType == "Control") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> last_name
colnames(last_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")      

kable(first_name)   


```

*After training*:

```{r}
#| echo: false 
#| message: false 
#| warning: false

kable(last_name) 
```

**Group 7**:

*Before* training:

```{r}
#| echo: false 
#| message: false 
#| warning: false  

# print for each group
df %>%     
  filter(TypeTest == "FirstTesting" & GroupNum == 7 & GroupType == "Control") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> first_name    
colnames(first_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")  

df %>%     
  filter(TypeTest == "SecondTesting" & GroupNum == 7 & GroupType == "Control") %>%     
  dplyr::select(Producer, Word, Shape) %>%     
  spread(Shape, Word) -> last_name
colnames(last_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")      

kable(first_name)   


```

*After training*:

```{r}
#| echo: false 
#| message: false 
#| warning: false

kable(last_name) 
```

# Results

## 0 - Understanding the results

### Learning Accuracy

Here, we examine how well the participants remembered the initial labels for the images, looking at the labels written by the participants during the *FirstTesting*.

Accuracy is **binary**: a value of 1 indicates correct recall by the participant, while a value of 0 signifies the presence of at least one error. However, we made an exception for the biased participant. In their case, their responses were considered "correct" if they substituted the biased letter they were unable to produce with another letter, or if they omitted it. Please note that for the biased participant in the heterogeneous groups, we **manually** coded the accuracy, only for the pre-communication (round 0) testing moment. Indeed, we only look at this measure in this context.

```{r }
#| echo: false
#| message: false
#| warning: false
#| fig-cap: "Learning accuracy per participant ID. Dots shape indicate the group number"
#| fig-alt: ""
#| fig-width: 8
#| fig-height: 5

# # summarize accuracy only first testing by PartID, GroupNum, and GroupType
# df_agg <- df %>%
#   filter(TypeTest == "FirstTesting" ) %>%
#   dplyr::group_by(Producer, GroupNum, GroupType) %>%
#   dplyr::summarize(mean_acc = mean(ACC)*100) %>% # to get a percentage
#   mutate(Producer = ifelse(as.character(Producer) == "1", "1 (biased)", as.character(Producer))) # for better visualisation
# 
# # plot obtained data
# ggplot(df_agg, aes(x=Producer, y=mean_acc, color=Producer, group=Producer, shape=GroupNum)) +
#   geom_boxplot(data=df_agg, aes(x=Producer, y=mean_acc, fill=Producer), alpha=0.2, width=0.2, color="grey") +
#   geom_jitter(size=3, width=0.1) +
#   ylim(0,100) +
#   labs(y="Accuracy (%)", x="Participant ID", color="Participant") +
#   scale_color_viridis_d() +
#   scale_fill_viridis_d() +
#   guides(color=FALSE, fill=FALSE) +
#   facet_grid(GroupType ~ .) 
  
```

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: yy
#| fig-cap: Same as above, except that here results are aggregated per participant."
#| fig-alt: ""
#| fig-width: 8
#| fig-height: 5
 
# df %>%
#   filter(TypeTest == "FirstTesting" ) %>%
#   dplyr::group_by(GroupNum, GroupType) %>%
#   dplyr::summarize(mean_acc = mean(ACC)*100) -> df_agg
# 
# ggplot(df_agg, aes(x=GroupType, y=mean_acc, color=GroupType, group=GroupType, shape=GroupNum)) +
#   geom_boxplot(data=df_agg, aes(x=GroupType, y=mean_acc, fill=GroupType), alpha=0.2, width=0.2, color="grey") +
#   geom_jitter(size=3, width=0.1) +
#   ylim(0,100) +
#   labs(y="Accuracy (%)", x="Group type") +
#   guides(color="none", fill="none") 
  
```

### Initial production similarity

Participants were presented with the following **initial labels** during the passive exposure phase: kesip, esip, nusa, nus, aike, puak, nekuki, and anap. Our analysis focuses on the differences between participants' first productions (during FirstTesting) and the initial labels. To do this, we computed the normalized Levenshtein distance between the initial labels and the initial productions. Please note that we tried to find a way to compute an exception for the biased participant, in a similar way as we did for the learning accuracy. However, we could not find a solution that would not "advantage" or "disandvantage" the biased participant. Thus, when plotting the results from the initial production similarity, we removed the biased participant, in order to have two sets of data which are comparable.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-learning
#| fig-cap: "Learning success (accuracy on the left, initial production similarity on the right) per group type. Dots indicate each participant. The red dot shows the mean of the group, and red point range shows the standard error."
#| fig-width: 10
#| fig-height: 5

# compute learning accuracy
df_agg_acc <- df %>%
  filter(TypeTest == "FirstTesting" ) %>%
  dplyr::group_by(Producer, GroupNum, GroupType) %>%
  dplyr::summarize(mean_acc = mean(ACC)*100) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))


# compute distance to initial labels
# df_agg_dist <- df %>%
#   filter(TypeTest == "FirstTesting") %>%
#   mutate(Shape = as.character(Shape)) %>%
#   mutate(lev_dis = stringdist(Word, Shape, method = "lv")/max(str_count(Word), str_count(Shape)))  %>%
#   mutate(GroupType2 = ifelse(GroupType == "Control", "Control", ifelse(Producer == 1, "Hetero_biased", "Hetero_unbiased"))) %>%
#   dplyr::group_by(Producer, GroupNum, GroupType2) %>%
#   dplyr::summarize(mean_lev_dis = mean(lev_dis)) 
# df_agg_dist <- df %>%
#   filter(TypeTest == "FirstTesting") %>%
#   mutate(Shape = as.character(Shape)) %>%
#   mutate(GroupType2 = ifelse(GroupType == "Control", "Control", ifelse(Producer == 1, "Hetero_biased", "Hetero_unbiased"))) %>%
#   dplyr::group_by(Producer, GroupNum, GroupType2) %>%
#   dplyr::summarize(mean_lev_dis = mean(DistInitLabel)) 

df_agg_dist2 <- df %>%
  filter(TypeTest == "FirstTesting",
         !(Producer == 1 & GroupType=="Hetero")) %>%
  dplyr::group_by(Producer, GroupNum, GroupType) %>%
  dplyr::summarize(mean_lev_dis = mean(ProducSim))  %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))


# plot accuracy learning
p1 <- ggplot(df_agg_acc, aes(x=GroupType, y=mean_acc)) +
  geom_violin(data=df_agg_acc, aes(x=GroupType, y=mean_acc, fill=GroupType), alpha=0.2, width=0.2, color="grey") +
  geom_jitter(size=2, width=0.1, alpha=0.4) +
  ylim(0,100) +
  labs(y="Accuracy learn (%)", x="Group type") +
  guides(color="none", fill="none") +
  stat_summary(fun.data=data_summary, color="red")  +
  scale_x_discrete(guide = guide_axis(n.dodge = 2)) 

# # plot distance to initial labels
# p2 <- ggplot(df_agg_dist, aes(x=GroupType2, y=mean_lev_dis)) +
#   geom_violin(data=df_agg_dist, aes(x=GroupType2, y=mean_lev_dis, fill=GroupType2), alpha=0.2, width=0.2, color="grey") +
#   geom_jitter(size=2, width=0.1, alpha=0.4) +
#   labs(y="Init produc sim", x="Group type") +
#   guides(color="none", fill="none") +
#   stat_summary(fun.data=data_summary, color="red") +
#   scale_x_discrete(guide = guide_axis(n.dodge = 2)) 

# plot distance to initial labels
p3 <- ggplot(df_agg_dist2, aes(x=GroupType, y=mean_lev_dis)) +
  geom_violin(data=df_agg_dist2, aes(x=GroupType, y=mean_lev_dis, fill=GroupType), alpha=0.2, width=0.2, color="grey") +
  geom_jitter(size=2, width=0.1, alpha=0.4) +
  labs(y="Init produc sim", x="Group type") +
  guides(color="none", fill="none") +
  stat_summary(fun.data=data_summary, color="red") +
  scale_x_discrete(guide = guide_axis(n.dodge = 2)) 

# arrange both plots in one
grid.arrange(p1,p3, ncol=2)

```

We check whether the difference of learning is statistically different. This is not an hypothesis, just a sanity check that our two group types are similar.

With **accuracy learning**:

```{r}
#| echo: false
#| message: false
#| warning: false

# linear mixed effect model with learning accuracy
model_acc <- lmer(mean_acc ~ GroupType + (1 | GroupID), data=df_agg_acc)
summary(model_acc)

```

With **initial production similarity**: (please note that here, we look at a model that include all productions from the control groups, but only production from participant 2, 3, and 4 in the heterogenous groups, since the biased compared cannot be directly compared to them).

```{r}
#| echo: false
#| message: false
#| warning: false

# remove biased participant
df_agg_dist2 <- df %>%
  filter(TypeTest == "FirstTesting",
         !(Producer == 1 & GroupType=="Hetero")) %>%
  dplyr::group_by(Producer, GroupNum, GroupType) %>%
  dplyr::summarize(mean_lev_dis = mean(ProducSim))  %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))


# linear mixed effect model with distance to initial labels
model_dist <- lmer(mean_lev_dis ~ GroupType + (1 | GroupID), data=df_agg_dist2)
summary(model_dist)
```

-\> The learning difference between the two groups is not significant

Looking at each shape:

```{r }
#| echo: false
#| message: false
#| warning: false
#| label: fig-learning-shape
#| fig-cap: "Levenshtein distance between initial words and initial productions for each word. Blue dots show biased participants."
#| fig-width: 12
#| fig-height: 6

# compute accuracy learning for each shape
df_agg_acc <- df %>%
  filter(TypeTest == "FirstTesting") %>%
  dplyr::group_by(GroupType, Shape) %>%
  dplyr::summarize(mean_acc = mean(ACC)*100,
                   se_acc = se(ACC)*100)

# compute production similarity for each shape
df_agg_dist <- df %>%
  filter(TypeTest == "FirstTesting",
         !(Producer == 1 & GroupType=="Hetero")) %>%
  dplyr::group_by(GroupType, Shape) %>%
  dplyr::summarize(mean_lev_dis = mean(ProducSim),
                   se_lev_dis = se(ProducSim))


# plot accuracy learning for each shape
p1 <- ggplot(df_agg_acc, aes(x=Shape, y=mean_acc, color=GroupType)) +
  geom_pointrange(data=df_agg_acc, mapping=aes(x=Shape, y=mean_acc, color=GroupType, ymin=mean_acc-se_acc, ymax=mean_acc+se_acc), position=position_dodge(0.3)) + 
  labs(y="Accuracy learning (in %)", x="", color="") +
  theme(legend.position="bottom") +
  scale_x_discrete(guide = guide_axis(n.dodge = 2))

# plot distance initial label for each shape
p2 <- ggplot(df_agg_dist, aes(x=Shape, y=mean_lev_dis, color=GroupType)) +
  geom_pointrange(data=df_agg_dist, mapping=aes(x=Shape, y=mean_lev_dis, color=GroupType, ymin=mean_lev_dis-se_lev_dis, ymax=mean_lev_dis+se_lev_dis), position=position_dodge(0.3)) + 
  labs(y="Init produc similarity", x="", color="") +
  theme(legend.position="bottom") +
  scale_x_discrete(guide = guide_axis(n.dodge = 2))

# arrange both plots in one
ggarrange(p1, p2, ncol=2, labels="AUTO", common.legend = TRUE, legend="bottom", font.label = list(size = 16, color = "black"))
```

### Participants' characteristics

```{r}
#| echo: false 
#| message: false 
#| warning: false  
#| label: fig-part-charact
#| fig-cap: "Distribution of the scores. Red shows the results for the control group, blue shows the results for the heterogenous group."
#| fig-width: 10 
#| fig-height: 6  

# Learning accuracy
df_learn <- df %>%
  filter(TypeTest == "FirstTesting" ) %>%
  group_by(Producer, GroupNum, GroupType) %>%
  summarize(AccLearning = mean(ACC)) %>%
  dplyr::select(Producer, GroupNum, AccLearning, GroupType) %>%
  dplyr::rename(PartID = Producer)  

# Distance with initial word
df_dist <- df %>%
  filter(TypeTest == "FirstTesting") %>%
  mutate(Shape = as.character(Shape)) %>%
  dplyr::group_by(Producer, GroupNum, GroupType) %>%
  dplyr::summarize(ProducSim = mean(ProducSim))  %>%
  dplyr::select(Producer, GroupNum, ProducSim, GroupType) %>%
  dplyr::rename(PartID = Producer)  
  
## merge with previous data
df_other <- merge(df_other, df_learn, by=c("PartID", "GroupNum", "GroupType"))
df_other <- merge(df_other, df_dist, by=c("PartID", "GroupNum", "GroupType"))

p1 <- ggplot(df_other, aes(x=prosoc, fill=GroupType)) +   
  geom_density(alpha=0.5) +   
  guides(fill=FALSE) 

p2 <- ggplot(df_other, aes(x=WorkingMem, fill=GroupType)) +   
  geom_density(alpha=0.5) +   
  guides(fill=FALSE) 

p3 <- ggplot(df_other, aes(x=CogFlexibility, fill=GroupType)) +   
  geom_density(alpha=0.5) +   
  guides(fill=FALSE) 

p4 <- ggplot(df_other, aes(x=DictatorGame, fill=GroupType)) +   
  geom_histogram(stat="count", position = position_dodge()) +   
  guides(fill=FALSE) 

p5 <- ggplot(df_other, aes(x=Age, fill=GroupType)) +   
  geom_density(alpha=0.5) +   
  guides(fill=FALSE) 

p6 <- ggplot(df_other, aes(x=Gender, fill=GroupType)) +   
  geom_histogram(stat="count", position = position_dodge()) +   
  guides(fill=FALSE) 

p7 <- ggplot(df_other, aes(x=AccLearning, fill=GroupType)) +   
  geom_density(alpha=0.5) +   
  guides(fill=FALSE) 

p8 <- ggplot(df_other, aes(x=ProducSim, fill=GroupType)) +   
  geom_density(alpha=0.5) 

ggarrange(p1, p2, p3, p4, p5, p6, p7, p8, ncol=4, nrow=2, labels="AUTO", common.legend = TRUE, legend="bottom", font.label = list(size = 16, color = "black"))

#grid.arrange(p1, p2, p3, p4, p5, p6, p7, p8, ncol=4, nrow=2)
```

```{r}

mod_prosoc <- t.test(df_other$prosoc[df_other$GroupType=="Hetero"], df_other$prosoc[df_other$GroupType=="Control"])
mod_wm <- t.test(df_other$WorkingMem[df_other$GroupType=="Hetero"], df_other$WorkingMem[df_other$GroupType=="Control"])
mod_cf <- t.test(df_other$CogFlexibility[df_other$GroupType=="Hetero"], df_other$CogFlexibility[df_other$GroupType=="Control"])
mod_dg <- t.test(df_other$DictatorGame[df_other$GroupType=="Hetero"], df_other$DictatorGame[df_other$GroupType=="Control"])

mod_age <- t.test(df_other$Age[df_other$GroupType=="Hetero"], df_other$Age[df_other$GroupType=="Control"])
mod_sex <- chisq.test(table(df_other$Gender, df_other$GroupType))
mod_acc <- t.test(df_other$AccLearning[df_other$GroupType=="Hetero"], df_other$AccLearning[df_other$GroupType=="Control"])
mod_dist <- t.test(df_other$ProducSim[df_other$GroupType=="Hetero"], df_other$ProducSim[df_other$GroupType=="Control"])
mod_dist2 <- t.test(df_other$ProducSim[df_other$GroupType=="Hetero" & df_other$PartID!=1], df_other$ProducSim[df_other$GroupType=="Control" & df_other$PartID!=1])

```

When building t-tests comparing each of these characteristics for the groups, we obtain the following p-values (please note that we used a chisq test for gender):

-   For prosociality: `r round(mod_prosoc$p.value,2)`
-   For working memory: `r round(mod_wm$p.value,2)`
-   For cognitive flexibility: `r round(mod_cf$p.value,2)`
-   For dictator game: `r round(mod_dg$p.value,2)`
-   For age: `r round(mod_age$p.value,2)`
-   For gender: `r round(mod_sex$p.value,2)`
-   For accuracy learning: `r round(mod_acc$p.value,2)`
-   For distance to initial words: `r round(mod_dist$p.value,2)`

None of these values are significant, except for the distance to initial words. This can be easily explained given that the method we used to measure the initial production similarities is different for biased and unbiased participants. Thus, if we remove the biased participants, this p-value is not-significant anymore: `r round(mod_dist2$p.value,2)`.

### Strategy

In this part, we only look at the patterns observed in the **heterogenous groups**.

What are the strategies used by the biased participant to produce the initial labels before communicating? In this table, we count the number of times each biased participant has performed:

-   *removal* means that the biased participant remembered the label, and decided to remove the biased letter

-   *switch* means that the biased participant remembered the label, and decided to switch the biased letter with another unbiased letter

-   *forgot* means that the biased participant has forgot the initial label

```{r}
strat_init_biased = data.frame(removal=c(0,0,4,5,5,0,0), 
                               forgot=c(1,0,2,1,1,4,6), 
                               switch=c(5,6,0,0,0,2,0)) 

rownames(strat_init_biased) = c("Group1", "Group2", "Group3", "Group4", "Group5", "Group6","Group7") 

kable(strat_init_biased)
```

Please note that these tables were filled manually.

Then, we also look at the pattern presented by the biased participant after communicating. How did this biased participant produce the label? Did this participant:

-   *removal*: used the initial label, but removed the biased letter

-   *switch*: used the initial label, but switched the biased letter with another unbiased letter (please note that in the case of "nekuki" label, we consider as "switch" things like "nepupi" or "nepipi"; it is not exactly the same word so it should be considered in the "new" column, but we think that the strategy is actually a switch (+ a weak forgot))

-   *new*: adopted a new label

-   *special*: here to condition where the participant has removed the biased letter, but has also added a letter at the end of the word. Then, the word was identifiable by the other members of the groups by the addition of this final letter (for example, esipp, and other participants produced esippp, sesss, sessss).

```{r}

strat_end_biased = data.frame(removal=c(0,0,5,0,3,1,0), 
                              new=c(1,6,0,2,1,3,4), 
                              switch=c(5,0,1,4,1,2,2), 
                              special=c(0,0,0,0,1,0,0)) 

rownames(strat_end_biased) = c("Group1", "Group2", "Group3", "Group4", "Group5", "Group6", "Group7") 

kable(strat_end_biased)
```

These tables concerned only the biased participants. We can also look at the productions of the unbiased participants after they communicated (during the final testing) to look at their adaptative strategy. Please note that we only look here at the labels featuring one or two biased letters (all labels but nus and esip). Here are the following possible options:

-   *SameBiased_Removed*: used the same label as the biased participant, in the case where the biased participant has removed a biased letter

-   *SameBiased_Removed*: used the same label as the biased participant, in the case where the biased participant has switched a biased letter with another unbiased letter

-   *SameBiased_New*: used the same label as the biased participant, in the case where the biased participant has created a new label

-   *InitialLabel*: used the initial label, even if the biased participant cannot use it the same way

-   *DiffBiased_Adapt*: use a different label from the biased participant, however this new label does not feature biased letter

-   *DiffBiased_ABitAdapt*: use a different label from the biased participant, this new label features slightly less biased letters than the original label (namely, instead of 2 biased letters, there is only one biased letter)

-   *DiffBiased_NonAdapt*: use a different label from the biased participant and from the initial label, featuring biased letters

```{r}
strat_adapt = data.frame(SameBiased_Removed=c(0,0,0,0,3,0,0), 
                         SameBiased_Switch=c(0,0,0,1,0,0,0), 
                         SameBiased_New=c(0,0,0,0,0,0,0), 
                         InitialLabel=c(2,14,10,7,3,11,6), 
                         DiffBiased_Adapt=c(2,0,2,4,7,0,6), 
                         DiffBiased_ABitAdapt=c(5,3,3,2,2,2,2), 
                         DiffBiased_NonAdapt = c(9,2,3,4,3,5,4)) 

rownames(strat_adapt) = c("Group1", "Group2", "Group3", "Group4", "Group5", "Group6","Group7") 
kable(strat_adapt) 
```

When adapating, there are three main types of strategy used by the unbiased participants to adapt to the biased participants:

-   either they use the same word as the biased participant (it has happened `r sum(strat_adapt$SameBiased_Removed) + sum(strat_adapt$SameBiased_Switch) +sum(strat_adapt$SameBiased_New)` times out of the 6 words containing a biased letter and the `r 3*nrow(strat_adapt)` unbiased participants -\> total of `r 6*(3*nrow(strat_adapt))` occurences).

-   either they use a new label, not used by the biased participants, but that does not feature any biased letters: `r sum(strat_adapt$DiffBiased_Adapt)` or that does feature less biased letters than the original label: `r sum(strat_adapt$DiffBiased_ABitAdapt)`

If they do not adapt, either by using the initial label that contains as many biased letters as the original label (or more): `r sum(strat_adapt$DiffBiased_NonAdapt) + sum(strat_adapt$InitialLabel)`

### Summary results

-   learning performance (both using accuracy index and distance to initial learning) are similar between control and heterogenous groups

-   some words are easier to remember compared to other (such as *aike* or *nus*)

-   the participant characteristics are similar between control and heterogenous groups (in average, they have approximately the same age, but also personal characteristics such as working memory, cognitive flexibility...)

-   in order to compensate for their difference, biased participants either remove the biased letter(s) or switch them to another letter. After communicating, they also come up with new words

-   unbiased participants adapt mostly by using another label which does not feature any biased letter (or less frequently), and sometimes they adapt by copying the label used by the biased participant

## 1 - How did language evolve in the heterogeneous groups?

In this part, we will find the plots and the models that are referred in the main paper as:

-   model 1 and model 1 bis, in the part [Communicative success]
-   model 2 and model 2 bis, in the part [Convergence]
-   model 3 and model 3 bis, in the part [Evolution of production similarity]

### Communicative success

Here, we examine the level of communicative success in interactions, specifically distinguishing between successful (success=1) and unsuccessful (success= 0) interaction in pairs. Please note that the variables Round2 here is the reverse order of Round (so that Round 9 becomes Round 0).

We look at the evolution of communicative success for each group:

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-comsucess-time-groups
#| fig-cap: "Evolution of communicative success for each group."
#| fig-width: 9
#| fig-height: 7

# aggregated accuracy by group number and group type, and Round
df %>%
  filter(TypeTest == "ComGame") %>%
  group_by(Round, GroupNum, GroupType) %>%
  summarize(mean_acc = mean(ACC, na.rm=TRUE)*100) -> df_agg

# Plot       
p <- ggplot(df_agg, aes(x=Round, y=mean_acc, color=GroupNum, group=GroupNum))+ geom_point() 
p <- add_grey_rect_1_9(p)
p <- p + geom_hline(yintercept = 50, linetype="dashed") +
  geom_point(size=5, position=position_dodge(width=0.5)) +
  geom_line(size=1, position=position_dodge(width=0.5)) +
  facet_grid(GroupType ~ .) +
  ylim(0,105) +
  labs(y="Mean com success (%)", fill="Group") +
  scale_x_continuous(breaks = c(0:10)) +
  scale_color_viridis_d()
p
```

We can see that the communicative success of group 2 in the heterogeneous group is particularly high.

Let's look at the aggregated performance for each group type:

```{r }
#| echo: false  
#| message: false  
#| warning: false 
#| label: fig-comsucess-time-agg 
#| fig-cap: "Evolution of communicative success aggregated by group type: control or heterogenous." 
#| fig-width: 8 
#| fig-height: 5   

# aggregate data
df %>%      
  filter(TypeTest == "ComGame") %>%      
  group_by(Round, GroupType) %>%      
  summarize(mean_acc = mean(ACC, na.rm=TRUE)*100,
            se_acc = se(ACC)*100) -> df_agg    

# Plot         
p <- ggplot(df_agg, aes(x=Round, y=mean_acc, color=GroupType, group=GroupType))+   geom_point()   
p <- add_grey_rect_1_9(p)  
p <- p + geom_hline(yintercept = 50, linetype="dashed") +      
  geom_point(size=5) +     
  geom_line(size=1) +      
  ylim(0,105) +      
  labs(y="Mean com success (%)", fill="Group") +       
  scale_x_continuous(breaks = c(0:10))  +
  geom_pointrange(aes(ymin=mean_acc-se_acc, ymax=mean_acc+se_acc), lwd=1, size=0.5, alpha=0.8) 

p
```

These plots raise two questions:

-   Is there a significant **improvement** of communicative success with time?

-   Is there a significant **difference** of communicative success between heterogeneous and control groups?

To investigate these questions, we build a *linear mixed-effect models* using the group type (hetero versus control) and the round as fixed effect. We use the aggregated data by pair, and we control for the random effect of Group Number.

**Model 1**:

```{r}
#| echo: false
#| message: false
#| warning: false

# aggregate data
df_agg <- df %>%
  filter(TypeTest == "ComGame") %>%
  group_by(Round, GroupNum, GroupType, pair) %>%
  summarize(mean_acc = mean(ACC, na.rm=TRUE)*100) %>%
  mutate(Round2 = ifelse(Round == 9, 0, ifelse(Round==8, 1, ifelse(Round==7, 2, ifelse(Round==6, 3, ifelse(Round==5, 4, ifelse(Round==4, 5, ifelse(Round==3, 6, ifelse(Round==2, 7, ifelse(Round==1, 8)))))))))) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))

# model
model <- lmer(mean_acc ~ GroupType * Round2 + (1  | GroupID), data = df_agg)
summary(model)

# print diagnostic plots
plots <- plot_model(model, type = "diag", show.ci = FALSE)
plots <- lapply(plots, function(p) p + theme(text = element_text(size = 12)))
ggarrange(plots[[1]], plots[[2]], plots[[3]], plots[[4]], nrow = 2, ncol = 2)
```

There is a significant improvement in performance with time in both group type (control and heterogenous), as shown by the main effect of the Round2 variable. A **lower performance is observed in the heterogenous groups** than in the control group, as shown by the main effect of the GroupType variable depsite the very high performance reached by heterogenous Group 2. Moreover, no interaction effect between group type and round is present.

From this analysis, it is clear that the average communicative success is lower in heterogeneous groups compared to control groups. However, it could be due to the fact that heterogeneous groups include interactions with a biased participants. Thus, it is interesting to split the heterogeneous groups into two categories:

-   **Hetero_biased** (pairs in the heterogeneous groups involving the biased participant: 1-2, 1-3, 1-4)

-   **Hetero_nonbiased** (pairs in the heterogeneous groups that do ***not*** involve the biased participant: 2-3, 2-4, 3-4).

This could lead to two different scenarios:

1.  Hetero_nonbiased has high communicative success similarly to control groups, because these pairs do not include the biased participants ;

2.  The confusion introduced by the biased participant spread to all participants, and the performance of hetero_unbiased is still lower than for control groups.

```{r }
#| echo: false 
#| message: false 
#| warning: false 
#| label: fig-comsucess-split-hetero
#| fig-cap: "Same as above, except that here we split heterogenous groups in 2: pairs including the biased participant and pairs without the biased participant."
#| fig-width: 6
#| fig-height: 6 

# aggregate data
df_agg <- df %>%   
  filter(TypeTest == "ComGame") %>%   
  mutate(type = ifelse( GroupType == "Control", "Control", ifelse(Producer == 1 | Guesser == 1, "Hetero With Biased", "Hetero Without Biased"))) %>%   
  group_by(Round, GroupType, type) %>%   
  summarize(mean_acc = mean(ACC, na.rm=TRUE)*100,
            se_acc = se(ACC)*100) %>%   
  mutate(Round = as.factor(Round),          
         type = as.factor(type))    

# Plot        
p_comsuccess <- ggplot(df_agg, aes(x=Round, y=mean_acc, color=type, group=type))+ 
  geom_point() 
p_comsuccess <- add_grey_rect_1_9(p_comsuccess) 
p_comsuccess <- p_comsuccess + 
  #geom_hline(yintercept = 50, linetype="dashed") +   
  #geom_point(size=5, position=position_dodge(width=0.5)) +   
  geom_line(size=1) +   
  geom_pointrange(aes(ymin=mean_acc-se_acc, ymax=mean_acc+se_acc), lwd=1.2, size=1.1) +
  scale_color_viridis_d(end=0.8) +
  ylim(0,105) +   
  labs(y="Communicative success", fill="", color="")   +
  theme(legend.position="bottom") 
p_comsuccess 
```

The plot suggests that **hypothesis 2 is supported**: the presence of the biased participant has introduced confusion within the heterogeneous group, leading to a decrease in the communicative success even in interactions between unbiased participants. However, in general, the pair with the biased individual seems to achieve an even lower accuracy score (in the heterogenous group). We used a mixed-effect model to see if this is statistically significant (this refers to the **model 1 bis** of the main paper:)

```{r}
#| echo: false
#| message: false
#| warning: false

df_agg <- df %>%   
  filter(TypeTest == "ComGame") %>%   
  mutate(type = ifelse( GroupType == "Control", "Control", ifelse(Producer == 1 | Guesser == 1, "Hetero With Biased", "Hetero Without Biased"))) %>%   
  group_by(Round, GroupType, type, GroupNum, pair) %>%   
  summarize(mean_acc = mean(ACC, na.rm=TRUE)*100) %>%
  mutate(Round2 = ifelse(Round == 9, 0, ifelse(Round==8, 1, ifelse(Round==7, 2, ifelse(Round==6, 3, ifelse(Round==5, 4, ifelse(Round==4, 5, ifelse(Round==3, 6, ifelse(Round==2, 7, ifelse(Round==1, 8))))))))))   %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))

# print summary model
model <- lmer(mean_acc ~ type*Round2 + (1 | GroupID), data=df_agg)
summary(model)

# print diagnostic plots
plots <- plot_model(model, type = "diag", show.ci = FALSE)
plots <- lapply(plots, function(p) p + theme(text = element_text(size = 12)))
ggarrange(plots[[1]], plots[[2]], plots[[3]], plots[[4]], nrow = 2, ncol = 2)
```

```{r}
#| echo: false
#| message: false
#| warning: false
# 
# df_agg <- df %>%   
#   filter(TypeTest == "ComGame",
#          GroupType == "Hetero") %>%   
#   mutate(type = ifelse(Producer == 1 | Guesser == 1, "Hetero_biased", "Hetero_nonbiased")) %>%   
#   group_by(Round, GroupNum, GroupType, type) %>%   
#   summarize(mean_acc = mean(ACC, na.rm=TRUE)*100) %>%   
#   filter(Round == 1) 
# 
# t.test(df_agg$mean_acc[df_agg$type == "Hetero_biased"], df_agg$mean_acc[df_agg$type == "Hetero_nonbiased"])
```

```{r }
#| echo: false
#| message: false
#| warning: false
#| label: fig-comsucess-other-plot
#| fig-cap: "Evolution of communicative success with Round and per pair. Dots color indicate which participant is in which pair. It is important to note that we excluded group number 1 from the heterogenous group from this plot (Please refer to the method section for further details.)"
#| fig-width: 10
#| fig-height: 7

# # Aggregate by Round, pair, and GroupType
# # Then perform some operations for better plotting
# df %>%
#   filter(TypeTest == "ComGame") %>%
#   dplyr::group_by(Round, pair, GroupType) %>%
#   dplyr::summarize(mean_acc = mean(ACC, na.rm=TRUE)*100) %>%
#   mutate(pair = as.factor(pair)) %>%
#   mutate(pair2 = pair) %>%
#   separate(pair2, c("parta", "partb"), "_") %>%
#   gather(condition, Participant, parta, partb) %>%
#   dplyr::select(-condition) %>%
#   mutate(Participant = as.character(Participant),
#            Round = as.factor(Round))  %>%
#   mutate(Participant = ifelse(Participant == "1", "1 (biased)",Participant)) -> df_agg
# 
# # create plot
# p <- ggplot(df_agg, aes(x=Round, y=mean_acc, fill=Participant)) + geom_point()  
# p <- add_grey_rect_1_9(p) # add grey background rectangles
# p <- p + geom_hline(yintercept = 50, linetype="dashed") + # add dashed line
#   geom_dotplot(binaxis = "y", stackdir = "centerwhole", stackgroups = TRUE, binpositions = "all", binwidth = 5) + # add dots
#   facet_grid(GroupType ~ .) + # add GroupType condition
#   labs(y="Mean com success (%)") + # rename labs
#   ylim(-5,105)  # change y limits
# 
# # print plot
# p


```

Let's just compare the pairs with the biased participant to the pairs without. Note that pairs with the biased participants are considered to be the pairs involving participant 1 even in the control groups. This allows us to check that there is no difference between these "sham" biased pairs and the other pairs in the control groups.

```{r )}
#| echo: false
#| message: false
#| warning: false
#| label: fig-nn
#| fig-cap: "Communicate, comparing pairs with biased participants (1-3, 1-2, 1-4) and pairs without biased participants (2-3, 2-4, 3-4)."
#| fig-width: 10
#| fig-height: 7
#| 
# df %>%
#   filter(TypeTest == "ComGame") %>%
#   mutate(have_biased = ifelse(grepl( "1", pair, fixed = TRUE), "yes", "no")) %>%
#   group_by(have_biased, GroupNum, GroupType) %>%
#   summarize(mean_acc = mean(ACC, na.rm=TRUE)*100) -> df_agg
# 
#         
# ggplot(df_agg, aes(x=have_biased, y=mean_acc, fill=have_biased))+
#   geom_violin(alpha=0.3, width=0.3) +
#   geom_boxplot(width=0.05, alpha=0.8, fill="white") +
#   geom_jitter(width=0.1, size=2)+
#   labs(y="Mean accuracy (%)", x="Pair with biased participant?") +
#   guides(fill=FALSE) +
#   facet_grid(GroupType ~ .) +
#   ylim(0,100)
#   

```

```{r }
#| echo: false
#| message: false
#| warning: false
#| label: fig-comsuccess-pointrange
#| fig-cap: "Mean communicative success for each group, whether unbiased communicate with biased participant (part 1) or unbiased participant (part 2, 3, 4) Bars show standard error."
#| fig-width: 8
#| fig-height: 5

# aggregate data
df_agg <- df %>%
  mutate(ACC=ACC*100) %>%
  filter(TypeTest == "ComGame" ) %>%
  mutate(have_biased = ifelse(grepl( "1", pair, fixed = TRUE), "yes", "no"))  %>%
  dplyr::group_by(pair, GroupType, GroupNum, have_biased, Round) %>%
  dplyr::summarize(mean_acc = mean(ACC, na.rm=TRUE))  %>%
  dplyr::group_by(have_biased, GroupType) %>%
  dplyr::summarize(mean_acc2 = mean(mean_acc, na.rm=TRUE), 
            se_acc = se(mean_acc)) 

# plot
ggplot(df_agg, aes(x=have_biased, y=mean_acc2, group=GroupType, color=GroupType)) +
  geom_line()+
  geom_pointrange(aes(ymin=mean_acc2-se_acc, ymax=mean_acc2+se_acc)) +
  labs(y="Mean com success (%)", x="Pair with biased participant?") 

```

```{r}
#| echo: false
#| message: false
#| warning: false

# aggregate data
df_agg <- df %>%
  mutate(ACC=ACC*100) %>%
  filter(TypeTest == "ComGame" ) %>%
  mutate(have_biased = ifelse(grepl( "1", pair, fixed = TRUE), "yes", "no"))  %>%
  dplyr::group_by(pair, GroupType, GroupNum, have_biased, Round) %>%
  dplyr::summarize(mean_acc = mean(ACC, na.rm=TRUE)) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))

# model
model <- lmer(mean_acc ~ GroupType * have_biased  + (1 | GroupID), data=df_agg)
summary(model)

# print diagnostic plots
plots <- plot_model(model, type = "diag", show.ci = FALSE)
plots <- lapply(plots, function(p) p + theme(text = element_text(size = 12)))
ggarrange(plots[[1]], plots[[2]], plots[[3]], plots[[4]], nrow = 2, ncol = 2)

```

**Summary results:**

-   Communicative success improves with time (for both groups)

-   Communicative success is higher in control groups

-   In heterogeneous groups, communicative success is higher in pairs that do not contain the biased individuals. However, the communicative of this type of pairs is still lower than the one in control groups, which suggests that introducing a biased participant has spread some confusion in the whole group.

### Convergence

In this part, we look at the convergence between all words produced in a round. As a reminder, each round, each participant produce one word for each label. So each round, there are 4 word productions for each labels : convergence will be high if these words are similar (such as *kesip*, *kesup*, *kesip* and *kesip*) but convergence will be low if these words are very different from each other (for example, *kesip*, *onup*, *asip* and *keku*).

Convergence is computed the following way:

1.  Calculate the normalized Levenshtein distance between all pairs of words within the set of four words.

2.  Find the average of these distances to obtain a single numerical value for each Round, each Shape, and each Group.

3.  Take the complement of this value, so that the measure of convergence increases when the words are more similar, rather than the opposite.

In other words, $convergence = 1 - (mean(dis(SetWords)))$ where dis(SetWords) is the pairwaise normalized Levenhstein distance between all words in SetWords.

The plot below includes the production of all participants, including the biased one:

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-evolution-convergence
#| fig-cap: "Evolution of convergence with time for each group."
#| fig-width: 10
#| fig-height: 8

# aggregate data
df_agg <- df %>%
  filter(TypeTest != "PassiveExposure")   %>%
  dplyr::group_by(GroupType, GroupNum, Shape, Round) %>%
  dplyr::summarise(lev_dist_list = 1 - mean(allpairslev(Word))) %>%
  dplyr::group_by(GroupType, GroupNum, Round) %>%
  dplyr::summarise(mean_lev_dist = mean(lev_dist_list))

# plot
p <- ggplot(df_agg, aes(x=Round, y=mean_lev_dist, color=GroupNum, group=GroupNum)) +
  geom_point()
p <- add_grey_rect_0_10(p)
p <- p + geom_point(size=5) +
  geom_line(size=1) +
  labs(y="Mean convergence per group", fill="Shape") +
  scale_x_continuous(breaks = c(0:10)) +
  facet_grid(GroupType ~ .) +
  scale_color_viridis_d()
p

```

```{r }
#| echo: false
#| message: false
#| warning: false
#| label: fig-evolution-convergence2
#| fig-cap: "Evolution of convergence with time for each group."
#| fig-width: 12
#| fig-height: 9

# df_agg_with <- df %>%
#   filter(TypeTest != "PassiveExposure")   %>%
#   dplyr::group_by(GroupType, GroupNum, Shape, Round) %>%
#   dplyr::summarise(lev_dist_list = 1 - mean(allpairslev(Word))) %>%
#   dplyr::group_by(GroupType, GroupNum, Round) %>%
#   dplyr::summarise(All = mean(lev_dist_list))
# 
# df_agg_without <- df %>%
#   filter(TypeTest != "PassiveExposure",
#          Producer != "1")   %>%
#   dplyr::group_by(GroupType, GroupNum, Shape, Round) %>%
#   dplyr::summarise(lev_dist_list = 1 - mean(allpairslev(Word))) %>%
#   dplyr::group_by(GroupType, GroupNum, Round) %>%
#   dplyr::summarise(WithoutBiased = mean(lev_dist_list))
# 
# df_agg <- merge(df_agg_with, df_agg_without, by=c("GroupType", "GroupNum", "Round"))
# df_agg <- gather(df_agg, condition, mean_lev_dist, All:WithoutBiased)
# 
# p <- ggplot(df_agg, aes(x=Round, y=mean_lev_dist, color=GroupNum, group=GroupNum)) +
#   geom_point()
# p <- add_grey_rect_0_10(p)
# p <- p + geom_point(size=5) +
#   geom_line(size=1) +
#   labs(y="Mean convergence per group", fill="Shape") +
#   scale_x_continuous(breaks = c(0:10)) +
#   facet_grid(GroupType ~ condition) +
#   scale_color_viridis_d()
# p


```

We look at the same plot aggregated by group type:

First, we look at the convergence with all participants:

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-evolution-convergence33
#| fig-cap: "Same, but aggregated by group."
#| fig-width: 6
#| fig-height: 6

# aggregate data
df_agg <- df %>%
  filter(TypeTest != "PassiveExposure")   %>%
  dplyr::group_by(GroupType, GroupNum, Shape, Round) %>%
  dplyr::summarise(lev_dist_list = 1 - mean(allpairslev(Word))) %>%
  dplyr::group_by(GroupType, Round) %>%
  dplyr::summarise(All = mean(lev_dist_list),
                   se_lev = se(lev_dist_list))

# plot
p <- ggplot(df_agg, aes(x=Round, y=All, color=GroupType, fill=GroupType)) + geom_point()
p <- add_grey_rect_0_10(p)
p <- p + geom_point(size=5) +
  geom_line(size=1) +
  #geom_smooth() +
  labs(y="Convergence", fill="", color="") +
  scale_x_continuous(breaks = c(0:10)) +
  theme(legend.position="bottom")  +
  ylim(0.3,1) +
  geom_pointrange(aes(ymin=All-se_lev, ymax=All+se_lev), lwd=1, size=0.5, alpha=0.8) 

p

```

And we look at the model comparing control and heterogenous groups. This refers to the **model 2** of the paper:

```{r}
# aggregate data
df_agg <- df %>%
  filter(TypeTest != "PassiveExposure")   %>%
  dplyr::group_by(GroupType, GroupNum, Shape, Round) %>%
  dplyr::summarise(lev_dist_list = 1 - mean(allpairslev(Word))) %>%
  dplyr::group_by(GroupType, GroupNum, Round) %>%
  dplyr::summarise(All = mean(lev_dist_list)) %>%
  mutate(Round2 = ifelse(Round == 10, 0, ifelse(Round == 9, 1, ifelse(Round==8, 2, ifelse(Round==7, 3, ifelse(Round==6, 4, ifelse(Round==5, 5, ifelse(Round==4, 6, ifelse(Round==3, 7, ifelse(Round==2, 8, ifelse(Round==1, 9, ifelse(Round==0, 10, "NA")))))))))))) %>%
  mutate(Round2 = as.numeric(Round2)) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))

# model
model <- lm(All ~ GroupType * Round2, data = df_agg)
summary(model)

# print diagnostic plots
plots <- plot_model(model, type = "diag", show.ci = FALSE)
plots <- lapply(plots, function(p) p + theme(text = element_text(size = 12)))
ggarrange(plots[[1]], plots[[2]], plots[[3]], plots[[4]], nrow = 2, ncol = 2)


```

Then, we look at:

-   "Hetero With Biased": convergence in heterogeneous groups with all participants (what was computed before; 4 data)
-   "Hetero Without Biased": convergence in heterogenous groups excluding the biased participant (3 data)
-   "Control": convergence in control groups (4 data)

```{r }
#| echo: false
#| message: false
#| warning: false
#| label: fig-evolution-convergence-agg
#| fig-cap: "Same as above, aggregated by group."
#| fig-width: 6
#| fig-height: 6

# aggregate data with the biased participant
df_agg_with <- df %>%
  filter(TypeTest != "PassiveExposure")   %>%
  dplyr::group_by(GroupType, GroupNum, Shape, Round) %>%
  dplyr::summarise(lev_dist_list = 1 - mean(allpairslev(Word))) %>%
  dplyr::group_by(GroupType, Round) %>%
  dplyr::summarise(All = mean(lev_dist_list),
                   SE_all = se(lev_dist_list))

# aggregate data without the biased participant
df_agg_without <- df %>%
  filter(TypeTest != "PassiveExposure",
         Producer != "1")   %>%
  dplyr::group_by(GroupType, GroupNum, Shape, Round) %>%
  dplyr::summarise(lev_dist_list = 1 - mean(allpairslev(Word))) %>%
  dplyr::group_by(GroupType, Round) %>%
  dplyr::summarise(WithoutBiased = mean(lev_dist_list),
                   SE_withoutBiased = se(lev_dist_list))

# merge both datasets
df_agg <- merge(df_agg_with, df_agg_without, by=c("GroupType", "Round"))
df_agg_mean <- df_agg %>% dplyr::select(-c(SE_all,SE_withoutBiased))
df_agg_mean <- gather(df_agg_mean, condition, mean_lev_dist, All:WithoutBiased)
df_agg_se <- df_agg %>% 
  dplyr::select(-c(All,WithoutBiased)) %>%
  dplyr::rename(All = SE_all,
         WithoutBiased = SE_withoutBiased)
df_agg_se <- gather(df_agg_se, condition, se_lev_dist, All:WithoutBiased)
df_agg <- merge(df_agg_mean, df_agg_se, by=c("GroupType", "Round", "condition"))

# change names
df_agg <- df_agg %>%
  filter(!(GroupType == "Control" & condition == "WithoutBiased")) %>%
  mutate(TypeGroup = ifelse(GroupType == "Control", "Control", ifelse(condition=="All", "Hetero With Biased", "Hetero Without Biased")))

# plot
p_converg <- ggplot(df_agg, aes(x=Round, y=mean_lev_dist, color=TypeGroup, group=TypeGroup)) + geom_point()
p_converg <- add_grey_rect_0_10(p_converg)
p_converg <- p_converg + geom_point(size=5) +
  geom_line(size=1) +
  #geom_smooth() +
  labs(y="Convergence", fill="", color="") +
  scale_x_continuous(breaks = c(0:10)) +
  theme(legend.position="bottom")  +
  ylim(0.3,1) +
  geom_pointrange(aes(ymin=mean_lev_dist-se_lev_dist, ymax=mean_lev_dist+se_lev_dist), lwd=1, size=0.5) +
  scale_color_viridis_d(end=0.8) 

p_converg

```

And we observe a model based on this plot, comparing control, hetero with biased, hetero without biased. This refers to the **model 2 bis** of the main paper:

```{r}

# Same steps as above
df_agg_with <- df %>%
  filter(TypeTest != "PassiveExposure")   %>%
  dplyr::group_by(GroupType, GroupNum, Shape, Round) %>%
  dplyr::summarise(lev_dist_list = 1 - mean(allpairslev(Word))) %>%
  dplyr::group_by(GroupType, Round, GroupNum) %>%
  dplyr::summarise(All = mean(lev_dist_list))
df_agg_without <- df %>%
  filter(TypeTest != "PassiveExposure",
         Producer != "1")   %>%
  dplyr::group_by(GroupType, GroupNum, Shape, Round) %>%
  dplyr::summarise(lev_dist_list = 1 - mean(allpairslev(Word))) %>%
  dplyr::group_by(GroupType, Round, GroupNum) %>%
  dplyr::summarise(WithoutBiased = mean(lev_dist_list))
df_agg <- merge(df_agg_with, df_agg_without, by=c("GroupType", "Round", "GroupNum"))
df_agg <- gather(df_agg, condition, mean_lev_dist, All:WithoutBiased)
df_agg <- df_agg %>%
  filter(!(GroupType == "Control" & condition == "WithoutBiased")) %>%
  mutate(TypeGroup = ifelse(GroupType == "Control", "Control", ifelse(condition=="All", "Hetero With Biased", "Hetero Without Biased"))) %>%
    mutate(Round2 = ifelse(Round == 10, 0, ifelse(Round == 9, 1, ifelse(Round==8, 2, ifelse(Round==7, 3, ifelse(Round==6, 4, ifelse(Round==5, 5, ifelse(Round==4, 6, ifelse(Round==3, 7, ifelse(Round==2, 8, ifelse(Round==1, 9, ifelse(Round==0, 10, "NA")))))))))))) %>%
  mutate(Round2 = as.numeric(Round2)) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))

# model
model <- lm(mean_lev_dist ~ TypeGroup*Round2, data=df_agg)
summary(model)

# print diagnostic plots
plots <- plot_model(model, type = "diag", show.ci = FALSE)
plots <- lapply(plots, function(p) p + theme(text = element_text(size = 12)))
ggarrange(plots[[1]], plots[[2]], plots[[3]], plots[[4]], nrow = 2, ncol = 2)

```

```{r }
#| echo: false
#| message: false
#| warning: false
#| label: fig-evolution-convergence-group-pair
#| fig-cap: "Evolution of convergence with time for each type of pair."
#| fig-width: 10
#| fig-height: 8

# We look at the same convergence measure for the two types of pairs: pairs including the biased participant (1 - 2, 1- 3, 1 - 4) and pairs excluding the biased participant (2 - 3, 2 - 4, 3 - 4). The plot belows shows the aggregated measure for all groups.

# df_agg <- df %>%
#   filter(TypeTest == "ComGame")   %>%
#   mutate(have_biased = ifelse(grepl( "1", pair, fixed = TRUE), "yes", "no")) %>%
#   dplyr::group_by(GroupType, GroupNum, Shape, Round, have_biased) %>%
#   dplyr::summarise(lev_dist_list = 1 - mean(allpairslev(Word))) %>%
#   dplyr::group_by(GroupType, Round, have_biased) %>%
#   dplyr::summarise(mean_lev_dist = mean(lev_dist_list))
# 
# p <- ggplot(df_agg, aes(x=Round, y=mean_lev_dist, color=have_biased, group=have_biased)) + geom_point()
# p <- add_grey_rect_1_9(p)
# p <- p + geom_point(size=5) +
#   geom_line(size=1) +
#   geom_smooth() +
#   scale_x_continuous(breaks = c(0:10))+
#   facet_grid(GroupType ~ .) +
#   labs(color="Pair with biased", y="Mean convergence per pair")
# p

```

### Evolution of production similarity

This analysis helps us gain insight into our data. We want to know if participants eventually adopt the initial labels, even if they initially didn't remember them. To find out, we calculate the average Levenshtein distance between participants' productions and the initial labels at each round.

Please note that this measure goes against the biased participant, as even if they remember the initial labels correctly, they may *not* be able to reproduce the exact initial labels.

We look at the evolution of production similarity for each shape:

```{r }
#| echo: false
#| message: false
#| warning: false
#| label: fig-evolution-ProducSim-sha
#| fig-cap: "Evolution of the production similarity at each round, for each shape. Please note that this plot does not include the productions of the biased participant."
#| fig-width: 10
#| fig-height: 8

# aggregate data
df_agg <- df %>%
  filter(TypeTest != "PassiveExposure") %>%
  mutate(Shape = as.character(Shape)) %>%
  dplyr::group_by(GroupType, Round, Shape) %>%
  dplyr::summarize(mean_lev_dis = mean(ProducSim))

# Plot
p <- ggplot(df_agg, aes(x=Round, y=mean_lev_dis, color=Shape, group=Shape)) + geom_point()
p <- add_grey_rect_0_10(p) 
p <- p + geom_point(size=5) +
  geom_line(size=1) +
  facet_grid(GroupType ~ .) +
  labs(y="Production similarity", fill="Shape") +
  scale_x_continuous(breaks = c(0:10)) +
  scale_color_viridis_d()
p
```

To see the production similarity by group:
```{r }
#| echo: false
#| message: false
#| warning: false
#| label: fig-evolution-ProducSim
#| fig-cap: "Evolution of the production similarity at each round, for each shape. Please note that this plot does not include the productions of the biased participant."
#| fig-width: 10
#| fig-height: 8

# aggregate data
df_agg <- df %>%
  filter(TypeTest != "PassiveExposure") %>%
  dplyr::group_by(GroupType, Round, GroupNum) %>%
  dplyr::summarize(mean_lev_dis = mean(ProducSim))

# Plot
p <- ggplot(df_agg, aes(x=Round, y=mean_lev_dis, color=GroupNum, group=GroupNum)) + geom_point()
p <- add_grey_rect_0_10(p) 
p <- p + geom_point(size=5) +
  geom_line(size=1) +
  facet_grid(GroupType ~ .) +
  labs(y="Production similarity", fill="GroupNum") +
  scale_x_continuous(breaks = c(0:10)) +
  scale_color_viridis_d()
p
```

We observe that **certain shapes are more effectively remembered than others**. For instance, "aike" and "nus" are often well-remembered, while "puak" tends to be frequently forgotten.

This plot also reveals that individuals in the control group often converge on the initial labels in the end, even if they initially forget it. However, in the heterogenous group, this convergence does not occur. Participants' productions tend to become slightly closer to the initial labels, but in the end, the words still remain quite different, **even for words that did not contain a biased letter** (nus and esip)!

We look at the same plot aggregated by group type. Please note that the following plot is biased, because the biased participant could not produce the exact initial labels. Below, you will find a plot that is more suited to compare control and heterogenous groups.

```{r }
#| echo: false
#| message: false
#| warning: false
#| label: fig-evolution-ProducSim-agg-group
#| fig-cap: "Same plot as above, but aggregated by shape. Please note that this plot does not include the productions of the biased participant"
#| fig-width: 9
#| fig-height: 6

# aggregate data
df_agg <- df %>%
  filter(TypeTest != "PassiveExposure") %>%
  dplyr::group_by(GroupType, Round) %>%
  dplyr::summarize(mean_lev_dis = mean(ProducSim),
                   se_lev_dis = se(ProducSim))

# Plot
p <- ggplot(df_agg, aes(x=Round, y=mean_lev_dis, color=GroupType, group=GroupType)) + geom_point()
p <- add_grey_rect_0_10(p) 
p <- p + geom_point(size=5) +
  geom_line(size=1) +
  labs(y="Production similarity", fill="Shape") +
  scale_x_continuous(breaks = c(0:10)) +
  ylim(0.5, 1) +
  geom_pointrange(aes(ymin=mean_lev_dis-se_lev_dis, ymax=mean_lev_dis+se_lev_dis), lwd=1, size=0.5, alpha=0.8) 

  
p
```

Then, we apply a model to compare the two groups, which is refered to as **model 3** in the main paper:

```{r}

# aggregate data
df_agg <- df %>%
  filter(TypeTest != "PassiveExposure") %>%
  dplyr::group_by(GroupType, Round, GroupNum, Producer) %>%
  dplyr::summarize(mean_lev_dis = mean(ProducSim)) %>%
  mutate(Round2 = ifelse(Round == 10, 0, ifelse(Round == 9, 1, ifelse(Round==8, 2, ifelse(Round==7, 3, ifelse(Round==6, 4, ifelse(Round==5, 5, ifelse(Round==4, 6, ifelse(Round==3, 7, ifelse(Round==2, 8, ifelse(Round==1, 9, ifelse(Round==0, 10)))))))))))) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))

# model
model <- lmer(mean_lev_dis ~ GroupType*Round2 + (1 | GroupID), data=df_agg)
summary(model)

# print diagnostic plots
plots <- plot_model(model, type = "diag", show.ci = FALSE)
plots <- lapply(plots, function(p) p + theme(text = element_text(size = 12)))
ggarrange(plots[[1]], plots[[2]], plots[[3]], plots[[4]], nrow = 2, ncol = 2)

```

Now, we split heterogenous condition in two: participants in heterogenous groups in pairs with (*hetero_biased*) and without (*hetero_unbiased*) the biased participant, similarly with previous plots. Is is a better measure since the data from the biased participant is artificially biased.

```{r }
#| echo: false
#| message: false
#| warning: false
#| label: fig-evolution-ProducSim-distinct
#| fig-cap: "Same plot as above, except that here, we differentiate between pairs interacting with the biased individuals, and pairs interacting without the biased individual."
#| fig-width: 6
#| fig-height: 6

# aggregate data
df_agg <- df %>%
  filter(TypeTest == "ComGame") %>%
  mutate(Condition = ifelse(GroupType == "Control", "Control", ifelse(Producer=="1", "Hetero With Biased", "Hetero Without Biased"))) %>%
  dplyr::group_by(GroupType, Round, Condition) %>%
  dplyr::summarize(mean_lev_dis = mean(ProducSim),
                   se_lev_dis = se(ProducSim))


# Plot
p_distlabel <- ggplot(df_agg, aes(x=Round, y=mean_lev_dis, color=Condition, group=Condition)) + geom_point()
p_distlabel <- add_grey_rect_1_9(p_distlabel) 
p_distlabel <- p_distlabel + geom_point(size=5) +
  geom_line(size=1) +
  labs(y="Production similarity", fill="", color="") +
  scale_x_continuous(breaks = c(1:9)) +
  theme(legend.position="bottom") +
  ylim(0.3,1) +
  geom_pointrange(aes(ymin=mean_lev_dis-se_lev_dis, ymax=mean_lev_dis+se_lev_dis), lwd=1, size=0.5) +
  scale_color_viridis_d(end=0.8) 

p_distlabel
```

We can see that as expected, due to our measure of production similarity, the performance of the biased participant was dragging the whole group to lower similarity. However, we still can find differences between the control groups and the heterogenous groups containing only unbiased participants.

Let's see if this difference is significant (**model 3 bis** in the main paper):

```{r}
# aggregate data
df_agg <- df %>%
  filter(TypeTest == "ComGame") %>%
  mutate(Condition = ifelse(GroupType == "Control", "Control", ifelse(Producer=="1", "Hetero With Biased", "Hetero Without Biased")), Shape = as.character(Shape)) %>%
  dplyr::group_by(GroupType, Round, Condition, GroupNum) %>%
  dplyr::summarize(mean_lev_dis = mean(ProducSim))  %>%
  mutate(Round2 = ifelse(Round == 10, 0, ifelse(Round == 9, 1, ifelse(Round==8, 2, ifelse(Round==7, 3, ifelse(Round==6, 4, ifelse(Round==5, 5, ifelse(Round==4, 6, ifelse(Round==3, 7, ifelse(Round==2, 8, ifelse(Round==1, 9, ifelse(Round==0, 10)))))))))))) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))

# model
model <- lmer(mean_lev_dis ~ Condition*Round2 + (1 | GroupID), data=df_agg)
summary(model)

# print diagnostic plots
plots <- plot_model(model, type = "diag", show.ci = FALSE)
plots <- lapply(plots, function(p) p + theme(text = element_text(size = 12)))
ggarrange(plots[[1]], plots[[2]], plots[[3]], plots[[4]], nrow = 2, ncol = 2)

```
### Production similarity with biased participant

Here, we look at a different index: how similar are the productions from the unbiased participants with the productions from the biased participants. 
We do this by computing the levenshtein distance between the productions from the unbiased, and the production of the biased used in this round. 

We do this for both groups, in order to check, but please note that in control groups we note "Participant 1" (who is unbiased) as the biased participant.

```{r}

# Initialize empty dataframe
df_all <- df
df_all$SimBiased <- NA
df_all <- df_all[FALSE, ]

# Loop for each round, group ID

for (gid in unique(df$GroupID)){
  
  for (myround in unique(df$Round)){
    
    # filter production from biased participant
    prodbiased <- df %>%
      filter(GroupID==gid & Round == myround & Producer == 1) %>%
      mutate(WordBiased = Word)
    
    # add this column to the rest of the participant
    produnbiased <- df %>% 
      filter(GroupID==gid & Round == myround & Producer != 1) %>%
      left_join(prodbiased %>% dplyr::select(Shape, WordBiased), by = "Shape")
    
    # rbind both dataframe
    prodall <- rbind(prodbiased, produnbiased)
    
    # compute distance to production of biased participant
    prodall$SimBiased <- NA
    for (row in c(1:nrow(prodall))){
      prodall$SimBiased[row] <- 1 - 
        normdist(prodall$Word[row], as.character(prodall$WordBiased[row]))
    }

    # add this to a big dataframe
    df_all <- rbind(df_all, prodall)
  }

}

```

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-evolution-SimBiased-distinct
#| fig-cap: "Evolution of the production similarity of unbiased participants with the biased participants. ."
#| fig-width: 6
#| fig-height: 6

# aggregate data
df_agg <- df_all %>%
  filter(TypeTest != "PassiveExposure" & !(GroupType == "Hetero" & Producer == 1 )) %>%
  dplyr::group_by(GroupType, Round, GroupNum) %>%
  dplyr::summarize(mean_SimBiased = mean(SimBiased))

# Plot
p <- ggplot(df_agg, aes(x=Round, y=mean_SimBiased, color=GroupNum, group=GroupNum)) + geom_point()
p <- add_grey_rect_0_10(p) 
p <- p + geom_point(size=5) +
  geom_line(size=1) +
  facet_grid(GroupType ~ .) +
  labs(y="Production similarity", fill="GroupNum") +
  scale_x_continuous(breaks = c(0:10)) +
  scale_color_viridis_d()
p

```


```{r}

# aggregate data
df_agg <- df_all %>%
  filter( TypeTest != "PassiveExposure" & !(GroupType == "Hetero" & Producer == 1) & Round != 0 & Round != 10) %>%
  dplyr::group_by(GroupType, Round, GroupNum) %>%
  dplyr::summarize(mean_SimBiased = mean(SimBiased))

# Plot
p <- ggplot(df_agg, aes(x=Round, y=mean_SimBiased)) + geom_point()
p <- add_grey_rect_1_9(p) 
p <- p + geom_point(size=5, color="black", alpha=0.3) +
  geom_line(data=df_agg, aes(x=Round, y=mean_SimBiased, group=GroupNum), size=1, color="black", alpha=0.3) +
  facet_grid(GroupType ~ .) +
  labs(y="Prod similarity with biased", fill="GroupNum") +
  scale_x_continuous(breaks = c(0:10)) +
  scale_color_viridis_d() +
  geom_smooth(data=df_agg, aes(x=Round, y=mean_SimBiased))
p

```

### Stability

Stability is a measure of the levenstein distances between all pairs of words from rounds n and n-1.

First, we look at the **evolution of stability for each shape**.

To better understand how the function works, let's take an example for the shape *kesip* for one group:

-   At round 7, participants produced *puise*, *kesip*, *esip*, *epi*
-   At round 8, participants produced *puie*, *suki*, *kesip*, *kesip*

Stability is computed by computing the levenshtein distance between all pairs of words (*puise* and *puie*, then *puise* and *suki*, and so on...). In this case stability between round 7 and 8 for the shape *kesip* is equal to 0.59.

Since this value assumes that the data is computed between rounds n and n-1, it is normal that the plots shows the value for stability only from round 1 to round 10.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-evolution-stability-with
#| fig-cap: "Evolution of stability with time for the group (including biased participants."
#| fig-width: 10
#| fig-height: 8

### compute stability for all (with biased)
for ( gr in unique(df$GroupID)){
  for ( myr in c(1:10)){
    for( mys in unique(df$Shape)){
      list1 <- df$Word[df$GroupID == gr & df$Round == myr & df$Shape == mys]
      list2 <- df$Word[df$GroupID == gr & df$Round == myr-1 & df$Shape == mys]
      stab <- mean(allpairslev_rounds(c(list1, list2), length(list1)), na.rm=TRUE)
      df$Stab[df$GroupID == gr & df$Round == myr & df$Shape == mys] <- 1 - stab
    }
  }
}

# aggregate (it is not very important here because the value is same for each)
df_agg <- df %>%
  filter(Round != 0) %>%
  dplyr::group_by(Round, GroupType, Shape) %>%
  dplyr::summarize(stab = mean(Stab))
  

p <- ggplot(df_agg, aes(x=Round, y=stab, color=Shape, group=Shape)) + geom_point()
p <- add_grey_rect_0_10(p)
p <- p + geom_point(size=5) +
  geom_line(size=1) +
  #geom_smooth() +
  scale_x_continuous(breaks = c(0:10))+
  facet_grid(GroupType ~ .) +
  labs(color="Pair with biased", y="Stability") +
  scale_color_viridis_d()
p

```

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-evolution-stability2
#| fig-cap: "Evolution of stability with time for the group (including biased participants."
#| fig-width: 10
#| fig-height: 8

# ### compute stability for all (with biased)
# for ( gr in unique(df$GroupID)){
#   for ( myr in c(1:10)){
#     for( mys in unique(df$Shape)){
#       list1 <- df$Word[df$GroupID == gr & df$Round == myr & df$Shape == mys]
#       list2 <- df$Word[df$GroupID == gr & df$Round == myr-1 & df$Shape == mys]
#       stab <- mean(allpairslev_rounds(c(list1, list2), length(list1)), na.rm=TRUE)
#       df$Stab[df$GroupID == gr & df$Round == myr & df$Shape == mys] <- 1 - stab
#     }
#   }
# }
# 
# # aggregate (it is not very important here because the value is same for each)
# df_agg_with <- df %>%
#   filter(Round != 0) %>%
#   dplyr::group_by(Round, GroupType, Shape) %>%
#   dplyr::summarize(All = mean(Stab))
# 
# ### compute stability for groups without biased
# df2 <- df %>%
#   filter(Producer != 1)
# 
# for ( gr in unique(df2$GroupID)){
#   for ( myr in c(1:10)){
#     for( mys in unique(df$Shape)){
#       list1 <- df2$Word[df2$GroupID == gr & df2$Round == myr & df2$Shape == mys]
#       list2 <- df2$Word[df2$GroupID == gr & df2$Round == myr-1 & df2$Shape == mys]
#       stab <- mean(allpairslev_rounds(c(list1, list2), length(list1)), na.rm=TRUE)
#       df2$Stab[df2$GroupID == gr & df2$Round == myr & df2$Shape == mys] <- 1 - stab
#     }
#   }
# }
# 
# # aggregate 
# df_agg_without <- df2 %>%
#   filter(Round != 0) %>%
#   dplyr::group_by(Round, GroupType, Shape) %>%
#   dplyr::summarize(WithoutBiased = mean(Stab))
# 
# ## merge
# df_agg <- merge(df_agg_with, df_agg_without, by=c("Round", "GroupType", "Shape"))
# df_agg <- gather(df_agg, condition, Stab, All:WithoutBiased)
# 
# p <- ggplot(df_agg, aes(x=Round, y=Stab, color=Shape, group=Shape)) + geom_point()
# p <- add_grey_rect_0_10(p)
# p <- p + geom_point(size=5) +
#   geom_line(size=1) +
#   #geom_smooth() +
#   scale_x_continuous(breaks = c(0:10))+
#   facet_grid(GroupType ~ condition) +
#   labs(color="Pair with biased", y="Stability") +
#   scale_color_viridis_d()
# p

```

We look at the same type of data, except that it is aggregated by group type, similarly as what was performed before.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-evolution-stability-without
#| fig-cap: "Evolution of stability with time for the group (excluding biased participants."
#| fig-width: 10
#| fig-height: 8

# compute stability
for ( gr in unique(df$GroupID)){
  for ( myr in c(1:10)){
    for( mys in unique(df$Shape)){
      list1 <- df$Word[df$GroupID == gr & df$Round == myr & df$Shape == mys]
      list2 <- df$Word[df$GroupID == gr & df$Round == myr-1 & df$Shape == mys]
      stab <- mean(allpairslev_rounds(c(list1, list2), length(list1)), na.rm=TRUE)
      df$Stab[df$GroupID == gr & df$Round == myr & df$Shape == mys] <- 1 - stab
    }
  }
}

# aggregate (it is not very important here because the value is same for each)
df_agg <- df %>%
  filter(Round != 0) %>%
  dplyr::group_by(Round, GroupType) %>%
  dplyr::summarize(stab = mean(Stab),
                   se_stab = se(Stab)) 

# Plot
p <- ggplot(df_agg, aes(x=Round, y=stab, color=GroupType, group=GroupType)) + geom_point()
p <- add_grey_rect_0_10(p)
p <- p + geom_point(size=5) +
  geom_line(size=1) +
  scale_x_continuous(breaks = c(0:10))+
  labs(color="Group Type", y="Stability") +
  ylim(0,1) +
  geom_pointrange(data=df_agg, aes(ymin=stab-se_stab, ymax=stab+se_stab), lwd=1, size=0.5, alpha=0.8) 
p

# Perform model
df_agg <- df %>%
  filter(Round != 0) %>%
  dplyr::group_by(Round, GroupType, GroupNum) %>%
  dplyr::summarize(stab = mean(Stab)) %>%
  mutate(Round2 = ifelse(Round == 10, 0, ifelse(Round == 9, 1, ifelse(Round==8, 2, ifelse(Round==7, 3, ifelse(Round==6, 4, ifelse(Round==5, 5, ifelse(Round==4, 6, ifelse(Round==3, 7, ifelse(Round==2, 8, ifelse(Round==1, 9, ifelse(Round==0, 10, "NA")))))))))))) %>%
  mutate(Round2 = as.numeric(Round2)) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))

summary(lmer(stab ~ GroupType*Round2 + (1 | GroupID), data=df_agg))

```

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-evolution-entropy-without-agg
#| fig-cap: "Evolution of stability aggregated with time for each type of group: everyone (all) or everyone except the biased participant (Without Biased)"
#| fig-width: 10
#| fig-height: 5

### compute stability for groups with biased
for ( gr in unique(df$GroupID)){
  for ( myr in c(1:10)){
    for( mys in unique(df$Shape)){
      list1 <- df$Word[df$GroupID == gr & df$Round == myr & df$Shape == mys]
      list2 <- df$Word[df$GroupID == gr & df$Round == myr-1 & df$Shape == mys]
      stab <- mean(allpairslev_rounds(c(list1, list2), length(list1)), na.rm=TRUE)
      df$Stab[df$GroupID == gr & df$Round == myr & df$Shape == mys] <- 1 - stab
    }
  }
}

# aggregate 
df_agg_with <- df %>%
  filter(Round != 0) %>%
  dplyr::group_by(Round, GroupType) %>%
  dplyr::summarize(All = mean(Stab))

### compute stability for groups without biased
df2 <- df %>%
  filter(Producer != 1)

for ( gr in unique(df2$GroupID)){
  for ( myr in c(1:10)){
    for( mys in unique(df2$Shape)){
      list1 <- df2$Word[df2$GroupID == gr & df2$Round == myr & df2$Shape == mys]
      list2 <- df2$Word[df2$GroupID == gr & df2$Round == myr-1 & df2$Shape == mys]
      stab <- mean(allpairslev_rounds(c(list1, list2), length(list1)), na.rm=TRUE)
      df2$Stab[df2$GroupID == gr & df2$Round == myr & df2$Shape == mys] <- 1 - stab
    }
  }
}

# aggregate 
df_agg_without <- df2 %>%
  filter(Round != 0) %>%
  dplyr::group_by(Round, GroupType) %>%
  dplyr::summarize(WithoutBiased = mean(Stab))


## merge
df_agg <- merge(df_agg_with, df_agg_without, by=c("Round", "GroupType"))
df_agg <- gather(df_agg, condition, Stab, All:WithoutBiased)

df_agg <- df_agg %>%
  filter(!(GroupType == "Control" & condition == "WithoutBiased")) %>%
  mutate(TypeGroup = ifelse(GroupType == "Control", "Control", ifelse(condition=="All", "Hetero_All", "Hetero_Unbiased")))

## plot
p <- ggplot(df_agg, aes(x=Round, y=Stab, color=TypeGroup, group=TypeGroup)) + geom_point()
p <- add_grey_rect_0_10(p)
p <- p + geom_point(size=5) +
  geom_line(size=1) +
  #geom_smooth() +
  scale_x_continuous(breaks = c(0:10))+
  labs(color="Which participants?", y="Stability") +
  ylim(0,1) +
  scale_color_viridis_d(end=0.8) 
p

```

And a model:

```{r}


### compute stability for groups with biased
for ( gr in unique(df$GroupID)){
  for ( myr in c(1:10)){
    for( mys in unique(df$Shape)){
      list1 <- df$Word[df$GroupID == gr & df$Round == myr & df$Shape == mys]
      list2 <- df$Word[df$GroupID == gr & df$Round == myr-1 & df$Shape == mys]
      stab <- mean(allpairslev_rounds(c(list1, list2), length(list1)), na.rm=TRUE)
      df$Stab[df$GroupID == gr & df$Round == myr & df$Shape == mys] <- 1 - stab
    }
  }
}

# aggregate 
df_agg_with <- df %>%
  filter(Round != 0) %>%
  dplyr::group_by(Round, GroupType, GroupNum) %>%
  dplyr::summarize(All = mean(Stab))

### compute stability for groups without biased
df2 <- df %>%
  filter(Producer != 1)

for ( gr in unique(df2$GroupID)){
  for ( myr in c(1:10)){
    for( mys in unique(df2$Shape)){
      list1 <- df2$Word[df2$GroupID == gr & df2$Round == myr & df2$Shape == mys]
      list2 <- df2$Word[df2$GroupID == gr & df2$Round == myr-1 & df2$Shape == mys]
      stab <- mean(allpairslev_rounds(c(list1, list2), length(list1)), na.rm=TRUE)
      df2$Stab[df2$GroupID == gr & df2$Round == myr & df2$Shape == mys] <- 1 - stab
    }
  }
}

# aggregate 
df_agg_without <- df2 %>%
  filter(Round != 0) %>%
  dplyr::group_by(Round, GroupType, GroupNum) %>%
  dplyr::summarize(WithoutBiased = mean(Stab))


## merge
df_agg <- merge(df_agg_with, df_agg_without, by=c("Round", "GroupType", "GroupNum"))
df_agg <- gather(df_agg, condition, Stab, All:WithoutBiased)

df_agg <- df_agg %>%
  filter(!(GroupType == "Control" & condition == "WithoutBiased")) %>%
  mutate(TypeGroup = ifelse(GroupType == "Control", "Control", ifelse(condition=="All", "Hetero_All", "Hetero_Unbiased"))) %>%
  mutate(Round2 = ifelse(Round == 10, 0, ifelse(Round == 9, 1, ifelse(Round==8, 2, ifelse(Round==7, 3, ifelse(Round==6, 4, ifelse(Round==5, 5, ifelse(Round==4, 6, ifelse(Round==3, 7, ifelse(Round==2, 8, ifelse(Round==1, 9, ifelse(Round==0, 10, "NA")))))))))))) %>%
  mutate(Round2 = as.numeric(Round2)) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))

# model
model <- summary(lmer(Stab ~ TypeGroup*Round2 + (1 | GroupID), data=df_agg))
summary(model)

# print diagnostic plots
#plots <- plot_model(model, type = "diag", show.ci = FALSE)
#plots <- lapply(plots, function(p) p + theme(text = element_text(size = 12)))
#ggarrange(plots[[1]], plots[[2]], plots[[3]], plots[[4]], nrow = 2, ncol = 2)

```

```{r}
#| echo: false
#| message: false
#| warning: false


# ENTROPY
# df %>%
#   filter(TypeTest == "testing_set" | TypeTest == "final_testing") %>%
#   mutate(PartID = as.factor(PartID),
#          Shape = as.factor(Shape)) -> df2
# 
# df_all <- data.frame()
# for (gt in unique(df2$GroupType)){
#   for (gnum in unique(df2$GroupNum)){
#     for (part_id in unique(df2$PartID)){
#       for (shape in unique(df2$Shape)){
#         subdf <- df2[df2$PartID==part_id & df2$Shape==shape,]
#         after_learn <- subdf$Word[subdf$TypeTest=="testing_set"]
#         LEARN_ent_per_word = Entropy(table(after_learn), base=exp(1))
#         LEARN_char_per_word = nchar(paste(after_learn, collapse=""))/length(after_learn)
#         LEARN_ent_per_character = LEARN_ent_per_word/LEARN_char_per_word
#         
#         after_test <- subdf$Word[subdf$TypeTest=="final_testing"]
#         TEST_ent_per_word = Entropy(table(after_test), base=exp(1))
#         TEST_char_per_word = nchar(paste(after_test, collapse=""))/length(after_test)
#         TEST_ent_per_character = TEST_ent_per_word/TEST_char_per_word
#         
#         mydf <- data.frame(GroupType = gt, GroupNum = gnum, PartID=part_id, Shape=shape, EntLearnWord=LEARN_ent_per_word, EntLearnChar = LEARN_ent_per_character, EntTestWord=TEST_ent_per_word, EntTestChar = TEST_ent_per_character)
#         df_all <- rbind(df_all, mydf)
#       }
#     }
#   }
# }
# 
# 
# # this computes the entropy using the following:
# # take a frequency table
# # then convert it to probability table
# # then for each prob compute prob*log(prob)
# # do the sum for each and multiply by -1
# 
# df_all_gat <- gather(df_all, condition, measurement, EntLearnWord:EntTestChar)
# df_all_gat %>%
#   filter(condition == "EntLearnWord" | condition == "EntTestWord") %>%
#   mutate(condition = case_when(condition == "EntLearnWord" ~ "After learning",
#                                condition == "EntTestWord" ~ "After testing")) %>%
#   mutate(Shape = case_when(Shape == 0 ~ "nusa",
#                            Shape == 1 ~ "nus",
#                            Shape == 2 ~ "kesip",
#                            Shape == 3 ~ "esip",
#                            Shape == 4 ~ "puak",
#                            Shape == 5 ~ "nekuki",
#                            Shape == 6 ~ "anap",
#                            Shape == 7 ~ "aike")) -> df_all_gat2
# 



```

## 2 - Has the language of the group adapted to the specificity of the biased participant?

In this part, we will look at a set of different models.

First, we will gather the data by group (of course, excluding the production from the biased participant in the heterogenous group). It leads to beautiful and interpretable plots (the ones printed in the main paper). However, we loose some information by averaging the data. In these models, we have only the Group ID as the random factor. Then, we will look at the data for each individuals. The plots are harder to read, but the statistics are more accurate. In the models, we look at the random effects of participants nested within group ID. For each type of data aggregation, we look both at the evolution of the frequency of biased letters across rounds (including round 0 and 10, which are the testing before and after the communication game), and we also make a special focus on the testing moment (first versus last). We tried to add the round or the moment of testing as random slopes, but it led the models not to converge.

To summarize our models, here is what we used:

| Type aggregation | Fixed effect 1 | Fixed effect 2  | Random effects | Plot   | Model        |
|------------|----------------|-----------------|------------------------|---------------------------|--------------------------------|
| Group      | Round          | Group Type      | Group ID               | **Figure 2A**             | model 4a.                      |
| Group      | Testing moment | Group Type      | Group ID               | **Figure 2B**             | model 4b                       |
| Individual | Round          | Group Type      | Group ID / part_ID     | not in the main paper     | **model 4, in the main paper** |
| Individual | Testing moment | Group Type      | Group ID / part_ID | not in the main paper | model 4c                       |



### Per group

#### For all rounds

Here, we calculate the frequency of biased and unbiased letters. For each round, we determine the total frequency of "k" and "a" out of all the letters used in that round to obtain the frequency of biased letters. Similarly, we compute the frequency of "p", "n", "s", "e", "i", and "u" out of the total frequency of letters used in the round to obtain the frequency of unbiased letters. Since there are 6 unbiased letters and 2 biased letters, we divide the frequency of biased letters by 2 and the frequency of unbiased letters by 6.

Please note that the initial labels have slightly more biased letters than unbiased letters. The frequency of each letter in the initial labels (**kesip, esip, nus, nusa, aike, puak, nekuki, anap**) is:

```{r}
#| echo: false
#| message: false
#| warning: false 

# vector of initial words
concat <- paste(unique(df$Word[df$TypeTest=="PassiveExposure"]), sep="", collapse="")

# Look at the frequency table
table(strsplit(concat, ""))

# compute mean initial frequency of biased letter
#init_freq_biased <- mean(str_count(concat, "k")/str_count(concat))*100
#init_freq_unbiased <- mean(str_count(concat, "p")/str_count(concat))*100

# we multiply this by 2 because there are two biased letters
init_freq_biased <- mean(str_count(concat, "k")/str_count(concat))*100*2


```

Thus, the initial frequency of each **biased** letter is of `r round(init_freq_biased, 2)` %.

In all the following plots, we will represent these initial frequencies with a black dashed line.

```{r }
#| echo: false
#| message: false
#| warning: false 
#| label: fig-freq-round-all
#| fig-cap: "Plot showing the evolution of frequency of biased letters in control groups (red) and heterogenous groups (blue). Each line represent a group, and the thick line shows the linear regression applied to all these groups."
#| fig-width: 9
#| fig-height: 7

# compute frequency (only biased letters)
df_agg <- df %>%
  filter(TypeTest != "PassiveExposure",
         !(Producer == "1" & GroupType == "Hetero")) %>%
  dplyr::group_by(GroupType, GroupNum, Round) %>% 
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Freq = (biased_count / total_count)*100) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))  %>%
  mutate(Round2 = ifelse(Round == 10, 0, ifelse(Round == 9, 1, ifelse(Round==8, 2, ifelse(Round==7, 3, ifelse(Round==6, 4, ifelse(Round==5, 5, ifelse(Round==4, 6, ifelse(Round==3, 7, ifelse(Round==2, 8, ifelse(Round==1, 9, ifelse(Round==0, 10, NA)))))))))))) %>%
  mutate(RoundType = ifelse(Round == 1 | Round == 3 | Round == 6, "T1", ifelse(Round == 2 | Round == 4 | Round == 7, "T2", ifelse(Round == 3 | Round == 6 | Round == 9, "T3", "TTest"))))


# plot
p_round <- ggplot(df_agg, aes(x=Round, y=Freq, color=GroupType, group = interaction(GroupNum, GroupType)))+ geom_point()
p_round <- add_grey_rect_0_10(p_round)
p_round <- p_round + 
  geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
  geom_point(alpha=0.5, size=1)+
  geom_line(alpha=0.5)+
  geom_smooth(method="lm", data=df_agg, aes(x=Round, y=Freq, color=GroupType, group = GroupType)) +
  labs(y="Mean freq of biased letters (%)", fill="Group") +
  #facet_grid(GroupType ~ .) +
  scale_x_continuous(breaks = c(0:10)) +
  theme(axis.title.y = element_text(size = 17))

p_round

```

Out of curiosity, let's observe if we plot the same plot with a loess function instead of a linear one:

```{r}

# plot
p_round <- ggplot(df_agg, aes(x=Round, y=Freq, color=GroupType, group = interaction(GroupNum, GroupType)))+ geom_point()
p_round <- add_grey_rect_0_10(p_round)
p_round <- p_round + 
  geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
  geom_point(alpha=0.5, size=1)+
  geom_line(alpha=0.5)+
  geom_smooth(method="loess", data=df_agg, aes(x=Round, y=Freq, color=GroupType, group = GroupType)) +
  labs(y="Mean freq of biased letters (%)", fill="Group") +
  #facet_grid(GroupType ~ .) +
  scale_x_continuous(breaks = c(0:10)) +
  theme(axis.title.y = element_text(size = 17))

p_round
```


Let's use a linear model to study if there is an effect of time and group type on the frequency of biased and unbiased letters.
The model include testing sessions (round 0 to 10), and is refered as **model 4a**:

(Please note that adding round or round type as random slopes causes the model not to converge; uncomment the part below to see the output.)

```{r}
#| echo: false
#| message: false
#| warning: false 

### THESE MODELS DO NOT CONVERGE

## model with random slopes for ROUND
#model <- lmer(Freq ~ Round2 * GroupType + (1 + RoundType | GroupID), data=df_agg, control=lmerControl(optimizer="bobyqa"))
#summary(model)

## model with random slopes for ROUNDTYPE
#model <- lmer(Freq ~ Round2 * GroupType + (1 + Round2 | GroupID), data=df_agg, control=lmerControl(optimizer="bobyqa"))
#summary(model)

# model without random slopes
model <- lmer(Freq ~ Round2 * GroupType + (1 | GroupID), data=df_agg)
summary(model)

# print diagnostic plots
plots <- plot_model(model, type = "diag", show.ci = FALSE)
plots <- lapply(plots, function(p) p + theme(text = element_text(size = 12)))
ggarrange(plots[[1]], plots[[2]], plots[[3]], plots[[4]], nrow = 2, ncol = 2)

```

The plot and model suggest:

-   There is more variation in heterogenous groups compared to control groups

-   In control groups, the proportion of biased and unbiased letters remains similar to the initial frequency of these letters

-   In heterogenous groups, the proportion of unbiased letters slightly increases with time, while the proportion of biased letters slightly decreases with time.

Let's look at the same plot, but using aggregated values for all groups:

```{r }
#| echo: false
#| message: false
#| warning: false 
#| label: fig-freq-round-all-agg
#| fig-cap: "Same plot as above, aggregated by group number."
#| fig-width: 8
#| fig-height: 6


df_agg <- df %>%
  filter(TypeTest != "PassiveExposure",
         !(Producer == "1" & GroupType == "Hetero")) %>%
  dplyr::group_by(GroupType, Round) %>%
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Freq = (biased_count / total_count)*100)

p <- ggplot(df_agg, aes(x=Round, y=Freq, color=GroupType))+ geom_point()
p <- add_grey_rect_0_10(p)
p <- p +  geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
  geom_point(size=5)+
  geom_line(size=1)+
  #geom_smooth() +
  labs(y="Mean frequency (in %)", fill="Group") +
  scale_x_continuous(breaks = c(0:10)) 
p
```
Interestingly, the frequency of biased letters dropped at round 3 in heterogenous groups. It could be due to the fact that unbiased participants have been paired with the biased participant successively in round 1 and 2, and thus have both in mind the vocabulary with less biased letters. 

#### For Testing

The previous plot focused on the evolution of the frequency of biased and unbiased letters across all rounds (0 to 10). Now, we will focus solely on **Round 0 and Round 10**, namely, the initial (*FirstTest*, after the passive exposure) and the final testing (*LastTest*, after the communication game). Here too, we remove the data from the biased participant in the heterogenous groups.

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-freq-testing2
#| fig-cap: "Change in the frequency of biased and unbiased letters in the first testing (before the communication game) and in the second testing (after the communication game) at a group-level. Each point represent a group, and the thin grey line indicate the within design (each group is tested before and after)."
#| fig-width: 7
#| fig-height: 5

# compute frequency (only biased letters)
df_agg <- df %>%
  filter(TypeTest=="FirstTesting" | TypeTest=="SecondTesting",
         !(Producer == "1" & GroupType == "Hetero")) %>%
  dplyr::group_by(GroupType, GroupNum, Round, TypeTest) %>% 
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Freq = (biased_count / total_count)*100) %>%
  dplyr::select(-c(biased_count, total_count, Words)) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))  %>%
  mutate(Round2 = ifelse(Round == 10, 0, ifelse(Round == 9, 1, ifelse(Round==8, 2, ifelse(Round==7, 3, ifelse(Round==6, 4, ifelse(Round==5, 5, ifelse(Round==4, 6, ifelse(Round==3, 7, ifelse(Round==2, 8, ifelse(Round==1, 9, ifelse(Round==0, 10, NA)))))))))))) %>%
  mutate(TypeTest = case_when(TypeTest == "FirstTesting" ~ "First Test",
                              TypeTest == "SecondTesting" ~ "Last Test")) %>%
  mutate(TypeTest = as.factor(TypeTest)) %>%
  mutate(GroupType = as.character(GroupType)) %>%
  mutate(GroupType = case_when(GroupType=="Hetero" ~ "Heterogenous",
                               GroupType=="Control" ~ "Control")) %>%
  mutate(GroupType = factor(GroupType, levels=c("Heterogenous", "Control"))) %>%
  mutate(RoundType = ifelse(Round == 1 | Round == 3 | Round == 6, "T1", ifelse(Round == 2 | Round == 4 | Round == 7, "T2", ifelse(Round == 3 | Round == 6 | Round == 9, "T3", NA))))

# Plot
p_test <- ggplot(df_agg, aes(x=TypeTest, y=Freq, fill=GroupType))+
  geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
  geom_point(data=df_agg, aes(x=TypeTest, y=Freq, group=GroupNum), size=2) +
  geom_boxplot(color="black", alpha=0.4,position= position_dodge(), width=0.3)+
  theme_bw(base_size=20) +
  geom_line(data=df_agg, aes(x=TypeTest, y=Freq, group=GroupNum), color="grey")+
  labs(x="", y="Mean freq of biased letters (%)") +
  facet_grid(. ~ GroupType) +
  guides(fill=FALSE, color=FALSE)

p_test
```
We compute the model, which is refered as **model 4b** (see [2 - Group-adaptation to the biased participants]) for more information.

```{r}
#| echo: false
#| message: false
#| warning: false


# with random slopes
#mod <- lmer(Freq ~ TypeTest * GroupType + (1 + TypeTest | GroupID), data=df_agg)
#summary(mod)
# this model crashes, because there are as many number of observations as random effects

# without random slopes
mod <- lmer(Freq ~ TypeTest * GroupType + (1 | GroupID), data=df_agg)
summary(mod)

# print diagnostic plots
plots <- plot_model(model, type = "diag", show.ci = FALSE)
plots <- lapply(plots, function(p) p + theme(text = element_text(size = 12)))
ggarrange(plots[[1]], plots[[2]], plots[[3]], plots[[4]], nrow = 2, ncol = 2)

```
This is not significant, but it could be due to the low number of groups. Thus, we also perform bootstrapping.

##### Boostrapping (Frequency of biased letters)

Bootstrapping is a resampling technique used in statistics to estimate the uncertainty associated with a sample statistic. It involves repeatedly drawing random samples with replacement from the original data set. By creating multiple bootstrap samples, the method allows for the estimation of sampling variability, constructing confidence intervals, and assessing the statistical significance of results. Bootstrapping is particularly useful when the sample size is small or when the underlying data distribution is unknown or non-normal, as it provides a robust and flexible approach for inference.

```{r}

# Here we used two methods, just to make sure that our results are OK - since they gave the same type of results we only look at method 2


#### ---- Method 1 ---- ####

# # Fit the mixed-effects model
# model <- lmer(Freq ~ GroupType * TypeTest + (1 | GroupID), data = df_agg)
# 
# # Bootstrapping
# num_iterations <- 100  
# boot_results <- matrix(NA, nrow = num_iterations, ncol = 4)  # 4 for coefficients of the Intercept v1, v2, and their interaction
# 
# for (i in 1:num_iterations) {
#   # Resampling
#   sampled_groups <- sample(unique(df_agg$GroupID), replace = TRUE)
#   boot_data <- df_agg[df_agg$GroupID %in% sampled_groups, ]
# 
#   # Model fitting
#   boot_model <- lmer(Freq ~ GroupType * TypeTest + (1 | GroupID), data = boot_data)
# 
#   # Record results
#   boot_results[i, ] <- fixef(boot_model)
# }
# 
# # add names
# colnames(boot_results) <- c("Intercept", "GroupTypeControl", "LastTest", "GroupType:LastTest")
# 
# # Aggregate and summarize results
# mean_coef <- colMeans(boot_results, na.rm = TRUE)
# conf_interval <- quantile(boot_results[,4], c(0.025, 0.975), na.rm = TRUE)
# 
# # Display results
# print("Mean Coefficients:")
# print(mean_coef)
# print("95% Confidence Intervals:")
# print(conf_interval)

#### ---- Method 2 via lmersmapler:---- ####

mod1 <- lmer(Freq ~ GroupType * TypeTest  + (1 | GroupID), data = df_agg)
lmer_par_boot <- bootstrap(mod1, .f = fixef, type = "parametric", B = 100)

### output:

# summary(mod1) # here to compare with the original fit 
#summary(lmer_par_boot)

# get confidence intervals:
confint(lmer_par_boot)
#print(lmer_par_boot,  ci = TRUE)

### plot
plot(lmer_par_boot)

```

When observing the lower and upper bound for the ineraction between GroupType and TypeTest, we found that this confidence interval never includes zero. It is hinting at the possible significance of the data if we have had more groups.


##### How to explain Group 2 and Group 6 performance?

@fig-freq-testing2 also highlights that two groups within the heterogenous condition (**Group 2 and Group 6**) deviate from this pattern. Our hypothesis is that these groups did not adapt to the biased participant because their participants remembered too well the initial labels, causing them to stick by those words. To further investigate, let's examine the accuracy of the initial learning phase for all groups:

```{r }
#| echo: false
#| message: false
#| warning: false
#| label: fig-acc-group2-and6
#| fig-cap: "Investigating more the relation between adaptability and performance at learning the initial words. Here, we look at the initial accuracy (binary, 0 or 1) and the initial distance words (levenshtein distance) in the first testing for each group. We expect the performance to be better for Group 2 and Group 6."
#| fig-width: 10
#| fig-height: 9

# Look at the learning accuracy for each group
df_agg <- df %>%
  filter(TypeTest == "FirstTesting",
         GroupType == "Hetero") %>%
  group_by(Producer, TypeTest, GroupNum, GroupType) %>%
  summarize(mean_acc = mean(ACC)*100) %>%
  mutate(Producer = as.character(Producer)) %>%
  mutate(Producer = ifelse(Producer == "1", "1 (biased)",Producer)) 

# Plot
p1 <- ggplot(df_agg, aes(x=Producer, y=mean_acc, fill=Producer)) +
  geom_bar(stat="identity") +
  ylim(-5,105) +
  labs(y="Accuracy first learning", x="Participant ID") +
  guides(color=FALSE, fill=FALSE) +
  facet_grid(GroupNum ~ .) +
  coord_flip() +
  geom_hline(yintercept=50, linetype="dashed") 
  
# Compute
df_agg <- df %>%
  filter(TypeTest == "FirstTesting", GroupType == "Hetero") %>%
  mutate(Shape = as.character(Shape)) %>%
  dplyr::group_by(Producer, GroupNum, GroupType) %>%
  dplyr::summarize(mean_lev_dis = mean(ProducSim)) %>%
  mutate(Producer = as.character(Producer)) %>%
  mutate(Producer = ifelse(Producer == "1", "1 (biased)",Producer))

# plot obtained data
p2 <- ggplot(df_agg, aes(x=Producer, y=mean_lev_dis, fill=Producer)) +
  geom_bar(stat="identity") +
  ylim(0,1) +
  labs(y="Norm Levenshtein dist", x="Participant ID") +
  facet_grid(GroupNum ~ .) +
  coord_flip() +
  guides(fill=FALSE)

grid.arrange(p1, p2, ncol=2)

```

It appears that Group 2 and Group 6 (the groups that did not adapt to the biased participants) also exhibited higher learning accuracy. Let's verify whether our hypothesis is encouraged by checking if these groups had nearly identical words at the end compared to the initial words.

**For group 2:**

Before communicating labels:

```{r}
#| echo: false
#| message: false
#| warning: false


df %>%
    filter(TypeTest == "FirstTesting" & GroupNum == 2 & GroupType == "Hetero") %>%
    dplyr::select(Producer, Word, Shape) %>%
    spread(Shape, Word) -> first_name

df %>%
    filter(TypeTest == "SecondTesting" & GroupNum == 2 & GroupType == "Hetero") %>%
    dplyr::select(Producer, Word, Shape) %>%
    spread(Shape, Word) -> last_name
  
  colnames(first_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")
  colnames(last_name) <- c("PartID", "aike","anap", "esip", "kesip", "nekuki", "nus","nusa","puak")
  
kable(first_name)

```

After communicating labels:

```{r}
#| echo: false
#| message: false
#| warning: false

kable(last_name)
```

**For Group 6:**

Before communicating labels:

```{r}
#| echo: false
#| message: false
#| warning: false

df %>%
    filter(TypeTest == "FirstTesting" & GroupNum == 6 & GroupType == "Hetero") %>%
    dplyr::select(Producer, Word, Shape) %>%
    spread(Shape, Word) -> first_name

df %>%
    filter(TypeTest == "SecondTesting" & GroupNum == 6 & GroupType == "Hetero") %>%
    dplyr::select(Producer, Word, Shape) %>%
    spread(Shape, Word) -> last_name
  
  colnames(first_name) <- c("PartID", "nusa","nus", "kesip", "esip", "puak", "nekuki","anap","aike")
  colnames(last_name) <- c("PartID", "nusa","nus", "kesip", "esip", "puak", "nekuki","anap","aike")
  
kable(first_name)
```

After communicating labels:

```{r}
#| echo: false
#| message: false
#| warning: false

kable(last_name)
```

Let's see if this is significant:

```{r}

# Look at the learning accuracy for each group
df_agg <- df %>%
  filter(TypeTest == "FirstTesting",
         GroupType == "Hetero") %>%
  group_by(Producer, TypeTest, GroupNum, GroupType) %>%
  summarize(mean_acc = mean(ACC)*100) %>%
  mutate(Producer = as.character(Producer)) %>%
  mutate(Producer = ifelse(Producer == "1", "1 (biased)", Producer)) %>%
  mutate(GroupOK = ifelse(GroupNum == 2 | GroupNum==6, "DidNotAdapt", "DidAdapt"))

summary(lmer(mean_acc ~ GroupOK + (1 | GroupNum), data=df_agg, control=lmerControl(optimizer="bobyqa")))

summary(lm(mean_acc ~ GroupOK, data=df_agg))

```


In order to look more precisely at the relation between learning accuracy and adaptability, please refer to part \[3 - Adaptability\] and subpart [What do predict adaptation?]

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-adapt-learning
#| fig-cap: "Investigating more the relation between adaptability and performance at learning the initial words. Each point represent a participant, and the blue line shows the linear regression between all these points."
#| fig-width: 6
#| fig-height: 4

# Now, let's take a closer look at how adaptability relates to the average accuracy of learning. To do this, we introduce a measure of adaptability. This measure reflects the difference between the frequency of biased letters during the initial testing and the frequency of biased letters during the final testing for each participant. A higher value indicates a greater reduction in the number of biased letters in their final vocabulary. On the other hand, a negative score for adaptability means that the participant has increased the number of biased letters. More details about adaptability will be available in the part [Relative to participants characteristics].

# # dataset with accuracy
# df_acc <- df %>%
#   filter(TypeTest == "FirstTesting",
#          GroupType == "Hetero", 
#          Producer != 1) %>%
#   group_by(Producer, TypeTest, GroupNum) %>%
#   summarize(mean_acc = mean(ACC)*100) 
# 
# # dataframe with frequency
# df_freq <- df %>%
#   filter(TypeTest == "SecondTesting" | TypeTest == "FirstTesting",
#          Producer != "1",
#          GroupType == "Hetero") %>%
#   dplyr::group_by(GroupNum, TypeTest, Producer) %>% 
#   dplyr::summarise(Words = paste(Word, collapse = "")) %>%
#   mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
#          total_count = str_count(Words, "\\S"),
#          Biased = (biased_count / total_count)/2) %>%
#   dplyr::select(-c(biased_count, total_count, Words)) %>%
#   spread(TypeTest, Biased) %>%
#   mutate(Adaptability = (FirstTesting - SecondTesting)*100) 
#   
# # merge the two dataframes
# df_merged <- merge(df_acc, df_freq, by=c("GroupNum", "Producer"))
# 
# # Plot
# ggplot(df_merged, aes(x=Adaptability, y=mean_acc))+
#   geom_point() +
#   geom_smooth(method="lm") +
#   labs(y="Mean accuracy of learning") +
#   geom_vline(xintercept=0, linetype="dashed")

#There is indeed a relationship between adaptability and mean learning accuracy: the more participants remember the initial labels, the less likely they are to adapt to the biased participants.

```

```{r }
#| echo: false
#| message: false
#| warning: false
#| label: fig-adapt-learning2
#| fig-cap: "Investigating more the relation between adaptability and performance at learning the initial words. Each point represent a participant, and the blue line shows the linear regression between all these points."
#| fig-width: 6
#| fig-height: 4

# 
# # compute frequency
# df_agg <- df %>%
#   filter(TypeTest=="FirstTesting" | TypeTest=="SecondTesting",
#          Producer != "1") %>%
#   dplyr::group_by(GroupType, GroupNum, TypeTest) %>% 
#   dplyr::summarise(Words = paste(Word, collapse = "")) %>%
#   mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
#          total_count = str_count(Words, "\\S"),
#          Biased = (biased_count / total_count)/2,#because there are 2 biased let
#          Normal = (1 - Biased)/6) %>% # because there are 6 unbiased let
#   gather(TypeLetter, Freq, Biased:Normal) %>%
#   dplyr::group_by(GroupType, TypeTest, TypeLetter) %>%
#   dplyr::summarize(mean_freq = mean(Freq),
#                    se_freq = se(Freq))
# 
# 
# ggplot(df_agg, aes(x=TypeTest, y=mean_freq, color=TypeLetter, fill=TypeLetter, group=interaction(TypeTest, TypeLetter)))+
#   geom_pointrange(aes(ymin=mean_freq-se_freq, ymax=mean_freq+se_freq), position=position_dodge()) +
#     geom_line()+
#   facet_grid(GroupType ~ .) +
#   labs(y="Mean frequency", x="")

```

Now, we look at the evolution of the production similarity with the initial labels with time with a focus on these two groups:

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-evolution-ProducSim_group
#| fig-cap: "Evolution of the production similarity at each round and for each group. Please note that this plot does not include the productions of the biased participant."
#| fig-width: 8
#| fig-height: 6

# Compute
df_agg <- df %>%
  filter(TypeTest != "PassiveExposure") %>%
  filter(GroupType == "Hetero") %>%
  mutate(GroupNum = as.character(GroupNum)) %>%
  dplyr::group_by(GroupType, Round, GroupNum) %>%
  dplyr::summarize(mean_lev_dis = mean(ProducSim)) %>%
  mutate(colorr = ifelse(GroupNum == 2, "Group2", ifelse(GroupNum==6, "Group6", "Other"))) %>%
  mutate(alphaa = ifelse(colorr=="Other", "high", "low"))

# Plot
p <- ggplot(df_agg, aes(x=Round, y=mean_lev_dis, color=colorr, group=GroupNum, alpha=alphaa)) + geom_point()
p <- add_grey_rect_0_10(p) 
p <- p + geom_point(size=5) +
  geom_line(size=1) +
  facet_grid(GroupType ~ .) +
  labs(y="Production similarity", fill="Shape", color="Group") +
  scale_x_continuous(breaks = c(0:10)) +
  scale_color_viridis_d(end=0.8) +
  scale_alpha_manual(values=c(0.4, 0.8)) +
  guides(alpha=FALSE)
p

```

This plot helps understand the non adaptability of Group 2 - participants of this group converged on the initial labels. However, no clear explanation emerges about the performance reached by Group 6.

### Per individual

#### For all rounds

This is the same plot as before, except that we plot here the results for each participant. See the part [2 - Group-adaptation to the biased participants] for more information. 

Please note that while we did not printed this plot in the main paper, the model associated to this plot is the one we put in the main paper.

```{r }
#| echo: false
#| message: false
#| warning: false 
#| label: fig-freq-round-indiv-all
#| fig-cap: "Plot showing the evolution of frequency of biased letters in control groups (red) and heterogenous groups (blue). Each line represent a group, and the thick line shows the linear regression applied to all these groups."
#| fig-width: 10
#| fig-height: 8

# compute frequency (only biased letters)
df_agg <- df %>%
  filter(TypeTest != "PassiveExposure",
         !(Producer == "1" & GroupType == "Hetero")) %>%
  dplyr::group_by(GroupType, GroupNum, Round, Producer) %>% 
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Freq = (biased_count / total_count)*100) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))  %>%
  mutate(Round2 = ifelse(Round == 10, 0, ifelse(Round == 9, 1, ifelse(Round==8, 2, ifelse(Round==7, 3, ifelse(Round==6, 4, ifelse(Round==5, 5, ifelse(Round==4, 6, ifelse(Round==3, 7, ifelse(Round==2, 8, ifelse(Round==1, 9, ifelse(Round==0, 10, NA)))))))))))) %>%
  mutate(RoundType = ifelse(Round == 1 | Round == 3 | Round == 6, "T1", ifelse(Round == 2 | Round == 4 | Round == 7, "T2", ifelse(Round == 3 | Round == 6 | Round == 9, "T3", NA)))) %>%
  mutate(PartID_unique = paste(GroupType, GroupNum, Producer, sep="_")) %>%
  ungroup()

# plot
p <- ggplot(df_agg, aes(x=Round, y=Freq, color=GroupType, group = PartID_unique))+ geom_point()
p <- add_grey_rect_0_10(p)
p <- p + 
  geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
  geom_point(alpha=0.5, size=1)+
  geom_line(alpha=0.5)+
  geom_smooth(method="lm", data=df_agg, aes(x=Round, y=Freq, color=GroupType, group = GroupType)) +
  labs(y="Mean Freq of biased letters (%)", fill="Group") +
  #facet_grid(GroupType ~ .) +
  scale_x_continuous(breaks = c(0:10))
p

# with loess function
p <- ggplot(df_agg, aes(x=Round, y=Freq, color=GroupType, group = PartID_unique))+ geom_point()
p <- add_grey_rect_0_10(p)
p <- p + 
  geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
  geom_point(alpha=0.5, size=1)+
  geom_line(alpha=0.5)+
  geom_smooth(method="loess", data=df_agg, aes(x=Round, y=Freq, color=GroupType, group = GroupType)) +
  labs(y="Mean Freq of biased letters (%)", fill="Group") +
  #facet_grid(GroupType ~ .) +
  scale_x_continuous(breaks = c(0:10))
p


```

Let's look at the model, included in the main paper and refered to as **model 4**. Please note that this model include testing sessions (round 0 to 10).

(Please note that adding round or round type as random slopes causes the model not to converge; uncomment the part below to see the output.)

```{r}

### THESE MODELS DO NOT CONVERGE

## model with random slopes for ROUND
#model <- lmer(Freq ~ Round2 * GroupType + (1 + Round2 | GroupID / PartID_unique) , data =  df_agg, control=lmerControl(optimizer="bobyqa"))
#summary(model)

## model with random slopes for PAIRS TYPE
# df_agg$pairs <- ifelse( ((df_agg$Round == 1 | df_agg$Round == 4 | df_agg$Round == 7) & df_agg$Producer == 2), "1_2", 
#                         ifelse(((df_agg$Round == 1 | df_agg$Round == 4 | df_agg$Round == 7) & df_agg$Producer != 2), "3_4", 
#                                ifelse(((df_agg$Round == 2 | df_agg$Round == 5 | df_agg$Round == 8) & df_agg$Producer == 3), "1_3", 
#                                       ifelse(((df_agg$Round == 2 | df_agg$Round == 5 | df_agg$Round == 8) & df_agg$Producer != 3), "2_4", 
#                                             ifelse(((df_agg$Round == 3 | df_agg$Round == 6 | df_agg$Round == 9) & df_agg$Producer == 4), "1_4", 
#                                                 ifelse(((df_agg$Round == 3 | df_agg$Round == 6 | df_agg$Round == 9) & df_agg$Producer != 4), "2_3", "None"))))))
# model <- lmer(Freq ~ Round2 * GroupType + (1 + pairs | GroupID / PartID_unique), data = df_agg)
# summary(model)


# model without random slopes
model <- lmer(Freq ~ Round2 * GroupType + (1 | GroupID / PartID_unique), data =  df_agg)
summary(model)

# print diagnostic plots
plots <- plot_model(model, type = "diag", show.ci = FALSE)
plots <- lapply(plots, function(p) p + theme(text = element_text(size = 12)))
ggarrange(plots[[1]], plots[[2]], plots[[3]], plots[[4]], nrow = 2, ncol = 2)

```

#### For Testing

This plot is the same as in figure 18, except that we plot here the output for each participant.

```{r}
#| echo: false
#| message: false
#| warning: false 
#| label: fig-freq-indv
#| fig-cap: "Evolution of the mean frequency of biased  and unbiased letters for each individual in each group type."
#| fig-width: 9
#| fig-height: 7

df_freq <- df %>%
  filter(TypeTest == "FirstTesting" | TypeTest == "SecondTesting") %>%
  dplyr::group_by(GroupType, GroupNum, Round, Producer) %>% 
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Freq = (biased_count / total_count)*100) %>%
  dplyr::select(-c(Words, biased_count, total_count)) %>%
  filter(!(Producer == 1 & GroupType == "Hetero")) %>%
  mutate(Round = case_when(Round == 0 ~ "First Test",
                           Round == 10 ~ "Last Test")) %>%
  dplyr::rename(TypeTest = Round) %>%
  mutate(ID = paste(GroupNum,  Producer, sep="_")) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_")) %>%
  mutate(PartID_unique = paste(GroupType, GroupNum, Producer, sep="_")) %>%
  ungroup()

# plot
ggplot(df_freq, aes(x=TypeTest, y=Freq, fill=GroupType)) +
  facet_grid(. ~ GroupType) +
  #geom_hline(aes(yintercept=Value_DashedLine), linetype="dashed", size=0.6)+
  geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
  #geom_hline(yintercept = init_freq_unbiased, linetype = "dashed") +
  geom_point(data=df_freq, aes(x=TypeTest, y=Freq, group=ID), size=2) +
  geom_boxplot(color="black", alpha=0.2,position= position_dodge(), width=0.3)+
  theme_bw(base_size=15) +
  geom_line(data=df_freq, aes(x=TypeTest, y=Freq, group=ID), color="grey") +
  labs(y="Mean Freq of biased letters (%)")

```
This model is refered as **model 4c**:

```{r}
#| echo: false
#| message: false
#| warning: false

# without random slopes
model <- lmer(Freq ~ TypeTest * GroupType + (1 | GroupID / PartID_unique) , data = df_freq)
summary(model)

# print diagnostic plots
plots <- plot_model(model, type = "diag", show.ci = FALSE)
plots <- lapply(plots, function(p) p + theme(text = element_text(size = 12)))
ggarrange(plots[[1]], plots[[2]], plots[[3]], plots[[4]], nrow = 2, ncol = 2)


# with random slopes: does not work
#model <- lmer(Freq ~ TypeTest * GroupType + (1 + TypeTest | GroupID / PartID_unique) , data = df_freq)
#summary(model)

```

```{r}
#| echo: false
#| message: false
#| warning: false 
#| label: fig-freq-indiv2
#| fig-cap: "Same as before, except that here we don't have an index Before and After, but an index that shows the difference between the two instead."
#| fig-width: 8
#| fig-height: 5

# Now, we compute the difference before and after. We plot it:


# df_freq_diff <- df_freq %>%
#   spread(TypeTest, Freq) %>%
#   mutate(diff = `Last Test` - `First Test`) %>%
#   dplyr::select(-c(`Last Test`, `First Test`))
# 
# 
# # Visual look
# ggplot(df_freq_diff, aes(x=GroupType, y=diff, color=GroupType, fill=GroupType)) +
#   geom_boxplot(color="black", alpha=0.3) +
#   geom_hline(yintercept = 0, linetype="dashed") +
#   geom_point(pch = 21, position = position_jitterdodge()) +
#   labs(y="Diff in BL freq - After and Before Interact") +
#   guides(color=FALSE, fill=FALSE)

```

### Summary: per group & per pair

```{r}
#| echo: false
#| message: false
#| warning: false 
#| label: fig-freq-all
#| fig-cap: "Plot showing the evolution of frequency of both biased letters (red) and unbiased letters (blue). Each line represent a group, and the thick line shows the linear regression applied to all these groups. The grey dashed lines shows the initial frequencies of biased and unbiased letters in the initial labels."
#| fig-width: 10
#| fig-height: 8

# # compute frequency
# df_agg <- df %>%
#   filter(TypeTest != "PassiveExposure",
#          Producer != "1") %>%
#   filter(Round == 0 | Round == 7 | Round == 8 | Round==9 | Round == 10) %>%
#   mutate(Moment = ifelse(Round == 0, "FirstTest", ifelse(Round==10, "FinalTest", ifelse(Round==9 & Producer==4, "LastBiased", ifelse(Round==8 & Producer==3, "LastBiased", ifelse(Round==7 & Producer==2, "LastBiased", ifelse(Round==8 & Producer==4, "LastUnbiased", ifelse(Round==9 & (Producer==2 | Producer==3), "LastUnbiased", NA)))))))) %>%
#   filter(is.na(Moment)==FALSE) %>%
#   dplyr::group_by(GroupType, GroupNum, Producer, Moment) %>% 
#   dplyr::summarise(Words = paste(Word, collapse = "")) %>%
#   mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
#          unbiased_count = str_count(Words, "p") + str_count(Words, "s") + str_count(Words, "n") + str_count(Words, "i") + str_count(Words, "u") + str_count(Words, "e"),
#          total_count = str_count(Words, "\\S"),
#          Biased = (biased_count / total_count)/2*100,#because there are 2 biased let
#          Normal = (unbiased_count / total_count)/6*100) %>% # because there are 6 unbiased let
#   #dplyr::select(-c(k_count, a_count, total_count, a_frequency, k_frequency, Words)) %>%
#   gather(TypeLetter, Freq, Biased:Normal) %>%
#   mutate(Moment = factor(Moment, levels=c("FirstTest", "LastUnbiased", "LastBiased", "FinalTest"))) 
# 
# df_agg2 <- df_agg %>%
#   dplyr::group_by(GroupType, Moment, TypeLetter) %>%
#   dplyr::summarize(mean_freq = mean(Freq),
#                    se_freq = se(Freq))
# 
# ggplot(df_agg, aes(x=Moment, y=Freq, color=TypeLetter, fill=TypeLetter))+ 
#   geom_point(alpha=0.7, position=position_jitterdodge(0.2))+
#   #geom_boxplot(width=0.3, color="black", alpha=0.3, position=position_dodge(0.5)) +
#   geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
#   geom_hline(yintercept = init_freq_unbiased, linetype = "dashed")+
#   guides(fill=FALSE) +
#   geom_pointrange(data=df_agg2, mapping=aes(x=Moment, y=mean_freq, ymin=mean_freq-se_freq, color=TypeLetter, ymax=mean_freq+se_freq),position = position_dodge(width = 0.6), color="black")  +
#   facet_grid(GroupType ~ .) 
# 
# ggplot(df_agg, aes(x=Moment, y=Freq, color=TypeLetter, fill=TypeLetter))+ 
#   geom_violin(alpha=0.7, position=position_dodge(0.5))+
#   #geom_boxplot(width=0.3, color="black", alpha=0.3, position=position_dodge(0.5)) +
#   geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
#   geom_hline(yintercept = init_freq_unbiased, linetype = "dashed")+
#   guides(fill=FALSE) +
#   geom_pointrange(data=df_agg2, mapping=aes(x=Moment, y=mean_freq, ymin=mean_freq-se_freq, color=TypeLetter, ymax=mean_freq+se_freq),position = position_dodge(width = 0.5), color="black")  +
#   facet_grid(GroupType ~ .) 
# 
# summary(lmer(Freq ~ Moment*TypeLetter*GroupType + (1 | GroupNum), data=df_agg))



```

Using violin plots and standard errors

```{r}
#| echo: false
#| message: false
#| warning: false 
#| label: fig-freq-all2
#| fig-cap: "Plot showing the evolution of frequency of both biased letters (red) and unbiased letters (blue). Each point represents a participant, and its production at specific moment: with it lasts interaction with a unbiased participant (left panel, left side), and a biased participant (left panel, right side), and during its first testing before communication game (right panel, left side), and during the last testing after communication game (right panel, right side). "
#| fig-width: 10
#| fig-height: 8

# 1 - compute frequency for last three rounds
df_agg1 <- df %>%
  filter(TypeTest != "PassiveExposure",
         !(Producer == "1" & GroupType == "Hetero")) %>%
  filter(Round == 7 | Round == 8 | Round==9) %>%
  mutate(Moment = ifelse(GroupType == "Control", "Control", ifelse(Round==9 & Producer==4, "Biased", ifelse(Round==8 & Producer==3, "Biased", ifelse(Round==7 & Producer==2, "Biased", ifelse(Round==8 & Producer==4, "Unbiased", ifelse(Round==9 & (Producer==2 | Producer==3), "Unbiased", NA))))))) %>%
  filter(is.na(Moment)==FALSE) %>%
  dplyr::group_by(GroupType, GroupNum, Producer, Moment) %>% 
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Freq = (biased_count / total_count)*100) %>%
  mutate(TypeMoment = "LastInteraction")

# 2 - compute frequency for first and last
df_agg3 <- df %>%
  filter(TypeTest != "PassiveExposure",
         !(Producer == "1" & GroupType == "Hetero")) %>%
  filter(Round == 0 | Round == 10) %>%
  mutate(Moment = ifelse(Round == 0, "First Test", ifelse(Round==10, "Last Test", "NA"))) %>%
  filter(is.na(Moment)==FALSE) %>%
  dplyr::group_by(GroupType, GroupNum, Producer, Moment) %>% 
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Freq = (biased_count / total_count)*100)  %>%
  mutate(TypeMoment = "Test")

# 3 - merge this two dataset and change order factors
df_agg <- rbind(df_agg1, df_agg3)
df_agg <- df_agg %>% 
  mutate(Moment = factor(Moment, levels=c("Control", "First Test", "Unbiased", "Biased", "Last Test"))) 

# 4 - summarize frequency by moment
df_agg2 <- df_agg %>%
  dplyr::group_by(GroupType, Moment, TypeMoment) %>%
  dplyr::summarize(mean_freq = mean(Freq),
                   se_freq = se(Freq)) 

# 5 - reformat
df_agg2 <- df_agg2 %>%
  mutate(Moment = as.character(Moment)) %>%
  mutate(ValueColor = df_agg2$mean_freq[df_agg2$Moment=="Control"]) %>%
  mutate(SeColor = df_agg2$se_freq[df_agg2$Moment=="Control"]) %>%
  filter(Moment!="Control")


### VIOLIN PLOT ###

p1 <- ggplot(df_agg[df_agg$TypeMoment=="LastInteraction",], aes(x=Moment, y=Freq, color=GroupType, fill=GroupType))+ 
  #geom_point(alpha=0.2, position=position_jitterdodge(0.2))+
  geom_violin(alpha=0.2)+
  geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
  geom_pointrange(data=df_agg2[df_agg2$TypeMoment=="LastInteraction",], mapping=aes(x=Moment, y=mean_freq, ymin=mean_freq-se_freq,  ymax=mean_freq+se_freq),position = position_dodge(width = 0.9))  +
  facet_grid(. ~ TypeMoment) +
  theme(legend.position="bottom") +
  ylim(12,42)+
  labs(x="", y="Mean Freq of biased letters (%)")

p2 <- ggplot(df_agg[df_agg$TypeMoment=="Test",], aes(x=Moment, y=Freq, color=GroupType, fill=GroupType))+ 
  #geom_point(alpha=0.2, position=position_jitterdodge(0.2))+
  #geom_boxplot(width=0.3, color="black", alpha=0.3, position=position_dodge(0.5)) +
  geom_violin(alpha=0.2)+
  geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
  geom_pointrange(data=df_agg2[df_agg2$TypeMoment=="Test",], mapping=aes(x=Moment, y=mean_freq, ymin=mean_freq-se_freq, ymax=mean_freq+se_freq),position = position_dodge(width = 0.9))  +
  facet_grid(. ~ TypeMoment) +
   theme(legend.position="bottom") +
  scale_y_continuous(breaks = seq(10, 20, by = 5)) +
  ylim(12,42) +
  labs(x="", y="Mean Freq of biased letters (%)")

ggarrange(p1, p2, ncol=2, nrow=1, common.legend = TRUE, legend="bottom")

### STANDARD ERROR PLOT ###

p1 <- ggplot(df_agg2[df_agg2$TypeMoment=="LastInteraction",], aes(x=Moment, y=mean_freq))+ 
  #geom_point(alpha=0.2, position=position_jitterdodge(0.2))+
  #geom_violin(alpha=0.2)+
  geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
  geom_pointrange(data=df_agg2[df_agg2$TypeMoment=="LastInteraction",], mapping=aes(x=Moment, y=mean_freq, ymin=mean_freq-se_freq,  ymax=mean_freq+se_freq),position = position_dodge(width = 0.9), color="cyan3")  +
  facet_grid(. ~ TypeMoment) +
  theme(legend.position="bottom") +
  ylim(20,31) +
  labs(x="", y="Mean Freq of biased letters (%)") +
  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = ValueColor-SeColor, ymax = ValueColor+SeColor), alpha=0.1, fill="red") +
  geom_hline(aes(yintercept = ValueColor), color="red3", size=1)   


p2 <- ggplot(df_agg[df_agg$TypeMoment=="Test",], aes(x=Moment, y=Freq, color=GroupType, fill=GroupType))+ 
  #geom_point(alpha=0.2, position=position_jitterdodge(0.2))+
  #geom_boxplot(width=0.3, color="black", alpha=0.3, position=position_dodge(0.5)) +
  #geom_violin(alpha=0.2)+
  geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
  geom_pointrange(data=df_agg2[df_agg2$TypeMoment=="Test",], mapping=aes(x=Moment, y=mean_freq, ymin=mean_freq-se_freq, ymax=mean_freq+se_freq),position = position_dodge(width = 0.9))  +
  facet_grid(. ~ TypeMoment) +
   theme(legend.position="bottom") +
  scale_y_continuous(breaks = seq(10, 20, by = 5)) +
  ylim(20,31) +
  labs(x="", y="Mean Freq of biased letters (%)")


ggarrange(p1, p2, ncol=2, nrow=1, common.legend = TRUE, legend="bottom")

```

## 3 - Who adapts and when? 

### Pair-level adaptation

We focus here on the pair-level: we compare the productions of the participants in the pair excluding the biased participants (pair 2 - 3, 3 - 4, and 2 - 4) to the production used by pairs involving the biased participant (pair 1 - 2, 1 - 3, and 1 - 4). Important note: the numbers of words considered when omparing between pair without and with the biased participant differ, as we do not consider the productions of Participant 1. For example, in Round 1, we compare the output of:

-   Pair without the biased participant (*Hetero_unbiased*): production of participant 3 and participant 4 -\> **16 words in total**

-   Pair involving the biased participant (*Hetero_biased*): production of participant 2 only (we did not look at the frequency of biased letter for participant 1 because this participant is unable to produce any of these letters) -\> **8 words in total**

```{r}
#| echo: false
#| message: false
#| warning: false 
#| label: fig-freq-testing3
#| fig-cap: "Evolution of the mean frequency of biased letters comparing two types of pair: pair including the biased participant (1-2, 1-3, and 1-4) and pair excluding the biased participant (2-3, 3-4, 2-4)."
#| fig-width: 10
#| fig-height: 8

# # compute frequency
# df_agg <- df %>%
#   filter(TypeTest == "ComGame",
#          Producer != "1") %>%
#   dplyr::group_by(GroupType, Round, pair) %>% 
#   dplyr::summarise(Words = paste(Word, collapse = "")) %>%
#   mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
#          unbiased_count = str_count(Words, "p") + str_count(Words, "s") + str_count(Words, "n") + str_count(Words, "i") + str_count(Words, "u") + str_count(Words, "e"),
#          total_count = str_count(Words, "\\S"),
#          Biased = ((biased_count / total_count)/2), #because there are 2 biased let
#          Normal = ((unbiased_count / total_count)/6)) %>% # because there are 6 unbiased let
#   dplyr::select(-c(biased_count, total_count, Words)) %>%
#   gather(TypeLetter, Freq, Biased:Normal) %>%
#   mutate(Freq = Freq*100)
# 
# # create this format that enable the nice plotting
# df_agg2 <- df_agg %>%
#   group_by(pair,Round, TypeLetter, GroupType) %>%
#   summarize(mean_freq = mean(Freq))  %>%
#   mutate(pair = as.factor(pair)) %>%
#   mutate(pair2 = pair) %>%
#   separate(pair2, c("parta", "partb"), "_") %>%
#   gather(condition, Producer, parta, partb) %>%
#   dplyr::select(-condition) %>%
#   mutate(Producer = as.factor(Producer),
#          Round = as.character(Round)) %>%
#   filter(Producer != "1")
# 
# # plot
# p <-  ggplot(df_agg2[df_agg2$TypeLetter=="Biased",], aes(x=Round, y=mean_freq, fill=Producer)) + geom_point()
# p <- add_grey_rect_1_9(p)
# p <- p +  labs(y="Mean frequency of biased letter (%)", x="Round", fill="Participant")  +
#   geom_dotplot(binaxis = "y", stackdir = "centerwhole", stackgroups = TRUE, binpositions = "all", binwidth = 0.5) +
#   facet_grid(GroupType ~ .) +
#   geom_hline(yintercept = init_freq_biased, linetype="dashed")+
#   geom_hline(yintercept = init_freq_unbiased, linetype="dashed")
# 
# p
```

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-freq-testing
#| fig-cap: "Change in the frequency of biased and unbiased letters in the first testing (before the communication game) and in the second testing (after the communication game) at a group-level. Each point represent a group, and the thin grey line indicate the within design (each group is tested before and after)."
#| fig-width: 12
#| fig-height: 7


# compute frequency
df_agg <- df %>%
  filter(TypeTest == "ComGame",
         !(Producer == "1" & GroupType == "Hetero")) %>%
  mutate(type = ifelse(GroupType == "Control", "Control", ifelse(grepl( "1", pair, fixed = TRUE), "Hetero_Biased", "Hetero_Unbiased"))) %>%
  dplyr::group_by(type, Round) %>% 
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Freq = (biased_count / total_count)) %>%
  dplyr::select(-c(biased_count, total_count, Words)) %>%
  mutate(Freq = Freq*100) %>%
  mutate(Round = as.factor(Round))


p <- ggplot(df_agg, aes(x=Round, y=Freq, color=type, group=type))+ 
  geom_point() 
p <- add_grey_rect_1_9(p) 
p <- p +   
  geom_hline(yintercept = init_freq_biased, linetype="dashed")+
  geom_point(size=5, position=position_dodge(width=0.5)) +   
  geom_line(size=1, position=position_dodge(width=0.5)) +   
  labs(y="Mean frequency (in %)", fill="Group")  
p 


# mod <- lmer(mean_freq ~ TypeLetter * TypeTest * GroupType + (1 | GroupNum), data=df_agg)
# summary(mod)

```

An interesting observation appears: in Round 3, pairs with unbiased individuals use less biased letters than the unbiased participants involved in the preceding rounds! One hypothesis is that these two unbiased participants have been paired with the biased participant in the preceding rounds and already start to adjust to them.

We merge these results over the rounds, to have a look at the global picture:

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-3-chapter
#| fig-cap: "Evolution of the mean frequency of biased letters comparing two types of pair: pair including the biased participant (1-2, 1-3, and 1-4) and pair excluding the biased participant (2-3, 3-4, 2-4)."
#| fig-width: 7
#| fig-height: 5

# compute frequency for heterogenous groups
df_agg_hetero <- df %>%
  filter(TypeTest == "ComGame",
         Producer != "1",
         GroupType=="Hetero") %>%
  mutate(TalkToBiased = ifelse(Guesser=="1", "Yes", "No")) %>% 
  dplyr::group_by(GroupType, GroupNum, Producer, TalkToBiased) %>% 
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Freq = ((biased_count / total_count))) %>%
  dplyr::select(-c(biased_count, total_count, Words)) %>%
  mutate(Freq = as.numeric(Freq*100))

# compute frequency for control groups
df_agg_control <- df %>%
  filter(TypeTest == "ComGame",
         GroupType=="Control") %>%
  dplyr::group_by(GroupType, GroupNum, Producer) %>% 
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Freq = ((biased_count / total_count))) %>% 
  dplyr::select(-c(biased_count, total_count, Words)) %>%
  mutate(Freq = as.numeric(Freq*100))

# ggplot(df_agg, aes(x=TypeLetter, y=Freq, fill=TalkToBiased))+
#   geom_violin(width=0.5, alpha=0.2) +
#   geom_point(pch = 21, position = position_jitterdodge(jitter.width=0.3) ) +
#   theme_bw(base_size=15) +
#   labs(y="Freq letter", x="Biased letter", fill="Talk to") +
#   facet_grid(GroupType ~ .)

# Compute mean and se for heterogenous groups
df_agg_hetero2 <- df_agg_hetero %>%
  group_by(GroupType, TalkToBiased) %>%
  summarize(se_freq = se(Freq),
            Freq = mean(Freq))

# Compute mean and se for control groups
df_agg_control2 <- df_agg_control %>%
  group_by(GroupType) %>%
  summarize(se_freq = se(Freq),
            Freq = mean(Freq)) %>%
  mutate(TalkToBiased=NA)

# add the value for color in hetero groups
df_agg2 <- df_agg_hetero2 %>% 
  mutate(ValueColor = df_agg_control2$Freq) %>%
  mutate(SeColor = df_agg_control2$se_freq) 

# Plot
ggplot(df_agg2, aes(x=TalkToBiased, y=Freq))+
  geom_line()+
  geom_violin(data=df_agg_hetero, aes(x=TalkToBiased, y=Freq, fill=TalkToBiased), alpha=0.3)+
  #geom_jitter(data=df_agg_hetero, aes(x=TalkToBiased, y=Freq, color=TalkToBiased), alpha=0.3)+
  geom_pointrange(data=df_agg_hetero2, aes(x=TalkToBiased, y=Freq, ymin=Freq-se_freq, ymax=Freq+se_freq),lwd=1.1, size=0.7) +
  theme_bw(base_size=20) +
  labs(y="Mean freq of biased letters (%)", x="Communicate with biased participant?") +
  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = ValueColor-SeColor, ymax = ValueColor+SeColor), alpha=0.1, fill="red") +
  geom_hline(aes(yintercept = ValueColor), color="red3", size=1)  +  
  geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
  guides(fill=FALSE) +
  theme(axis.title.y = element_text(size = 17),
        axis.title.x = element_text(size = 17))


# ggplot(df_agg2, aes(x=TalkToBiased, y=Freq))+
#   geom_line()+
#   #geom_violin(data=df_agg_hetero, aes(x=TalkToBiased, y=Freq, fill=TalkToBiased), alpha=0.3)+
#   #geom_jitter(data=df_agg_hetero, aes(x=TalkToBiased, y=Freq, color=TalkToBiased), alpha=0.3)+
#   geom_pointrange(data=df_agg2, aes(x=TalkToBiased, y=Freq, ymin=Freq-se_freq, ymax=Freq+se_freq), size=0.7) +
#   theme_bw(base_size=20) +
#   labs(y="Mean frequency of biased letters", x="Talk to biased participant?") +
#   geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = ValueColor-SeColor, ymax = ValueColor+SeColor), alpha=0.1, fill="red") +
#   geom_hline(aes(yintercept = ValueColor), color="red3", size=1)  +  
#   geom_hline(yintercept = init_freq_biased, linetype = "dashed") 


```

We build two models: one in which the group type is a fixed effect (but please note that this introduces a bias, since in control groups, there is no "talk to bias" or "talk to unbias" - instead, it reflects whether participants 2, 3, and 4 talk to participant1 or not).

This is **not** the model 5 refered in the main paper, since we also have here the control groups:

```{r }

# # compute frequency
df_agg <- df %>%
  filter(TypeTest == "ComGame",
         Producer != "1") %>%
  mutate(TalkToBiased = ifelse(Guesser=="1", "Yes", "No")) %>%
  dplyr::group_by(GroupType, GroupNum, Producer, TalkToBiased) %>%
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Freq = ((biased_count / total_count)/2)) %>%
  dplyr::select(-c(biased_count, total_count, Words)) %>%
  mutate(Freq = Freq*100) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_")) %>%
  mutate(PartID_unique = paste(GroupType, GroupNum, Producer, sep="_"))

# model
model <- lmer(Freq ~ GroupType * TalkToBiased + (1 | GroupID / PartID_unique), data=df_agg)
summary(model)

# print diagnostic plots
plots <- plot_model(model, type = "diag", show.ci = FALSE)
plots <- lapply(plots, function(p) p + theme(text = element_text(size = 12)))
ggarrange(plots[[1]], plots[[2]], plots[[3]], plots[[4]], nrow = 2, ncol = 2)


```

Then, we also look only at heterogeneous groups. This is the **model 5** refered in the main paper:


```{r }

# # compute frequency
df_agg <- df %>%
  filter(TypeTest == "ComGame",
         Producer != "1",
         GroupType=="Hetero") %>%
  mutate(TalkToBiased = ifelse(Guesser=="1", "Yes", "No")) %>%
  dplyr::group_by(GroupType, GroupNum, Producer, TalkToBiased) %>%
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Freq = ((biased_count / total_count)/2)) %>%
  dplyr::select(-c(biased_count, total_count, Words)) %>%
  mutate(Freq = Freq*100) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_")) %>%
  mutate(PartID_unique = paste(GroupType, GroupNum, Producer, sep="_"))

# model
model <- lmer(Freq ~ TalkToBiased + (1 | GroupID / PartID_unique), data=df_agg)
summary(model)

# print diagnostic plots
plots <- plot_model(model, type = "diag", show.ci = FALSE)
plots <- lapply(plots, function(p) p + theme(text = element_text(size = 12)))
ggarrange(plots[[1]], plots[[2]], plots[[3]], plots[[4]], nrow = 2, ncol = 2)


```

```{r}
#| echo: false
#| message: false
#| warning: false

# We apply a linear mixed-effect models, where we look at the frequency of biased letters for each participant. We study the effect of the variable "condition":
# 
#  - Heterogeneous, talk to biased
#  - Heterogeneous, talk to unbiased
#  - Control group, talk to both
#  
# The random effect are Group Num and Producer.
# 
# First, we include all variables:
# 
# 
# # compute frequency
# df_agg_hetero <- df %>%
#   filter(TypeTest == "ComGame",
#          Producer != "1",
#          GroupType=="Hetero") %>%
#   mutate(TalkToBiased = ifelse(Guesser=="1", "Biased", "Unbiased")) %>% 
#   dplyr::group_by(GroupType, GroupNum, Producer, TalkToBiased) %>% 
#   dplyr::summarise(Words = paste(Word, collapse = "")) %>%
#   mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
#          total_count = str_count(Words, "\\S"),
#          Freq = ((biased_count / total_count))) %>%
#   dplyr::select(-c(biased_count, total_count, Words)) %>%
#   mutate(Freq = as.numeric(Freq*100)) %>%
#   mutate(condition = paste("Hetero", TalkToBiased, sep="_")) %>%
#   ungroup() %>%
#   dplyr::select(-TalkToBiased)
# 
# df_agg_control <- df %>%
#   filter(TypeTest == "ComGame",
#          GroupType=="Control") %>%
#   dplyr::group_by(GroupType, GroupNum, Producer) %>% 
#   dplyr::summarise(Words = paste(Word, collapse = "")) %>%
#   mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
#          total_count = str_count(Words, "\\S"),
#          Freq = ((biased_count / total_count))) %>% 
#   dplyr::select(-c(biased_count, total_count, Words)) %>%
#   mutate(Freq = as.numeric(Freq*100)) %>%
#   mutate(condition = "Control")
# 
# df_agg <- rbind(df_agg_hetero, df_agg_control)
# df_agg <- df_agg %>% 
#   mutate(GroupID = paste(GroupType, GroupNum, sep="_")) %>%
#   mutate(PartID_unique = paste(GroupType, GroupNum, Producer, sep="_"))
# 
# # model <- lmer(Freq ~ condition + (1 | GroupID) + (1 | PartID_unique) , data=df_agg)
# # summary(model)
# 
# 
# model <- lmer(Freq ~ condition + (1 | GroupID), data=df_agg[df_agg$condition != "Hetero_Unbiased",])
# summary(model)
```



```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-freq-pair2
#| fig-cap: "Evolution of the mean frequency of biased letters comparing two types of pair: pair including the biased participant (1-2, 1-3, and 1-4) and pair excluding the biased participant (2-3, 3-4, 2-4)."
#| fig-width: 6
#| fig-height: 6

## We create an index for each participant: the difference in frequency of letter when this participant is talking to the Biased compared to when talking to the other. A high value in "yes" mean that the participant uses way less (biased or unbiased) letters when talking to the biased participant.
#
# df_agg3 <- df_agg %>%
#   spread(TalkToBiased, Freq) %>%
#   mutate(diff = No - Yes) 
# 
# ggplot(df_agg3, aes(x=GroupType, y = diff, fill=GroupType)) +
#   geom_boxplot(alpha=0.3, color="black") +
#   geom_jitter(pch = 21) +
#   geom_hline(yintercept = 0, linetype = "dashed") +
#   labs(y="no <- Adaptation -> yes")
# 
# model <- lmer(diff ~ GroupType + (1 | GroupNum), data=df_agg3)
# summary(model)

```


### Predictors of adaptability

#### Our measures of adaptability

We compute three measures of adaptability based on the ratio of letter frequency:

-   **Adapt1.** The first one reflects, for each participant, the difference between the frequency of biased letter in the *FirstTesting* and the frequency of biased letter in the *SecondTesting*. A larger number indicates a greater decrease in the number of biased letters in the participants' final vocabulary (so the participant adapted to the peculiarities of the biased participant). Conversely, a negative score for adaptability means that the person has increased the number of biased letters (so the participant did ***not*** adapt to the peculiarities of the biased participant).

-   **Adapt2.** The measure is very similar to the first one, except that here we do not look at the First and Second Testing, but at all interactions with the biased participants made from Round 1 to 9.

-   **Adapt3**. This measure is the most complex, and the most likely to efficiently represent adaptability. We arbitrarily created a score based on a decision tree, see image below:

![](Pictures/Adaptation_scale.jpg){width="780"}

-   Adapt4. This is similar to Adapt3, except that here, we look at the normalized distance between:

    -   d1: the new item produced and the item the partner has said

    -   d2: the new item produced and the last item produced by the participant.

        Then, we computed the Adapt4 as 2\*(1-d1) + d2 (see below)

        ![](Pictures/Adaptation_scale2.jpg)

We look at this only in **heterogenous** groups for Adapt1 and Adapt2, and for both groups (**heterogeneous and control**) in Adapt3.

```{r}
#| echo: false
#| message: false
#| warning: false 

# ------------------ADAPT1 --------------------- #
df_adapt1 <- df %>%
  filter(TypeTest == "SecondTesting" | TypeTest == "FirstTesting",
         Producer != "1",
         GroupType == "Hetero") %>%
  dplyr::group_by(GroupNum, TypeTest, Producer, GroupType) %>% 
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Biased = (biased_count / total_count)) %>%
  dplyr::select(-c(biased_count, total_count, Words)) %>%
  spread(TypeTest, Biased) %>%
  mutate(Adaptability1 = (FirstTesting - SecondTesting)*100) %>%
  dplyr::rename(PartID = Producer)

# ------------------ADAPT2 --------------------- #
df_adapt2 <- df %>%
  filter(TypeTest == "ComGame",
         Producer != "1",
         GroupType == "Hetero")  %>%
  mutate(TalkToBiased = ifelse(Guesser=="1", "Yes", "No")) %>%
  dplyr::group_by(GroupType, GroupNum, Producer, TalkToBiased) %>% 
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Biased = ((biased_count / total_count))) %>% 
  dplyr::select(-c(biased_count, total_count, Words)) %>%
  spread(TalkToBiased, Biased) %>%
  mutate(Adaptability2 = (No - Yes)*100) %>%
  dplyr::rename(PartID = Producer)

# ------------------ADAPT3 --------------------- #

# Initiliaze the data frame with the first word pronounced by all
df %>%
  filter(TypeTest == "FirstTesting") %>%
  dplyr::select(GroupID, Round, Producer, Shape, Word) %>%
  mutate(adapt3 = NA) -> df_adapt3

# filter dataframe to look at every Round for each group
for (gid in unique(df$GroupID)){
  for (myround in c(1:9)){
    for (mypair in unique(df$pair[df$TypeTest=="ComGame"])){
      subdf <- df %>%
        filter(TypeTest == "ComGame",
               GroupID == gid,
               Round == myround,
               pair == mypair) 
        subdf <- subdf[order(subdf$index),]
        
        # look at each shape, find who is the second producer
        for (myshape in unique(subdf$Shape)){
          id_second <- subdf$Producer[subdf$Shape == myshape][2]
          
          # Find out which word this person has listened to
          listen <- subdf$Word[subdf$Shape == myshape & subdf$Producer != id_second ]
          # ... and then which word this producer has produced
          produce <- subdf$Word[subdf$Shape == myshape & subdf$Producer == id_second ]
          
          # then retrieve in the memory what was the latest word pronound by this person
          subdf2 <- df_adapt3 %>% filter(GroupID == gid,
                            Shape == myshape,
                            Producer == id_second)
          latest_it <- subdf2$Word[length(subdf2$Word)]
          
          # Find what is the initial label for the word
          goodword <- myshape
          
          # Compute a measure of adaptability based on these items
          adapt3 <- compute_adapt3(goodword, latest_it, listen, produce)
          row <- c(gid, myround, id_second, myshape, produce, adapt3)
          
          # And add to dataframe
          df_adapt3[nrow(df_adapt3) + 1,] <- row
  
        }
     }
  }
}
df_adapt3$adapt3 <- as.numeric(df_adapt3$adapt3)
df_adapt3 <- df_adapt3 %>% separate(GroupID, c("GroupNum", "GroupType"))

# We first aggregate it per Participant, to see how adaptability evolves
df_adapt3 %>%
  filter(Round != 0) %>%
  dplyr::group_by(Producer, GroupNum, GroupType) %>%
  dplyr::summarize(Adaptability3 = mean(adapt3)) %>%
  dplyr::rename(PartID = Producer) -> adapt3_id


# ------------------ADAPT4--------------------- #
# Initiliaze the data frame with the first word pronounced by all
df %>%
  filter(TypeTest == "FirstTesting") %>%
  dplyr::select(GroupID, Round, Producer, Shape, Word) %>%
  mutate(adapt4 = NA) -> df_adapt4

# filter dataframe to look at every Round for each group
for (gid in unique(df$GroupID)){
  for (myround in c(1:9)){
    for (mypair in unique(df$pair[df$TypeTest=="ComGame"])){
      subdf <- df %>%
        filter(TypeTest == "ComGame",
               GroupID == gid,
               Round == myround,
               pair == mypair)
        subdf <- subdf[order(subdf$index),]
        
        # look at each shape, find who is the second producer
        for (myshape in unique(subdf$Shape)){
          id_second <- subdf$Producer[subdf$Shape == myshape][2]
          
          # Find out which word this person has listened to
          listen <- subdf$Word[subdf$Shape == myshape & subdf$Producer != id_second ]
          # ... and then which word this producer has produced
          produce <- subdf$Word[subdf$Shape == myshape & subdf$Producer == id_second ]
          
          # then retrieve in the memory what was the latest word pronound by this person
          subdf2 <- df_adapt4 %>% filter(GroupID == gid,
                            Shape == myshape,
                            Producer == id_second)
          latest_it <- subdf2$Word[length(subdf2$Word)]
          
          # Find what is the initial label for the word
          goodword <- myshape
          
          # Compute a measure of adaptability based on these items
          adapt4 <- compute_adapt4(latest_it, listen, produce)
          row <- c(gid, myround, id_second, myshape, produce, adapt4)
          
          # And add to dataframe
          df_adapt4[nrow(df_adapt4) + 1,] <- row
  
        }
     }
  }
}
df_adapt4$adapt4 <- as.numeric(df_adapt4$adapt4)
df_adapt4 <- df_adapt4 %>% separate(GroupID, c("GroupNum", "GroupType"))


# We first aggregate it per Participant, to see how adaptability evolves
df_adapt4 %>%
  filter(Round != 0) %>%
  dplyr::group_by(Producer, GroupNum, GroupType) %>%
  dplyr::summarize(Adaptability4 = mean(adapt4)) %>%
  dplyr::rename(PartID = Producer) -> adapt4_id

# --------------------------------------- #

# merge the two dataframe with previous data
df_other <- merge(df_other, df_adapt1[,c("GroupNum", "GroupType", "PartID", "Adaptability1")], by=c("GroupNum", "GroupType", "PartID"), all.x=TRUE)

# merge all
df_other <- merge(df_other, df_adapt2[,c("GroupNum", "GroupType", "PartID", "Adaptability2")], by=c("GroupNum", "GroupType", "PartID"), all.x=TRUE)

# merge all
df_other <- merge(df_other, adapt3_id[,c("GroupNum", "GroupType", "PartID", "Adaptability3")], by=c("GroupNum", "GroupType", "PartID"), all.x=TRUE)

# merge all
df_other <- merge(df_other, adapt4_id[,c("GroupNum", "GroupType", "PartID", "Adaptability4")], by=c("GroupNum", "GroupType", "PartID"), all.x=TRUE)




```

```{r}
#| echo: false
#| message: false
#| warning: false 
#| label: fig-distrib-adapt
#| fig-cap: "Correlation between the adaptability scores."
#| fig-width: 10
#| fig-height: 6
# What distribution for these measures?
# p1 <- ggplot(df_other, aes(x=Adaptability1)) +
#   geom_histogram()
# p1bis <- ggplot(df_other, aes(x=Adaptability1)) +
#   geom_density()
# p2 <- ggplot(df_other, aes(x=Adaptability2)) +
#   geom_histogram()
# p2bis <- ggplot(df_other, aes(x=Adaptability2)) +
#   geom_density()
# p3 <- ggplot(df_other, aes(x=Adaptability3)) +
#   geom_histogram()
# p3bis <- ggplot(df_other, aes(x=Adaptability3)) +
#   geom_density()
# p4 <- ggplot(df_other, aes(x=Adaptability4)) +
#   geom_histogram()
# p4bis <- ggplot(df_other, aes(x=Adaptability4)) +
#   geom_density()
# grid.arrange(p1, p2, p3,p4, ncol=4, nrow=1)
```

Do these measures correlate with each other, and how are they distributed?

```{r }
#| echo: false
#| message: false
#| warning: false 
#| label: fig-corr-adapt
#| fig-cap: "Correlation between the adaptability scores."
#| fig-width: 7
#| fig-height: 6

df_other %>%
  dplyr::select(Adaptability1, Adaptability2, Adaptability3, Adaptability4) %>%
  drop_na() %>%
  ggpairs(lower=list(continuous=wrap("smooth", colour="black")),
          upper = list(continuous = wrap("cor", size=6, colour = "black"))) +
  theme(strip.text = element_text(size = 10),
        axis.text = element_text(size = 10))

# # plot
# p1 <- ggplot(df_other, aes(x=Adaptability1, y=Adaptability2)) +
#   geom_point()+
#   geom_smooth(method="lm")
# p2 <- ggplot(df_other, aes(x=Adaptability2, y=Adaptability3)) +
#   geom_point()+
#   geom_smooth(method="lm")
# p3 <- ggplot(df_other, aes(x=Adaptability1, y=Adaptability3)) +
#   geom_point()+
#   geom_smooth(method="lm")
# grid.arrange(p1, p2, p3, ncol= 3)
# 
# # corr 1 - 2
# p12 <- cor(df_other$Adaptability1[is.na(df_other$Adaptability1)==FALSE], df_other$Adaptability2[is.na(df_other$Adaptability1)==FALSE], method = "pearson")
# s12 <- cor(df_other$Adaptability1[is.na(df_other$Adaptability1)==FALSE], df_other$Adaptability2[is.na(df_other$Adaptability1)==FALSE], method = "spearman")
# 
# # corr 2 - 3
# p23 <- cor(df_other$Adaptability2[is.na(df_other$Adaptability2)==FALSE & is.na(df_other$Adaptability3)==FALSE], df_other$Adaptability3[is.na(df_other$Adaptability2)==FALSE & is.na(df_other$Adaptability3)==FALSE], method="pearson")
# s23 <- cor(df_other$Adaptability2[is.na(df_other$Adaptability2)==FALSE & is.na(df_other$Adaptability3)==FALSE], df_other$Adaptability3[is.na(df_other$Adaptability2)==FALSE & is.na(df_other$Adaptability3)==FALSE], method="spearman")
# 
# # corr 1 - 3
# p13 <- cor(df_other$Adaptability1[is.na(df_other$Adaptability1)==FALSE & is.na(df_other$Adaptability3)==FALSE], df_other$Adaptability3[is.na(df_other$Adaptability1)==FALSE & is.na(df_other$Adaptability3)==FALSE], method="pearson")
# s13 <- cor(df_other$Adaptability1[is.na(df_other$Adaptability1)==FALSE & is.na(df_other$Adaptability3)==FALSE], df_other$Adaptability3[is.na(df_other$Adaptability1)==FALSE & is.na(df_other$Adaptability3)==FALSE], method="spearman")

```

The correlation netween the measure for Adaptability 1 and 2 is quite low, while it should be higher.

```{r}
#| echo: false
#| message: false
#| warning: false 
#| label: fig-evolution-adapt3
#| fig-cap: "Evolution of Adaptability 3 with time."
#| fig-width: 9
#| fig-height: 7
 
# How does the third measure of adaptability evolve with time?

# # We now have a measure for each participant in each Round, and each interaction. 
# # We first aggregate it per Round, to see how adaptability evolves
# df_adapt3 %>%
#   filter(Round != 0) %>%
#   dplyr::group_by(Round, GroupType, GroupNum) %>%
#   dplyr::summarize(mean_adapt3 = mean(adapt3)) -> adapt3_round
# 
# # show evolution per round
# p <- ggplot(data = adapt3_round, aes(x=Round, y=mean_adapt3, color=GroupNum, group=GroupNum)) + geom_point()
# p <- add_grey_rect_0_10(p)
# p <- p + geom_point(size=5) +
#   geom_line(size=1) +
#   facet_grid(GroupType ~ .) +
#   geom_hline(yintercept = 0, linetype="dashed") +
#   labs(y="Adapt3") +
#   scale_color_viridis_d()
# p

```

#### Summary predictors

However, we will still try to observe how our different metrics (such as age, gender...: see [Method]) correlate with the adaptability scores. First, we look at the variable distribution.

```{r}
#| echo: false
#| message: false
#| warning: false 
#| label: fig-distrib-var
#| fig-cap: "Distribution of the scores. Red shows the results for the control group, blue shows the results for the heterogenous group."
#| fig-width: 10
#| fig-height: 6

p1 <- ggplot(df_other, aes(x=prosoc, fill=GroupType)) +
  geom_density(alpha=0.5) +
  guides(fill=FALSE)
p2 <- ggplot(df_other, aes(x=WorkingMem, fill=GroupType)) +
  geom_density(alpha=0.5) +
  guides(fill=FALSE)
p3 <- ggplot(df_other, aes(x=CogFlexibility, fill=GroupType)) +
  geom_density(alpha=0.5) +
  guides(fill=FALSE)
p4 <- ggplot(df_other, aes(x=DictatorGame, fill=GroupType)) +
  geom_histogram(stat="count", position = position_dodge()) +
  guides(fill=FALSE)
p5 <- ggplot(df_other, aes(x=Age, fill=GroupType)) +
  geom_density(alpha=0.5) +
  guides(fill=FALSE)
p6 <- ggplot(df_other, aes(x=Gender, fill=GroupType)) +
  geom_histogram(stat="count", position = position_dodge()) +
  guides(fill=FALSE)
p7 <- ggplot(df_other, aes(x=AccLearning, fill=GroupType)) +
  geom_density(alpha=0.5) +
  guides(fill=FALSE)
p8 <- ggplot(df_other, aes(x=ProducSim, fill=GroupType)) +
  geom_density(alpha=0.5) +
  guides(fill=FALSE)

grid.arrange(p1, p2, p3, p4, p5, p6, p7, p8, ncol=4, nrow=2)
```

Just a reminder:

-   the global working memory is the overall inverse efficiency (reaction time divided by accuracy) in the task-switching experiment, only in letters+numbers task: **the higher, the worst the workig memory**
-   the cognitive flexibility is measured in the letters+numbers task in the task switching experiment. It is the normalized difference (by time) of the time needed to switch between two tasks and the time needed when performing the same task: **the higher, the worst the cognitive flexibility**

Let's look at the correlations between the numerical variables:

```{r}
#| echo: false
#| message: false
#| warning: false 
#| label: fig-corr-predictors
#| fig-cap: "Correlation between the predictors."
#| fig-width: 12
#| fig-height: 11

df_other %>%
  dplyr::select(prosoc, DictatorGame, Age, WorkingMem, CogFlexibility, AccLearning, ProducSim, Gender) %>%
  drop_na() %>%
  ggpairs(lower=list(continuous=wrap("smooth", colour="black")),
          upper = list(continuous = wrap("cor", size=6, colour = "black"))) +
  theme(strip.text = element_text(size = 10),
        axis.text = element_text(size = 10))
```

#### Predicting adaptation

```{r}

# Create new dataset
df_other_z <- df_other %>%
  mutate(prosoc_z = scale(prosoc, center = TRUE, scale = FALSE),
         WorkingMem_z = scale(WorkingMem, center = TRUE, scale = FALSE),
         CogFlexibility_z = scale(CogFlexibility, center = TRUE, scale = FALSE),
         DictatorGame_z = scale(DictatorGame, center = TRUE, scale = FALSE),
         Age_z = scale(Age, center = TRUE, scale = FALSE),
         AccLearning_z = scale(AccLearning, center = TRUE, scale = FALSE),
         ProducSim_z = scale(ProducSim, center = TRUE, scale = FALSE),
         Gender_z = as.numeric(as.factor(Gender)) - 1)

# create df with only hetero
df_other2_z <- df_other_z %>% filter(GroupType == "Hetero")
df_other2 <- df_other %>% filter(GroupType == "Hetero")

# rename column
df_other2_z$GroupID <- paste(df_other2_z$GroupType, df_other2_z$GroupNum, sep="_")
df_other_z$GroupID <- paste(df_other_z$GroupType, df_other_z$GroupNum, sep="_")


```

We can look at all scores together:

```{r}

# df_other  %>%
#   dplyr::select(PartID, prosoc, DictatorGame, Age, WorkingMem, CogFlexibility, AccLearning, ProducSim, Adaptability1, Adaptability2, Adaptability3, Adaptability4) %>%
#   pivot_longer(names_to = "Feature", values_to = "Value", -c(PartID, Adaptability1, Adaptability2, Adaptability3, Adaptability4)) %>%
#   pivot_longer(names_to = "Density", values_to = "dens_Value", -c(PartID, Feature, Value) ) %>%
#   drop_na %>%
#   ggplot(aes(x = Value, y = dens_Value)) +
#   geom_point() +
#   geom_smooth(method = "lm") +
#   facet_grid(Density~Feature, scales = "free") +
#   theme(legend.position = "top") +
#   labs(x="",y="")

```

But, in order to see more clearly (and also add the effect of gender, which we could not see in the plot above, we will have a closer look at each of our Adaptability measures.

We first look at the measure using the score of ***Adaptability1***:

(please note that this variable only includes participants from heterogenous groups)

```{r }
#| echo: false
#| message: false
#| warning: false 
#| label: fig-adapt1
#| fig-cap: "Correlations between the different individual measures and our score for Adaptability1. Reminder: in the dictator game 1 is keeping all the money for oneself, 5 is to share it all."
#| fig-width: 10
#| fig-height: 8


# plot
p1 <- ggplot(df_other2, aes(x=prosoc, y=Adaptability1))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15) 

p2 <- ggplot(df_other2, aes(x=WorkingMem, y=Adaptability1))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

p3 <- ggplot(df_other2, aes(x=CogFlexibility, y=Adaptability1))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

p4 <- ggplot(df_other2, aes(x=DictatorGame, y=Adaptability1))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15) 

p5 <- ggplot(df_other2, aes(x=Age, y=Adaptability1))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15) 

p6 <- ggplot(df_other2, aes(x=Gender, y=Adaptability1))+
  geom_boxplot()+
  theme_bw(base_size=15) 

p7 <- ggplot(df_other2, aes(x=AccLearning, y=Adaptability1))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

p8 <- ggplot(df_other2, aes(x=ProducSim, y=Adaptability1))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

grid.arrange(p1,p2,p3,p4,p5,p6,p7,p8, nrow=2, ncol=4)
```

Model:

```{r}

# Model adaptability 1
model <- lmer(Adaptability1 ~ prosoc_z + WorkingMem_z + CogFlexibility_z + DictatorGame_z + Age_z + Gender_z + AccLearning_z + ProducSim_z + (1 | GroupNum), data = df_other2_z)
summary(model)
r.squaredGLMM(model)

# print diagnostic plots
plots <- plot_model(model, type = "diag", show.ci = FALSE)
plots <- lapply(plots, function(p) p + theme(text = element_text(size = 12)))
ggarrange(plots[[1]], plots[[2]], plots[[3]], plots[[4]], nrow = 2, ncol = 2)

```

RÂ²m focuses solely on the fixed effects' contribution to explaining variance, while RÂ²c takes into account both the fixed effects and the random effects.

We look at the exact same plots using the score for ***Adaptability2***:

```{r }
#| echo: false
#| message: false
#| warning: false 
#| label: fig-adapt2
#| fig-cap: "Correlations between the different individual measures and our score for Adaptability2. Reminder: in the dictator game 1 is keeping all the money for oneself, 5 is to share it all."
#| fig-width: 10
#| fig-height: 8


# plot
p1 <- ggplot(df_other2, aes(x=prosoc, y=Adaptability2))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15) 

p2 <- ggplot(df_other2, aes(x=WorkingMem, y=Adaptability2))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

p3 <- ggplot(df_other2, aes(x=CogFlexibility, y=Adaptability2))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

p4 <- ggplot(df_other2, aes(x=DictatorGame, y=Adaptability2))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15) 

p5 <- ggplot(df_other2, aes(x=Age, y=Adaptability2))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15) 

p6 <- ggplot(df_other2, aes(x=Gender, y=Adaptability2))+
  geom_boxplot()+
  theme_bw(base_size=15) 

p7 <- ggplot(df_other2, aes(x=AccLearning, y=Adaptability2))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

p8 <- ggplot(df_other2, aes(x=ProducSim, y=Adaptability2))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

grid.arrange(p1,p2,p3,p4,p5,p6,p7,p8, nrow=2, ncol=4)

```

Model:

```{r}

# model Adaptability 2
model <- lmer(Adaptability1 ~ prosoc_z + WorkingMem_z + CogFlexibility_z + DictatorGame_z + Age_z + Gender_z + AccLearning_z + ProducSim_z + (1 | GroupID), data = df_other2_z)
summary(model)
r.squaredGLMM(model)

# print diagnostic plots
plots <- plot_model(model, type = "diag", show.ci = FALSE)
plots <- lapply(plots, function(p) p + theme(text = element_text(size = 12)))
ggarrange(plots[[1]], plots[[2]], plots[[3]], plots[[4]], nrow = 2, ncol = 2)

```

We look at the exact same plots using the score for ***Adaptability3***:

```{r }
#| echo: false
#| message: false
#| warning: false 
#| label: fig-adapt3
#| fig-cap: "Correlations between the different individual measures and our score for Adaptability3. Reminder: in the dictator game 1 is keeping all the money for oneself, 5 is to share it all."
#| fig-width: 10
#| fig-height: 8


# plot
p1 <- ggplot(df_other, aes(x=prosoc, y=Adaptability3))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15) 

p2 <- ggplot(df_other, aes(x=WorkingMem, y=Adaptability3))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

p3 <- ggplot(df_other, aes(x=CogFlexibility, y=Adaptability3))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

p4 <- ggplot(df_other, aes(x=DictatorGame, y=Adaptability3))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15) 

p5 <- ggplot(df_other, aes(x=Age, y=Adaptability3))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15) 

p6 <- ggplot(df_other, aes(x=Gender, y=Adaptability3))+
  geom_boxplot()+
  theme_bw(base_size=15) 

p7 <- ggplot(df_other, aes(x=AccLearning, y=Adaptability3))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

p8 <- ggplot(df_other, aes(x=ProducSim, y=Adaptability3))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

grid.arrange(p1,p2,p3,p4,p5,p6,p7,p8, nrow=2, ncol=4)

```

Model, including production from the biased participant:

```{r}

# Model adaptability 2
model <- lmer(Adaptability2 ~ prosoc_z + WorkingMem_z + CogFlexibility_z + DictatorGame_z + Age_z + Gender_z + AccLearning_z + ProducSim_z + (1 | GroupID), data = df_other_z)
summary(model)
r.squaredGLMM(model)

# print diagnostic plots
plots <- plot_model(model, type = "diag", show.ci = FALSE)
plots <- lapply(plots, function(p) p + theme(text = element_text(size = 12)))
ggarrange(plots[[1]], plots[[2]], plots[[3]], plots[[4]], nrow = 2, ncol = 2)


```

Model, excluding production from the biased participant:

```{r}
model <- lmer(Adaptability3 ~ prosoc_z + WorkingMem_z + CogFlexibility_z + DictatorGame_z + Age_z + Gender_z + AccLearning_z + ProducSim_z + (1 | GroupID), data = df_other_z[!(df_other_z$PartID==1 & df_other_z$GroupType=="Hetero"),])
summary(model)
r.squaredGLMM(model)

# print diagnostic plots
plots <- plot_model(model, type = "diag", show.ci = FALSE)
plots <- lapply(plots, function(p) p + theme(text = element_text(size = 12)))
ggarrange(plots[[1]], plots[[2]], plots[[3]], plots[[4]], nrow = 2, ncol = 2)


```

We look at the exact same plots using the score for ***Adaptability4***:

```{r }
#| echo: false
#| message: false
#| warning: false 
#| label: fig-adapt4
#| fig-cap: "Correlations between the different individual measures and our score for Adaptability4. Reminder: in the dictator game 1 is keeping all the money for oneself, 5 is to share it all."
#| fig-width: 10
#| fig-height: 8


# plot
p1 <- ggplot(df_other, aes(x=prosoc, y=Adaptability4))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15) 

p2 <- ggplot(df_other, aes(x=WorkingMem, y=Adaptability4))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

p3 <- ggplot(df_other, aes(x=CogFlexibility, y=Adaptability4))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

p4 <- ggplot(df_other, aes(x=DictatorGame, y=Adaptability4))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15) 

p5 <- ggplot(df_other, aes(x=Age, y=Adaptability4))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15) 

p6 <- ggplot(df_other, aes(x=Gender, y=Adaptability4))+
  geom_boxplot()+
  theme_bw(base_size=15) 

p7 <- ggplot(df_other, aes(x=AccLearning, y=Adaptability4))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

p8 <- ggplot(df_other, aes(x=ProducSim, y=Adaptability4))+
  geom_point()+
  geom_smooth(method="lm") +
  theme_bw(base_size=15)

grid.arrange(p1,p2,p3,p4,p5,p6,p7,p8, nrow=2, ncol=4)


```

Model including the production from the biased participant:

```{r}

# Model adaptability 4
model <- lmer(Adaptability4 ~ prosoc_z + WorkingMem_z + CogFlexibility_z + DictatorGame_z + Age_z + Gender_z + AccLearning_z + ProducSim_z + (1 | GroupID), data = df_other_z)

summary(model)
r.squaredGLMM(model)
car::vif(model)

# print diagnostic plots
plots <- plot_model(model, type = "diag", show.ci = FALSE)
plots <- lapply(plots, function(p) p + theme(text = element_text(size = 12)))
ggarrange(plots[[1]], plots[[2]], plots[[3]], plots[[4]], nrow = 2, ncol = 2)


```


Model excluding productions from the biased participants in heterogenous groups:

```{r}

model <- lmer(Adaptability4 ~ prosoc + WorkingMem + CogFlexibility + DictatorGame + Age + Gender + AccLearning + ProducSim + (1 | GroupID), data = df_other_z[!(df_other_z$PartID==1 & df_other_z$GroupType=="Hetero"),])
summary(model)
r.squaredGLMM(model)
car::vif(model)

# model <- lmer(Adaptability4 ~ prosoc*Age*Gender*CogFlexibility*ProducSim + (1 | GroupID), data = df_other)
# summary(model)

```


```{r}

```

Let's have a look at how the Adaptbility score of participants evolve with time:

```{r}
# We first aggregate it per Participant, to see how adaptability evolves
df_adapt4 %>%
  filter(Round != 0) %>%
  dplyr::group_by(GroupType, Round) %>%
  dplyr::summarize(Adaptability4 = mean(adapt4))  -> adapt44

ggplot(adapt44, aes(x=Round, y=Adaptability4, color=GroupType, group=GroupType)) +
  geom_point() +
  geom_line() + 
  geom_smooth()
```

# Chapter plots

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-1-chapter
#| fig-cap: "Evolution of stability aggregated with time for each type of group: everyone (all) or everyone except the biased participant (Without Biased)"
#| fig-width: 12
#| fig-height: 5

ggarrange(p_comsuccess, p_converg, p_distlabel, ncol=3, labels="AUTO", common.legend = TRUE, legend="bottom", font.label = list(size = 16, color = "black"))
```

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-2-chapter
#| fig-cap: ""
#| fig-width: 11
#| fig-height: 5

# # compute frequency (only biased letters)
# df_agg <- df %>%
#   filter(TypeTest != "PassiveExposure",
#          !(Producer == "1" & GroupType == "Hetero")) %>%
#   dplyr::group_by(GroupType, GroupNum, Round) %>% 
#   dplyr::summarise(Words = paste(Word, collapse = "")) %>%
#   mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
#          total_count = str_count(Words, "\\S"),
#          Freq = (biased_count / total_count)*100) %>%
#   mutate(GroupID = paste(GroupType, GroupNum, sep="_"))  %>%
#   mutate(Round2 = ifelse(Round == 10, 0, ifelse(Round == 9, 1, ifelse(Round==8, 2, ifelse(Round==7, 3, ifelse(Round==6, 4, ifelse(Round==5, 5, ifelse(Round==4, 6, ifelse(Round==3, 7, ifelse(Round==2, 8, ifelse(Round==1, 9, ifelse(Round==0, 10, NA))))))))))))
# 
# # plot
# p_round <- ggplot(df_agg[!(df_agg$Round == 0 |df_agg$Round==10),], aes(x=Round, y=Freq, color=GroupType, group = interaction(GroupNum, GroupType)))+ geom_point()
# p_round <- add_grey_rect_1_9(p_round)
# p_round <- p_round + 
#   geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
#   geom_point(alpha=0.5, size=1)+
#   geom_line(alpha=0.5)+
#   geom_smooth(method="lm", data=df_agg[!(df_agg$Round == 0 |df_agg$Round==10),], aes(x=Round, y=Freq, color=GroupType, group = GroupType)) +
#   labs(y="Mean freq of biased letters (%)    ", fill="Group") +
#   #facet_grid(GroupType ~ .) +
#   scale_x_continuous(breaks = c(0:10)) +
#   theme(axis.title.y = element_text(size = 17),
#         axis.title.x = element_text(size = 17)) +
#   scale_x_continuous(breaks = 1:9)
# 
# 
# 
# 
# # compute frequency (only biased letters)
# df_agg <- df %>%
#   filter(TypeTest=="FirstTesting" | TypeTest=="SecondTesting",
#          !(Producer == "1" & GroupType == "Hetero")) %>%
#   dplyr::group_by(GroupType, GroupNum, Round, TypeTest) %>% 
#   dplyr::summarise(Words = paste(Word, collapse = "")) %>%
#   mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
#          total_count = str_count(Words, "\\S"),
#          Freq = (biased_count / total_count)*100) %>%
#   dplyr::select(-c(biased_count, total_count, Words)) %>%
#   mutate(GroupID = paste(GroupType, GroupNum, sep="_"))  %>%
#   mutate(Round2 = ifelse(Round == 10, 0, ifelse(Round == 9, 1, ifelse(Round==8, 2, ifelse(Round==7, 3, ifelse(Round==6, 4, ifelse(Round==5, 5, ifelse(Round==4, 6, ifelse(Round==3, 7, ifelse(Round==2, 8, ifelse(Round==1, 9, ifelse(Round==0, 10, NA)))))))))))) %>%
#   mutate(TypeTest = case_when(TypeTest == "FirstTesting" ~ "First Test",
#                               TypeTest == "SecondTesting" ~ "Last Test")) %>%
#   mutate(TypeTest = as.factor(TypeTest)) %>%
#   mutate(GroupType = as.character(GroupType)) %>%
#   mutate(GroupType = case_when(GroupType=="Hetero" ~ "Heterogenous",
#                                GroupType=="Control" ~ "Control")) %>%
#   mutate(GroupType = factor(GroupType, levels=c("Control", "Heterogenous")))
# 
# 
# # Plot
# p_test <- ggplot(df_agg, aes(x=TypeTest, y=Freq, fill=GroupType))+
#   geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
#   geom_point(data=df_agg, aes(x=TypeTest, y=Freq, group=GroupNum), size=2) +
#   geom_boxplot(color="black", alpha=0.7,position= position_dodge(), width=0.3)+
#   theme_bw(base_size=20) +
#   geom_line(data=df_agg, aes(x=TypeTest, y=Freq, group=GroupNum), color="grey")+
#   labs(x="", y="Mean freq of biased letters (%)") +
#   facet_grid(. ~ GroupType) +
#   guides(fill=FALSE, color=FALSE) +
#   theme(axis.title.y = element_text(size = 17))
# 
# 
# ggarrange(p_round, p_test, ncol=2, nrow=1, labels="AUTO", common.legend = TRUE, legend="bottom", font.label = list(size = 16, color = "black"))

```

```{r}
#| echo: false
#| message: false
#| warning: false
#| label: fig-2-chapterbis
#| fig-cap: ""
#| fig-width: 11
#| fig-height: 5

# compute frequency (only biased letters)
df_agg <- df %>%
  filter(TypeTest != "PassiveExposure",
         !(Producer == "1" & GroupType == "Hetero")) %>%
  dplyr::group_by(GroupType, GroupNum, Round) %>% 
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Freq = (biased_count / total_count)*100) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))  %>%
  mutate(Round2 = ifelse(Round == 10, 0, ifelse(Round == 9, 1, ifelse(Round==8, 2, ifelse(Round==7, 3, ifelse(Round==6, 4, ifelse(Round==5, 5, ifelse(Round==4, 6, ifelse(Round==3, 7, ifelse(Round==2, 8, ifelse(Round==1, 9, ifelse(Round==0, 10, NA))))))))))))

# plot
p_round <- ggplot(df_agg, aes(x=Round, y=Freq, color=GroupType, group = interaction(GroupNum, GroupType)))+ geom_point()
p_round <- add_grey_rect_0_10(p_round)
p_round <- p_round + 
  geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
  geom_point(alpha=0.5, size=1)+
  geom_line(alpha=0.5)+
  geom_smooth(method="lm", data=df_agg, aes(x=Round, y=Freq, color=GroupType, group = GroupType)) +
  labs(y="Mean freq of biased letters (%)    ", fill="Group") +
  #facet_grid(GroupType ~ .) +
  scale_x_continuous(breaks = c(0:10)) +
  theme(axis.title.y = element_text(size = 17),
        axis.title.x = element_text(size = 17)) +
  ylim(17,42.5)

# compute frequency (only biased letters)
df_agg <- df %>%
  filter(TypeTest=="FirstTesting" | TypeTest=="SecondTesting",
         !(Producer == "1" & GroupType == "Hetero")) %>%
  dplyr::group_by(GroupType, GroupNum, Round, TypeTest) %>% 
  dplyr::summarise(Words = paste(Word, collapse = "")) %>%
  mutate(biased_count = str_count(Words, "k") + str_count(Words, "a"),
         total_count = str_count(Words, "\\S"),
         Freq = (biased_count / total_count)*100) %>%
  dplyr::select(-c(biased_count, total_count, Words)) %>%
  mutate(GroupID = paste(GroupType, GroupNum, sep="_"))  %>%
  mutate(Round2 = ifelse(Round == 10, 0, ifelse(Round == 9, 1, ifelse(Round==8, 2, ifelse(Round==7, 3, ifelse(Round==6, 4, ifelse(Round==5, 5, ifelse(Round==4, 6, ifelse(Round==3, 7, ifelse(Round==2, 8, ifelse(Round==1, 9, ifelse(Round==0, 10, NA)))))))))))) %>%
  mutate(TypeTest = case_when(TypeTest == "FirstTesting" ~ "FirstTest",
                              TypeTest == "SecondTesting" ~ "LastTest")) %>%
  mutate(TypeTest = as.factor(TypeTest)) %>%
  mutate(GroupType = as.character(GroupType)) %>%
  mutate(GroupType = case_when(GroupType=="Hetero" ~ "Heterogenous",
                               GroupType=="Control" ~ "Control")) %>%
  mutate(GroupType = factor(GroupType, levels=c("Control", "Heterogenous")))


# Plot
p_test <- ggplot(df_agg, aes(x=TypeTest, y=Freq, fill=GroupType))+
  geom_hline(yintercept = init_freq_biased, linetype = "dashed") +
  geom_point(data=df_agg, aes(x=TypeTest, y=Freq, group=GroupNum), size=2) +
  geom_boxplot(color="black", alpha=0.7,position= position_dodge(), width=0.3)+
  theme_bw(base_size=20) +
  geom_line(data=df_agg, aes(x=TypeTest, y=Freq, group=GroupNum), color="grey")+
  labs(x="", y="Mean freq of biased letters (%)") +
  facet_grid(. ~ GroupType) +
  guides(fill=FALSE, color=FALSE) +
  theme(axis.title.y = element_text(size = 17)) +
  ylim(17,39)


ggarrange(p_round, p_test, ncol=2, nrow=1, labels="AUTO", common.legend = TRUE, legend="bottom", font.label = list(size = 16, color = "black"))

```
